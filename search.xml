<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[APK瘦身最佳实践]]></title>
      <url>http://tonnyl.github.io/2017/04/17/Best-practice-of-reducing-apk-size/</url>
      <content type="html"><![CDATA[<p>本篇文章将介绍如何对APK文件进行瘦身。<br><a id="more"></a></p>
<p>在开始对APK进行正式的减肥之前，我们先来了解一下APK包的构成，这样才好对症下药嘛。知己知彼方能百战不殆。</p>
<h3 id="APK文件内容速揽"><a href="#APK文件内容速揽" class="headerlink" title="APK文件内容速揽"></a>APK文件内容速揽</h3><p>我们可以通过 <code>unzip &lt;apkname&gt;.apk</code> 命令实现对apk的解压(你也可以直接将<code>&lt;apkname&gt;.apk</code>更名为<code>&lt;apkname&gt;.zip</code>后直接通过解压软件解压)。解压后，我们就会得到一个文件夹了，里面包含了:</p>
<pre><code>AndroidManifest.xml
/assets
classes.dex
classes2.dex
...
/lib
    /arm64-v8a
    /armeabi-v7a
    /mips
    /x86
    /x86_64
/META-INF
    CERT.RSA
    CERT.SF
    MANIFEST.MF
/res
    /anim
    ...
resources.arsc
</code></pre><p>各个文件和目录的作用是什么呢？</p>
<table>
<thead>
<tr>
<th>文件/目录</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>AndroidManifest.xml</td>
<td>清单文件，列出了应用的名称，版本，权限等信息。</td>
</tr>
<tr>
<td>assets</td>
<td>配置文件，放置一些本地资源，例如本地html，可以通过使用<code>AssetManager</code>检索。</td>
</tr>
<tr>
<td>classes.dex, classes2.dex</td>
<td>编译后的字节码文件，能够被Dalvik/ART理解。</td>
</tr>
<tr>
<td>lib</td>
<td>存放特定平台使用的编译后的.so文件，每一个子文件夹对应一个特定的平台，例如<code>armeabi</code>, <code>armeabi-v7a</code>, <code>arm64-v8a</code>, <code>x86</code>, <code>x86_64</code>, and <code>mips</code>.</td>
</tr>
<tr>
<td>META-NIF</td>
<td>包含 <code>CERT.RSA</code>, <code>CERT.SF</code>, <code>MANIFEST.MF</code>， 存放的签名信息，用于保证系统的安全性和APK文件的完整性。</td>
</tr>
<tr>
<td>res</td>
<td>存放没有被编译到 <code>resources.arsc</code>文件中的资源文件。</td>
</tr>
<tr>
<td>resouces.arsc</td>
<td>编译后的二进制资源文件。存放 <code>res/values/</code> 目录下的所有XML内容。打包工具对XML内容进行提取，编译为二进制，并进行分类，其中，XML内容包含了不同语言的strings和styles，同时还包含没有被直接打包至 <code>resources.arsc</code> 文件的其他文件的路径，例如布局文件和图片文件。</td>
</tr>
</tbody>
</table>
<p>OK，既然我们已经了解了APK的各个组成部分，那么我们就可以针对下面的三个组成部分，采取逐个击破的方式，达到缩减APK体积的目的：</p>
<ul>
<li><a href="#Java代码">Java代码</a></li>
<li><a href="#资源文件">资源文件</a></li>
<li><a href="#navtive-code">Native Code</a></li>
<li><a href="#其他">其他</a></li>
</ul>
<h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><p>我们可以使用Proguard，在编译时对Java代码进行混淆，优化和压缩。Proguard对代码进行遍历，然后剔除其中未被使用的冗余的代码，并对类，属性，接口等进行重命名，从而达到瘦身的目的。</p>
<p>我们可以在 <code>build.gradle</code> 文件中配置Proguard。</p>
<pre><code class="groovy">buildTypes {

        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }

    }
</code></pre>
<p>在未使用Proguard之前，我们的APK体积达到了13.9M。</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1feosjj5w32j30hx081wfa.jpg" alt=""></p>
<p>开启Proguard后，APK的体积缩减到了10.1M。可见，效果还是很明显的。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1feotydfii8j30i4087js4.jpg" alt=""></p>
<p>除此之外，微信的工程师还开源了一个项目，可以直接对APK进行处理，缩小体积。具体的使用方法：<a href="https://github.com/shwenzhang/AndResGuard。" target="_blank" rel="external">https://github.com/shwenzhang/AndResGuard。</a></p>
<h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><h4 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h4><p>由于Proguard只对Java代码起作用，对于资源文件，它就无能为力了。这个时候，<code>Lint</code>就派上用场了。Lint是一个静态的代码分析器，我们可以通过在 <code>Android Studio</code> -&gt; <code>Analyze</code> -&gt; <code>Inspect code...</code> ， 选择范围即可开始就检查。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1feowjdymlnj30sc0puq71.jpg" alt=""></p>
<p>Lint在检查完成后，会提供一份详细的资源文件清单，并且将没有用到的资源在 <code>UnusedResources:Unused resources</code> 区域。只要我们没有通过反射使用这些资源，就可以放心的删掉它们了。</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1feowa244znj31kw0jpjzc.jpg" alt=""></p>
<p>下面是我根据lint的提示，剔除了部分无用资源后，APK的体积：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1feow8ygb4fj30hz089js4.jpg" alt=""></p>
<p>Notice：需要注意的是，Lint并不会扫描 <code>assets</code> 目录，所以最好还是手动的检查一下 <code>assets</code> 目录下是否有未被使用的文件吧。</p>
<p>我们还可以通过配置 <code>shrinkResources</code> 来移除未使用的资源。不过，使用 <code>shrinkResources</code> 必须开启代码混淆。在处理过程中，<code>ProGuard</code> 会移除未被使用的代码，但是不会移除资源。而开启 <code>shrinkResources</code> 后，Gradle就会移除资源了。</p>
<p>下面为开启 <code>shrinkResources</code> 后APK体积的变化:</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1feowxvf26ej30hz084gmb.jpg" alt=""></p>
<p>又缩小了一点点。</p>
<h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h4><p>对于资源文件的优化，其实占大头的还是图片。Android打包本身会对png进行无损压缩，在不那么影响图片显示效果的情况下，对图片进行有损压缩对apk体积的减小还是非常可观的。</p>
<p>我们先使用<a href="https://tinypng.com/" target="_blank" rel="external">TinyPng</a>对项目中四张比较大的图片进行压缩，可以看出，效果还是非常不错的。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1feox9rux7rj31kw0vd4qp.jpg" alt=""></p>
<p>使用TinyPng后，我们还可以将图片转换为 <code>WebP</code> 格式，进一步缩小图片的体积。不过需要注意的是，WebP格式仅适用于Android 4.0+版本，如果你的应用需要兼容Android 2.3，那么需要额外的引入 <code>.so</code> 文件，apk的体积自然也会增加。所以，根据你的需求，权衡利弊吧。</p>
<p>在 <code>Android Studio</code> 中，选定需要转换的图片，然后右键鼠标，即可在菜单底部看到 <code>Convert to WebP</code> 的选项了，然后就可以进行转换的操作。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1feoxrpetfkj31kw0xn7wh.jpg" alt=""></p>
<p>经过上面的处理，我们的App体积来到了9.6M。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1feoxx4abvvj30i00860tf.jpg" alt=""></p>
<h4 id="矢量图"><a href="#矢量图" class="headerlink" title="矢量图"></a>矢量图</h4><p>如果你的项目中使用 <code>appcompat</code> 兼容包，并且版本在23.2以上，那么，使用矢量图或许是个不错的选择。矢量图和分辨率无关，理论上支持任何级别的缩放。以一张常用的 点赞 图标为例，在 Android中使用 <code>Vector</code> 矢量图，大小为：</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1feoyegvw6fj30i3082wf7.jpg" alt=""></p>
<p>而它对应的xxxhdpi的png格式，大小为：</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1feoyaug3xij30i1084aav.jpg" alt=""></p>
<p>效果显而易见，但是这也并不是意味着，我们就可以将所有的图片替换为 矢量图 了 。我们来看一看 <code>ic_favorite_black_24dp.xml</code> 的源代码:</p>
<pre><code class="xml">&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:width=&quot;24dp&quot;
        android:height=&quot;24dp&quot;
        android:viewportWidth=&quot;24.0&quot;
        android:viewportHeight=&quot;24.0&quot;&gt;
    &lt;path
        android:fillColor=&quot;#FF000000&quot;
        android:pathData=&quot;M12,21.35l-1.45,-1.32C5.4,15.36 2,12.28 2,8.5 2,5.42 4.42,3 7.5,3c1.74,0 3.41,0.81 4.5,2.09C13.09,3.81 14.76,3 16.5,3 19.58,3 22,5.42 22,8.5c0,3.78 -3.4,6.86 -8.55,11.54L12,21.35z&quot;/&gt;
&lt;/vector&gt;
</code></pre>
<p>正如你所见，vector的颜色是单一的颜色，所以，vector 适用于图标等颜色单一的图片，如果是颜色比较复杂，那么vector很明显就不合适了。</p>
<h4 id="使用JPG"><a href="#使用JPG" class="headerlink" title="使用JPG"></a>使用JPG</h4><p>对于非透明的大图，JPG格式将会比PNG格式的大小有显著的优势，虽然不是绝对的，但是通常会减小到一半都不止。在启动页，活动页等之类的大图展示区采用JPG将是非常明智的选择。</p>
<p>对于图片的使用，Google的建议，简单来说就是：VD-&gt;WebP-&gt;Png-&gt;JPG</p>
<ul>
<li>如果是纯色的icon，那么用svg</li>
<li>如果是两种以上颜色的icon，用webp</li>
<li>如果webp无法达到效果，选择png</li>
<li>如果图片没有alpha通道，可以考虑jpg</li>
</ul>
<h4 id="复用图片"><a href="#复用图片" class="headerlink" title="复用图片"></a>复用图片</h4><p>项目中我们还可能遇到图片内容相同，仅仅是颜色不同的情况。这个时候我们就可以使用Android提供的着色来完成，而不用提供好几套图片。例如在Android 5.0+上我们可以使用 <code>android:tint</code> 和 <code>android:tintMode</code>，在低版本中可以使用 <code>ColorFilter</code>。</p>
<p>对于那些内容颜色等都相同，只是方向不同的图片，我们可以只保留一中方向的，其他方向的图片通过代码实现。例如我们可以对上面提到的 <code>ic_favorite_black_24dp</code> 进行翻转。创建一个 <code>drawable</code>：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:drawable=&quot;@drawable/ic_favorite_black_24dp&quot;
    android:fromDegrees=&quot;180&quot;
    android:pivotX=&quot;50%&quot;
    android:pivotY=&quot;50%&quot;
    android:toDegrees=&quot;180&quot; /&gt;
</code></pre>
<p>虽然Android设备的分辨率非常的多，但这并不代表着我们需要为每一种分辨率都准备一套资源。在显示差异不大的情况下，我们可以尽量复用一套图片资源，一套布局，然后再考虑特定屏幕密度。</p>
<h4 id="语言资源"><a href="#语言资源" class="headerlink" title="语言资源"></a>语言资源</h4><p>说完了图片，我们还要来说说语言资源。对于大多数的应用，并不需要支持几十种的国际化。使用Gradle，对语言资源进行配置，也可以达到应用瘦身的目的。例如，我们的应用如果只需要支持中文和英语:</p>
<pre><code class="groovy">android {
    defaultConfig {
        ...
        resConfigs &quot;en&quot;, &quot;zh&quot;
        // 支持分辨率
        resConfigs &quot;nodpi&quot;, &quot;hdpi&quot;, &quot;xhdpi&quot;, &quot;xxhdpi&quot;, &quot;xxxhdpi&quot;
    }
}
</code></pre>
<h3 id="Native-Code"><a href="#Native-Code" class="headerlink" title="Native Code"></a>Native Code</h3><p>如果你的App使用到了Native code,在不影响功能的前提下，可以考虑去除部分平台对应的代码，例如移除对 <code>armeabi、mips</code>的支持，</p>
<pre><code class="groovy">android {
    ...
    splits {
        abi {
            enable true
            reset()
            include &#39;armeabi-v7a&#39;, &#39;arm64-v8a&#39;, &#39;x86&#39;, &#39;x86_64&#39;
            universalApk true
        }
    }

 }
</code></pre>
<p>当然，如果是特别大的原生库，我们还可以通过网络，从云端获取，而不直接打包在APK中。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>别忘了最简单，也最容易忽视的，去除重复的依赖，或者是引用更加轻量级的库，也可以达到apk瘦身的效果。</li>
<li>在Release版本中，去除那些只会在debug时才会出现的代码。</li>
<li>对于那些使用频率很小的文件或者是图片，可以存放到云端后，通过网络加载。</li>
</ul>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>相对小的体积能够在用户安装前就给用户留下不错的印象，但是，这不并代表着我们可以为了追求APK体积的小巧而过度的牺牲用户体验。权衡利弊后，选择合适的，才是最重要的。</p>
<p>项目完整地址: <a href="https://github.com/TonnyL/Espresso" target="_blank" rel="external">Espresso</a> - Espresso is an express delivery tracking app designed with Material Design style, built on MVP(Model-View-Presenter) architecture with RxJava2, Retrofit2, Realm database and ZXing.</p>
<p>如果你觉得文章不错的话，请点个赞吧。有其他问题，可以通过以下方式联系我:</p>
<p>Zhihu: <a href="https://www.zhihu.com/people/kirin-momo/" target="_blank" rel="external">https://www.zhihu.com/people/kirin-momo/</a></p>
<p>Slack: <a href="https://androiddevsslack.slack.com" target="_blank" rel="external">https://androiddevsslack.slack.com</a></p>
<p>Weibo: <a href="http://weibo.com/u/5313690193" target="_blank" rel="external">http://weibo.com/u/5313690193</a></p>
<p>Medium: <a href="https://medium.com/@TonnyL" target="_blank" rel="external">https://medium.com/@TonnyL</a></p>
<p>Twitter: <a href="https://twitter.com/TonnyLZTL" target="_blank" rel="external">https://twitter.com/TonnyLZTL</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用ViewPager实现Material Design风格炫酷引导页]]></title>
      <url>http://tonnyl.github.io/2017/04/16/Onboarding-Screens-in-Material-Design/</url>
      <content type="html"><![CDATA[<p>当我们第一次打开一个App，首先映入眼帘的就是引导页了。<br><a id="more"></a><br>引导页向我们展示了一些可以滑动的页面，并在页面中以图片方式展示了这个App的一些亮点。要实现这个效果，网上更多的是通过引入第三方库的形式，但是，这哪里有我们自己动手撸一个来的痛快呢？所以，今天我将手 <del>摸</del> 把手的带大家实现一个符合Material Design标准的炫酷引导页。</p>
<h3 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h3><p>我们首先来看看Google Docs是实现的效果:</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1fenmtjv4a3g307i0dce21.gif" alt="Google Docs"></p>
<p>下面是我们将要实现的效果:</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1fenmmjbz96g307i0dcn3q.gif" alt="Espresso"></p>
<h3 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h3><p>在Material Design官方文档中，关于引导页的部分是这样说明的：</p>
<blockquote>
<p>Onboarding is a virtual unboxing experience that helps users get started with an app’s UI. It should be brief and enhance the use of the app.</p>
</blockquote>
<p>简单来说，引导应该是一个简短的过程，能够帮助用户理解App的使用。</p>
<p>那么，我们应该什么时候使用引导呢？按照规范，当我们的应用添加了新的特色功能或者有重大改变时，应该使用引导页面。对于那些用户本来就期待的，很普通的功能，就不要滥用引导页了。</p>
<p>更多关于设计规范的内容，请访问: <a href="https://material.io/guidelines/growth-communications/onboarding.html" target="_blank" rel="external">https://material.io/guidelines/growth-communications/onboarding.html</a>.</p>
<h3 id="开始吧"><a href="#开始吧" class="headerlink" title="开始吧"></a>开始吧</h3><p>本次的教程主要分为以下三步：</p>
<ol>
<li>使用ViewPager创建引导页</li>
<li>当页面滑动时，控制背景色的渐变</li>
<li>当应用第一次加载时，显示引导页</li>
</ol>
<p>现在就开始吧。</p>
<p>首先当然是要添加依赖了。在<code>build.gradle</code>文件中，添加支持库的依赖。</p>
<pre><code class="groovy">dependencies {
    compile &#39;com.android.support:appcompat-v7:25.3.1&#39;
    compile &#39;com.android.support:design:25.3.1&#39;
    // Other dependencies here.
}
</code></pre>
<p>然后我们就可以利用<code>Android Studio</code>自带的模板，创建一个<code>Tabbed Activity</code>: 在我们的Java包点击鼠标右键 -&gt; <code>New</code> -&gt; <code>Activity</code> -&gt; <code>Tabbed Activity</code>，然后选择<code>Navigation Style</code>为<strong> <code>Swipe Views (ViewPager)</code> </strong> .</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1fennpshdpqj31b2104alw.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1fennu6b80mj31eo170479.jpg" alt=""></p>
<h4 id="Tabbed-Activity-Template"><a href="#Tabbed-Activity-Template" class="headerlink" title="Tabbed Activity Template"></a>Tabbed Activity Template</h4><p>首先，我们来看看我们现有有了些什么：</p>
<ol>
<li>Activity(在我的工程中为<code>OnboardingActivity</code>);</li>
<li><code>SectionsPagerAdapter</code>, ViewPager的适配器;</li>
<li><code>PlaceholderFragment</code>, 用于相应每一个滑动页面的布局。</li>
</ol>
<p>现在我们就可以根据需要对代码进行改造了。打开<code>OnboardingActivity</code>对应的布局文件<code>activity_onboarding.xml</code>，完成下面的工作：</p>
<ol>
<li>移除<code>Toolbar</code>;</li>
<li>添加底部导航按钮部分(用于控制ViewPager)。</li>
</ol>
<p>下面就是底部导航按钮：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1fens8al6o0j30u008iaaa.jpg" alt=""></p>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>底部导航按钮的类型包括：</p>
<ol>
<li>圆形的页面位置指示器;</li>
<li>上一页/下一页按钮;</li>
<li>完成按钮(理应包括跳过按钮，后面我会讲解为什么我没有做跳过按钮)。</li>
</ol>
<p>下面是<code>activity_onboarding.xml</code>文件的源码：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:id=&quot;@+id/main_content&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;@color/colorPrimary&quot;
    tools:context=&quot;.ui.onboarding.OnboardingActivity&quot;&gt;

    &lt;android.support.v4.view.ViewPager
        android:id=&quot;@+id/container&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:paddingBottom=&quot;?attr/actionBarSize&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&gt;

    &lt;!--分割线--&gt;
    &lt;View
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;1dp&quot;
        android:layout_gravity=&quot;bottom&quot;
        android:layout_marginBottom=&quot;?attr/actionBarSize&quot;
        android:alpha=&quot;0.12&quot;
        android:background=&quot;@android:color/white&quot; /&gt;

    &lt;FrameLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;?attr/actionBarSize&quot;
        android:layout_gravity=&quot;bottom&quot;
        android:paddingEnd=&quot;@dimen/activity_horizontal_margin&quot;
        android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
        android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
        android:paddingStart=&quot;@dimen/activity_horizontal_margin&quot;&gt;


        &lt;ImageButton
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:id=&quot;@+id/imageButtonPre&quot;
            style=&quot;@style/Widget.AppCompat.Button.Borderless&quot;
            android:contentDescription=&quot;@string/onboarding_pre_button_description&quot;
            android:layout_gravity=&quot;start|center&quot;
            android:padding=&quot;@dimen/activity_horizontal_margin&quot;
            android:src=&quot;@drawable/ic_chevron_left_white_24dp&quot;
            android:visibility=&quot;gone&quot;
            android:tint=&quot;@android:color/white&quot; /&gt;

        &lt;!--圆形指示器--&gt;
        &lt;LinearLayout
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_gravity=&quot;center&quot;
            android:orientation=&quot;horizontal&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/imageViewIndicator0&quot;
                android:layout_width=&quot;8dp&quot;
                android:layout_height=&quot;8dp&quot;
                android:background=&quot;@drawable/onboarding_indicator_selected&quot; /&gt;

            &lt;ImageView
                android:id=&quot;@+id/imageViewIndicator1&quot;
                android:layout_width=&quot;8dp&quot;
                android:layout_height=&quot;8dp&quot;
                android:layout_marginEnd=&quot;@dimen/activity_margin_half&quot;
                android:layout_marginRight=&quot;@dimen/activity_margin_half&quot;
                android:layout_marginLeft=&quot;@dimen/activity_margin_half&quot;
                android:layout_marginStart=&quot;@dimen/activity_margin_half&quot;
                android:background=&quot;@drawable/onboarding_indicator_unselected&quot; /&gt;

            &lt;ImageView
                android:id=&quot;@+id/imageViewIndicator2&quot;
                style=&quot;@style/Widget.AppCompat.Button.Borderless&quot;
                android:layout_width=&quot;8dp&quot;
                android:layout_height=&quot;8dp&quot;
                android:background=&quot;@drawable/onboarding_indicator_unselected&quot; /&gt;

        &lt;/LinearLayout&gt;

        &lt;android.support.v7.widget.AppCompatButton
            android:id=&quot;@+id/buttonFinish&quot;
            style=&quot;@style/Widget.AppCompat.Button.Borderless&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_gravity=&quot;end|center&quot;
            android:text=&quot;@string/onboarding_finish_button_description&quot;
            android:contentDescription=&quot;@string/onboarding_finish_button_description&quot;
            android:textColor=&quot;@android:color/white&quot;
            android:visibility=&quot;gone&quot; /&gt;

        &lt;ImageButton
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            style=&quot;@style/Widget.AppCompat.Button.Borderless&quot;
            android:id=&quot;@+id/imageButtonNext&quot;
            android:contentDescription=&quot;@string/onboarding_next_button_description&quot;
            android:layout_gravity=&quot;end|center&quot;
            android:padding=&quot;@dimen/activity_horizontal_margin&quot;
            android:src=&quot;@drawable/ic_chevron_right_white_24dp&quot;
            android:tint=&quot;@android:color/white&quot; /&gt;

    &lt;/FrameLayout&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>
<h4 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h4><p>下面是我的<code>fragment_onboarding.xml</code>的全部代码:</p>
<pre><code class="xml">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.ui.onboarding.OnboardingFragment&quot;&gt;

    &lt;FrameLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:background=&quot;@color/colorPrimary&quot;&gt;

        &lt;ImageView
            android:id=&quot;@+id/section_img&quot;
            android:layout_width=&quot;192dp&quot;
            android:layout_height=&quot;192dp&quot;
            android:layout_gravity=&quot;center&quot;
            android:adjustViewBounds=&quot;true&quot;
            android:src=&quot;@drawable/ic_notifications_black_24dp&quot;
            android:alpha=&quot;0.30&quot;
            android:scaleType=&quot;fitCenter&quot; /&gt;

    &lt;/FrameLayout&gt;

    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_gravity=&quot;bottom&quot;
        android:gravity=&quot;center&quot;
        android:orientation=&quot;vertical&quot;
        android:padding=&quot;@dimen/activity_horizontal_margin&quot;&gt;

        &lt;android.support.v7.widget.AppCompatTextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:id=&quot;@+id/section_label&quot;
            android:textAlignment=&quot;center&quot;
            style=&quot;@style/TextAppearance.AppCompat.Headline&quot;
            android:textColor=&quot;@android:color/white&quot;
            tools:text=&quot;Page One&quot; /&gt;

        &lt;android.support.v7.widget.AppCompatTextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:id=&quot;@+id/section_intro&quot;
            style=&quot;@style/TextAppearance.AppCompat.Body1&quot;
            android:layout_marginTop=&quot;@dimen/activity_horizontal_margin&quot;
            android:alpha=&quot;0.7&quot;
            android:gravity=&quot;center&quot;
            android:text=&quot;Your awesome description about the app&quot;
            android:textColor=&quot;@android:color/white&quot; /&gt;

    &lt;/LinearLayout&gt;

&lt;/FrameLayout&gt;
</code></pre>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1fenspnj84uj30dy0nct9j.jpg" alt=""></p>
<p>调整完布局文件之后，我们还可以对Java代码进行一定的调整，便于阅读，当然，这是可选的。我们可以把<code>PlaceholderFragment</code>和<code>SectionsPagerAdapter</code>单独抽取出来，然后统一命名，这样更加便于理解和管理，在后期的维护中也更加容易。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1fent0qe7jbj30gi05amxq.jpg" alt=""></p>
<h4 id="控制ViewPager的颜色"><a href="#控制ViewPager的颜色" class="headerlink" title="控制ViewPager的颜色"></a>控制ViewPager的颜色</h4><p>由于<code>ViewPager</code>已经和<code>SectionsPagerAdapter</code>(<code>OnboardingPagerAdapter</code>)绑定了，所以不用我们就不用担心这个问题了。</p>
<p>当我们滑动页面时，颜色应该自动的更新。也就是说，Pager的颜色应该根据滑动的距离自行调整。</p>
<p>我们有三个页面，每个页面搭配不同的颜色。</p>
<pre><code class="java">private int bgColors[];

bgColors = new int[]{ContextCompat.getColor(this, R.color.colorPrimary),
                ContextCompat.getColor(this, R.color.cyan_500),
                ContextCompat.getColor(this, R.color.light_blue_500)};
</code></pre>
<p>然后可以通过为<code>ViewPager</code>添加<code>OnPageChangeListener</code>做出相应的改变。</p>
<pre><code class="java">viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {

                @Override
                public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
                    int colorUpdate = (Integer) new ArgbEvaluator().evaluate(positionOffset, bgColors[position], bgColors[position == 2 ? position : position + 1]);
                    viewPager.setBackgroundColor(colorUpdate);
                }

                @Override
                public void onPageSelected(int position) {
                    currentPosition = position;
                    updateIndicators(position);
                    viewPager.setBackgroundColor(bgColors[position]);
                    buttonPre.setVisibility(position == 0 ? View.GONE : View.VISIBLE);
                    buttonNext.setVisibility(position == 2 ? View.GONE : View.VISIBLE);
                    buttonFinish.setVisibility(position == 2 ? View.VISIBLE : View.GONE);
                }

                @Override
                public void onPageScrollStateChanged(int state) {

                }
            });
</code></pre>
<p>我们创建了一个<code>ArgbEvaluator</code>用于更新颜色，在前一个页面和后一个页面的颜色之间进行过渡。</p>
<p>想必你也猜到了，<code>updateIndicators()</code>方法通过切换两个不同的<code>drawable</code>来更新指示器。</p>
<pre><code class="java">private void updateIndicators(int position) {
        for (int i = 0; i &lt; indicators.length; i++) {
            indicators[i].setBackgroundResource(
                    i == position ? R.drawable.onboarding_indicator_selected : R.drawable.onboarding_indicator_unselected
            );
        }
    }
</code></pre>
<p>注意：</p>
<p><code>bgColors[position == 2 ? position : position + 1]</code>提示当前是否为最后一个位置，如果是，则不再增加，否则会出现<code>ArrayIndexOutOfBoundsException</code>数组越界异常。数组的范围为「0」 - 「n-1」。</p>
<p><code>currentPosition</code>变量用于追踪ViewPager的当前位置，我们需要在Pre和Next按钮中对<code>currentPosition</code>进行减或者加的操作。</p>
<p>最后，当页面处于最后一页时，需要将FINISH按钮的状态设置为可见。</p>
<h4 id="指示器Drawable"><a href="#指示器Drawable" class="headerlink" title="指示器Drawable"></a>指示器Drawable</h4><p>onboarding_indicator_selected.xml:</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:shape=&quot;oval&quot;&gt;
    &lt;corners android:radius=&quot;100dp&quot; /&gt;
    &lt;solid android:color=&quot;@color/indicator_selected&quot; /&gt;
&lt;/shape&gt;
</code></pre>
<p>onboarding_indicator_unselected.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:shape=&quot;oval&quot;&gt;
    &lt;corners android:radius=&quot;100dp&quot; /&gt;
    &lt;solid android:color=&quot;@color/indicator_unselected&quot; /&gt;
&lt;/shape&gt;
</code></pre>
<h3 id="调用与触发首次加载"><a href="#调用与触发首次加载" class="headerlink" title="调用与触发首次加载"></a>调用与触发首次加载</h3><p>App第一次启动是展示引导页的最佳时机，这样就可以提示用户此App有哪些值得注意的特色功能；但是，从第二次启动开始，App就不应该展示引导页了。我们可以通过在<code>SharedPreference</code>中存放一个<code>boolean</code>值来判断App是否是第一次加载。</p>
<p>当用户按下FINISH按钮后，结束引导，将<code>SettingsUtil.KEY_FIRST_LAUNCH</code>对应的值修改为<code>false</code>。</p>
<pre><code class="java">buttonFinish.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    SharedPreferences.Editor ed = sp.edit();
                    ed.putBoolean(SettingsUtil.KEY_FIRST_LAUNCH, false);
                    ed.apply();
                    navigateToMainActivity();
                }
            });
</code></pre>
<p>如果不是第一次加载，则直接进入<code>MainActivity</code>。</p>
<pre><code class="java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    final SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(this);
    if (sp.getBoolean(SettingsUtil.KEY_FIRST_LAUNCH, true)) {

        setContentView(R.layout.activity_onboarding);

        // Do other things here.
    } else {

        navigateToMainActivity();

        finish();
    }

private void navigateToMainActivity() {
        Intent i = new Intent(this, MainActivity.class);
        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivity(i);
    }
</code></pre>
<p>现在我们把项目跑起来，不出意外的话，你就会看到<a href="#效果预览">效果预览</a>里的效果啦。</p>
<h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><p>如果你还需要对页面的切换动画进行定制，请访问：<a href="https://developer.android.com/training/animation/screen-slide.html#pagetransformer。Medium上`Michell" target="_blank" rel="external">https://developer.android.com/training/animation/screen-slide.html#pagetransformer。Medium上`Michell</a> Bak`的这篇文章或许也能帮到你:<a href="https://android.jlelse.eu/creating-an-intro-screen-for-your-app-using-viewpager-pagetransformer-9950517ea04f" target="_blank" rel="external">Creating an intro screen for your app using ViewPager and PageTransformer</a>.</p>
<h3 id="其他优秀开源库"><a href="#其他优秀开源库" class="headerlink" title="其他优秀开源库"></a>其他优秀开源库</h3><p>如果你需要更加简单的实现方式，你还可以选择：</p>
<ul>
<li><a href="https://github.com/apl-devs/AppIntro" target="_blank" rel="external">AppIntro</a> - Make a cool intro for your Android app.</li>
<li><a href="https://github.com/TangoAgency/material-intro-screen" target="_blank" rel="external">material-intro-screen</a> - Inspired by Heinrich Reimer Material Intro and developed with love from scratch.</li>
<li><a href="https://github.com/riggaroo/MaterialIntroTutorial" target="_blank" rel="external">MaterialIntroTutorial</a> - Library demonstrating a material intro tutorial much like the ones on Google Sheets.</li>
</ul>
<h3 id="One-More-Thing…"><a href="#One-More-Thing…" class="headerlink" title="One More Thing…"></a>One More Thing…</h3><p>还记得我之前立的flag吗？为什么我没有做<code>SKIP</code>跳过按钮？因为在我的引导页中，并不仅仅只是向用户展示了App的特色功能，实际上，在展示页面的同时还完成了一部分数据的初始化工作，向数据库中插入了几百条数据，而这很明显是耗时操作，放在主线程肯定是不合适的，所以我选择了使用<code>AsyncTask</code>，当任务完成后再将Button的状态设置为enable。</p>
<pre><code class="java">private class InitCompaniesDataTask extends AsyncTask&lt;Void, Void, Void&gt; {

    @Override
    protected Void doInBackground(Void... params) {
        CompaniesRepository.getInstance(CompaniesLocalDataSource.getInstance())
                .initData();
        return null;
    }

    @Override
    protected void onPostExecute(Void aVoid) {
        super.onPostExecute(aVoid);
        handler.sendEmptyMessage(MSG_DATA_INSERT_FINISH);
    }

    @Override
    protected void onProgressUpdate(Void... values) {

    }
}

private Handler handler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case MSG_DATA_INSERT_FINISH:
                buttonFinish.setText(R.string.onboarding_finish_button_description);
                buttonFinish.setEnabled(true);
                break;
        }
    }
};
</code></pre>
<p>(事实上，我所使用的<code>Realm</code>数据库在数据插入的速度方面还是很乐观的，但是为了保险起见(避免引起ANR)，我仍然还是选择了<code>AsyncTask</code>，如果你有更好的解决方式，请不吝赐教。)</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>项目完整地址: <a href="https://github.com/TonnyL/Espresso" target="_blank" rel="external">Espresso</a> - Espresso is an express delivery tracking app designed with Material Design style, built on MVP(Model-View-Presenter) architecture with RxJava2, Retrofit2, Realm database and ZXing.</p>
<p>参考:<a href="http://blog.iamsuleiman.com/onboarding-android-viewpager-google-way/" target="_blank" rel="external">Onboarding with Android ViewPager: The Google Way</a></p>
<p>如果你觉得文章不错的话，请点个赞吧。有其他问题，可以通过以下方式联系我:</p>
<p>Zhihu: <a href="https://www.zhihu.com/people/kirin-momo/" target="_blank" rel="external">https://www.zhihu.com/people/kirin-momo/</a></p>
<p>Slack: <a href="https://androiddevsslack.slack.com" target="_blank" rel="external">https://androiddevsslack.slack.com</a></p>
<p>Weibo: <a href="http://weibo.com/u/5313690193" target="_blank" rel="external">http://weibo.com/u/5313690193</a></p>
<p>Medium: <a href="https://medium.com/@TonnyL" target="_blank" rel="external">https://medium.com/@TonnyL</a></p>
<p>Twitter: <a href="https://twitter.com/TonnyLZTL" target="_blank" rel="external">https://twitter.com/TonnyLZTL</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android实现条形码与二维码扫描]]></title>
      <url>http://tonnyl.github.io/2017/04/11/Make-android-app-barcode-and-QR-code-aware/</url>
      <content type="html"><![CDATA[<p>利用Zxing实现条形码和二维码扫描 In this tutorial, we will carry out the barcode and QR code scanning within our app using ZXing library.<br><a id="more"></a></p>
<h1 id="Android实现条形码与二维码扫描"><a href="#Android实现条形码与二维码扫描" class="headerlink" title="Android实现条形码与二维码扫描"></a>Android实现条形码与二维码扫描</h1><p><img src="http://upload-images.jianshu.io/upload_images/2440049-311f7e2a0b14d0cf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在本次教程中，我们将使用ZXing库让我们的app实现条形码和二维码的扫描。</p>
<h2 id="为什么选择ZXing"><a href="#为什么选择ZXing" class="headerlink" title="为什么选择ZXing"></a>为什么选择ZXing</h2><p>要实现条形码和二维码扫描功能，常用的有下面几种方法：</p>
<ul>
<li>使用Google Play Service和<a href="https://developers.google.com/vision/" target="_blank" rel="external">Mobile Vision APIs</a>。</li>
<li>使用<a href="https://github.com/dm77/barcodescanner" target="_blank" rel="external">barcodescanner</a>库。</li>
<li>使用<a href="https://github.com/zxing/zxing" target="_blank" rel="external">ZXing</a>库。</li>
</ul>
<p>我们来仔细分析以上三种方法各自的优缺点。</p>
<ul>
<li>第一种，使用Google Play Service和Mobile Vision APIs。不合适，因为不是所有的用户设备都有安装Google Play Service，特别是在中国。</li>
<li>第二种，使用barcodescanner。也不合适，尽管barcodescanner的导入非常简单，识别也很快，但是UI的调整比较困难。特别是当UI非常复杂时，你就需要拉取整个项目的源码然后自己进行定制。</li>
<li>现在就只剩下ZXing了。ZXing库由谷歌出品，所以在短期内应该不会停止维护。很多应用，报错barcodescanner，都是基于ZXingk开发的。使用ZXing我们不用担心用户没有安装Google Play Service，而聚焦于开发和处理结果本身。</li>
</ul>
<h2 id="ZXing是什么"><a href="#ZXing是什么" class="headerlink" title="ZXing是什么"></a>ZXing是什么</h2><blockquote>
<p>Zxing是Google提供的关于条码（一维码、二维码）的解析工具，提供了二维码的生成与解析的方法。</p>
</blockquote>
<h2 id="设置项目"><a href="#设置项目" class="headerlink" title="设置项目"></a>设置项目</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在你的<code>build.gradle</code>文件(<strong>application级别</strong>)中，添加<code>ZXing core</code>的库。</p>
<pre><code class="groovy">dependencies {
    compile fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)
    // 其他的库在这里...
    compile &#39;com.google.zxing:core:3.3.0&#39;
    testCompile &#39;junit:junit:4.12&#39;
}
</code></pre>
<h3 id="添加必要的权限"><a href="#添加必要的权限" class="headerlink" title="添加必要的权限"></a>添加必要的权限</h3><p>在你的<code>AndroidManifest.xml</code>文件中，添加下面的代码：</p>
<pre><code class="xml">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;io.github.marktony.espresso&quot;&gt;

    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;

     &lt;application ...
</code></pre>
<h3 id="导入必要的类和资源文件"><a href="#导入必要的类和资源文件" class="headerlink" title="导入必要的类和资源文件"></a>导入必要的类和资源文件</h3><p>将<a href="https://github.com/TonnyL/Espresso/tree/master/mobile/src/main/java/io/github/marktony/espresso/zxing" target="_blank" rel="external">整个包</a>复制到你的项目中。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2440049-268d1ac434d52d2d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>注意</strong>:上面的包中的代码我做了简化，如果你需要ZXing示例项目此部分的完整的代码，请访问<a href="https://github.com/zxing/zxing/tree/master/android" target="_blank" rel="external">这里</a>，并下载相应的代码。</p>
<p>代码文件导入完成后，我们还需要导入下面的资源文件：</p>
<ul>
<li><a href="https://github.com/TonnyL/Espresso/blob/master/mobile/src/main/res/layout/activity_scan.xml" target="_blank" rel="external"><code>res/layout/activity_scan</code></a> -  <a href="https://github.com/TonnyL/Espresso/blob/master/mobile/src/main/java/io/github/marktony/espresso/zxing/CaptureActivity.java" target="_blank" rel="external">CaptureActivity</a>的布局文件.</li>
<li><a href="https://github.com/TonnyL/Espresso/blob/master/mobile/src/main/res/values/zxing_ids.xml" target="_blank" rel="external"><code>res/values/zxing_ids.xml</code></a> - zxing id的集合.</li>
<li><a href="https://github.com/TonnyL/Espresso/tree/master/mobile/src/main/res/raw" target="_blank" rel="external"><code>res/raw/beep.ogg</code></a> - 当扫描成功后播放的声音文件.</li>
<li><a href="https://github.com/TonnyL/Espresso/tree/master/mobile/src/main/res/drawable" target="_blank" rel="external"><code>res/drawable/...</code></a> - 共3个文件: <a href="https://github.com/TonnyL/Espresso/blob/master/mobile/src/main/res/drawable/scan_line.png" target="_blank" rel="external">scan_line.png</a>, <a href="https://github.com/TonnyL/Espresso/blob/master/mobile/src/main/res/drawable/qr_code_bg.9.png" target="_blank" rel="external">qr_code_bg.9.png</a>, <a href="https://github.com/TonnyL/Espresso/blob/master/mobile/src/main/res/drawable/shadow.png" target="_blank" rel="external">shadow.png</a>.</li>
</ul>
<h2 id="开动吧"><a href="#开动吧" class="headerlink" title="开动吧"></a>开动吧</h2><p>现在我们从<code>MainActivity</code>启动<code>CaptureActivity</code>并期待获取相应的结果:</p>
<pre><code class="java">public class MainActivity extends AppCompatActivity {

    public final static int SCANNING_REQUEST_CODE = 1;

    private TextView textView;

    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.textView);

        textView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent = new Intent(MainActivity.this, CaptureActivity.class);
                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
                startActivityForResult(intent, SCANNING_REQUEST_CODE);
            }
        });
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case SCANNING_REQUEST_CODE:
                if (resultCode == RESULT_OK) {
                    final Bundle bundle = data.getExtras();
                    Handler handler = new Handler(Looper.getMainLooper());
                    handler.post(new Runnable() {
                        @Override
                        public void run() {
                            textView.setText(bundle.getString(&quot;result&quot;));
                        }
                    });
                }
                break;
            default:
                break;
        }
    }
}
</code></pre>
<p>我们可以在<code>onActivityResult()</code>方法中得到相应的结果。</p>
<p>注意: 如果你的app的target api level是23或者更高, <strong>不要</strong><br>忘记适配运行时权限因为我们的app需要用到相机。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>现在我们可以测试app是否成功运行了。访问 <a href="http://www.qr-code-generator.com/" target="_blank" rel="external">qr-code-generator.com</a>生成你想要的二维码，然后进行愉快的测试吧。我们可以期待获得下面的结果:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2440049-541fcdbb3a4f70b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在这篇教程中，我们使用ZXing库实现了条形码和二维码的扫描。在你自己的app中，你可能需要对扫描的结果进行进一步的处理，例如加载URL或者是从第三方数据源中获取数据等等。</p>
<p>你可以在访问<a href="https://github.com/TonnyL/Espresso" target="_blank" rel="external">Espresso</a>项目主页下载全部源代码。Espresso是一个基于MVP架构，采用RxJava2, Retrofit2, Realm3.0, ZXing开发的快递查询App。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/zxing/zxing" target="_blank" rel="external">ZXing</a> - ZXing(“Zebra Crossing”)项目官方主页。</p>
<h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><p>如果你对这篇文章或者项目有任何问题，可以通过以下方式联系我：</p>
<p>GitHub: <a href="https://github.com/TonnyL" target="_blank" rel="external">https://github.com/TonnyL</a></p>
<p>Zhihu: <a href="https://www.zhihu.com/people/kirin-momo/" target="_blank" rel="external">https://www.zhihu.com/people/kirin-momo/</a></p>
<p>Slack: <a href="https://androiddevsslack.slack.com" target="_blank" rel="external">https://androiddevsslack.slack.com</a></p>
<p>Weibo: <a href="http://weibo.com/u/5313690193" target="_blank" rel="external">http://weibo.com/u/5313690193</a></p>
<p>Medium: <a href="https://medium.com/@TonnyL" target="_blank" rel="external">https://medium.com/@TonnyL</a></p>
<p>Twitter: <a href="https://twitter.com/TonnyLZTL" target="_blank" rel="external">https://twitter.com/TonnyLZTL</a></p>
<h1 id="Make-android-application-barcode-and-QR-code-aware"><a href="#Make-android-application-barcode-and-QR-code-aware" class="headerlink" title="Make android application barcode and QR code aware"></a>Make android application barcode and QR code aware</h1><p>In this tutorial, we will carry out the barcode and QR code scanning within our app using ZXing library.</p>
<h2 id="Why-ZXing"><a href="#Why-ZXing" class="headerlink" title="Why ZXing"></a>Why ZXing</h2><p>Here are the several ways to carry out this function below:</p>
<ul>
<li>Using Google Play Service and the <a href="https://developers.google.com/vision/" target="_blank" rel="external">Mobile Vision APIs</a>.</li>
<li>Using <a href="https://github.com/dm77/barcodescanner" target="_blank" rel="external">barcodescanner</a> library.</li>
<li>Using <a href="https://github.com/zxing/zxing" target="_blank" rel="external">ZXing</a> library.</li>
</ul>
<p>Let’s analyze the positive and negative points of the 3 ways above.</p>
<ul>
<li>The first one, using Google Play Service and the Mobile Vision APIs is not suitable, because not every user has installed the Google Play Service on his devices especially in China.</li>
<li>The second one, using barcodescanner library is not suitable either. Though the integration of it is simple and it is fast, the adjustment of UI is not easy. Particularly when the UI is much complex, you need to pull down the source code and custom it by yourself.</li>
<li>Then only the ZXing left. The ZXing library is produced by Google, so it will not be abandoned in a short time. Many apps including the barcodescanner are based on it. Using ZXing library, we do not need to worry about users without Google Play Service installed, and we can make user scans easier and faster, and focus our development on handling the results.</li>
</ul>
<h2 id="What-is-ZXing"><a href="#What-is-ZXing" class="headerlink" title="What is ZXing"></a>What is ZXing</h2><blockquote>
<p>ZXing (“zebra crossing”) is an open-source, multi-format 1D/2D barcode image processing library implemented in Java, with ports to other languages.</p>
</blockquote>
<h2 id="Set-up-the-project"><a href="#Set-up-the-project" class="headerlink" title="Set up the project"></a>Set up the project</h2><h3 id="Add-the-dependences"><a href="#Add-the-dependences" class="headerlink" title="Add the dependences"></a>Add the dependences</h3><p>In your build.gradle file(<strong>App module level</strong>), add the <code>ZXing core</code> library to it.</p>
<pre><code class="groovy">dependencies {
    compile fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)
    // Other dependencies here...
    compile &#39;com.google.zxing:core:3.3.0&#39;
    testCompile &#39;junit:junit:4.12&#39;
}
</code></pre>
<h3 id="Ask-the-required-permissions"><a href="#Ask-the-required-permissions" class="headerlink" title="Ask the required permissions"></a>Ask the required permissions</h3><p>In your <code>AndroidManifest.xml</code> file, add the code below.</p>
<pre><code class="xml">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;io.github.marktony.espresso&quot;&gt;

    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;

     &lt;application ...
</code></pre>
<h3 id="Import-the-needed-class-and-resource-files"><a href="#Import-the-needed-class-and-resource-files" class="headerlink" title="Import the needed class and resource files"></a>Import the needed class and resource files</h3><p>Copy <a href="https://github.com/TonnyL/Espresso/tree/master/mobile/src/main/java/io/github/marktony/espresso/zxing" target="_blank" rel="external">the whole package</a> to your project.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2440049-ca5581baeb7fe823.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>Notice</strong>: I have simplified the classes and code in the package above, if you need the complete package, visit the <a href="https://github.com/zxing/zxing/tree/master/android" target="_blank" rel="external">ZXing samples</a> here and download the corresponding code.</p>
<p>After import the code, we need to add the resource files below.</p>
<ul>
<li><a href="https://github.com/TonnyL/Espresso/blob/master/mobile/src/main/res/layout/activity_scan.xml" target="_blank" rel="external"><code>res/layout/activity_scan</code></a> - The layout file of <a href="https://github.com/TonnyL/Espresso/blob/master/mobile/src/main/java/io/github/marktony/espresso/zxing/CaptureActivity.java" target="_blank" rel="external">CaptureActivity</a>.</li>
<li><a href="https://github.com/TonnyL/Espresso/blob/master/mobile/src/main/res/values/zxing_ids.xml" target="_blank" rel="external"><code>res/values/zxing_ids.xml</code></a> - The collection of zxing ids.</li>
<li><a href="https://github.com/TonnyL/Espresso/tree/master/mobile/src/main/res/raw" target="_blank" rel="external"><code>res/raw/beep.ogg</code></a> - The sound that app will make when recognize the code successfully.</li>
<li><a href="https://github.com/TonnyL/Espresso/tree/master/mobile/src/main/res/drawable" target="_blank" rel="external"><code>res/drawable/...</code></a> - Three files in total: <a href="https://github.com/TonnyL/Espresso/blob/master/mobile/src/main/res/drawable/scan_line.png" target="_blank" rel="external">scan_line.png</a>, <a href="https://github.com/TonnyL/Espresso/blob/master/mobile/src/main/res/drawable/qr_code_bg.9.png" target="_blank" rel="external">qr_code_bg.9.png</a>, <a href="https://github.com/TonnyL/Espresso/blob/master/mobile/src/main/res/drawable/shadow.png" target="_blank" rel="external">shadow.png</a>.</li>
</ul>
<h2 id="Wrap-it-up"><a href="#Wrap-it-up" class="headerlink" title="Wrap it up"></a>Wrap it up</h2><p>Now we start the <code>CaptureActivity</code> from <code>MainActivity</code> and expect a result by:</p>
<pre><code class="java">public class MainActivity extends AppCompatActivity {

    public final static int SCANNING_REQUEST_CODE = 1;

    private TextView textView;

    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = (TextView) findViewById(R.id.textView);

        textView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent = new Intent(MainActivity.this, CaptureActivity.class);
                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
                startActivityForResult(intent, SCANNING_REQUEST_CODE);
            }
        });
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case SCANNING_REQUEST_CODE:
                if (resultCode == RESULT_OK) {
                    final Bundle bundle = data.getExtras();
                    Handler handler = new Handler(Looper.getMainLooper());
                    handler.post(new Runnable() {
                        @Override
                        public void run() {
                            textView.setText(bundle.getString(&quot;result&quot;));
                        }
                    });
                }
                break;
            default:
                break;
        }
    }
}
</code></pre>
<p>We take care of the result in function <code>onActivityResult()</code>.</p>
<p>Notice: If your target api level is 23 or higher, <strong>DO NOT</strong> forget adapt the runtime permissions because our app need to use the camera.<br>Tip: As you can see in my source code, I did not launch the <code>CaptureActivity</code> in <code>AddPackageFragment</code> instead of <code>MainActivity</code>, so it is a little bit different to the code above.</p>
<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>Now we can test our app if it works well. Go to <a href="http://www.qr-code-generator.com/" target="_blank" rel="external">qr-code-generator.com</a> and test it. We should expect something just this:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2440049-d26c687d70c9eb79.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this tutorial, we have run through the process of facilitating barcode and QR code scanning within Android apps using the ZXing library. In your own apps, you might want to carry out further processing on the retrieved scan results, such as loading URLs or looking the data up in a third party data source.</p>
<p>You can download the complete source code of <a href="https://github.com/TonnyL/Espresso" target="_blank" rel="external">Espresso</a>, it is an express delivery tracking app designed with Material Design style, built on MVP(Model-View-Presenter) architecture with RxJava2, Retrofit2, Realm database and ZXing.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/zxing/zxing" target="_blank" rel="external">ZXing</a> - Official ZXing (“Zebra Crossing”) project home.</p>
<h2 id="Contact"><a href="#Contact" class="headerlink" title="Contact"></a>Contact</h2><p>If you have any problem about this article or the Espresso project, contact me on:</p>
<p>GitHub: <a href="https://github.com/TonnyL" target="_blank" rel="external">https://github.com/TonnyL</a></p>
<p>Zhihu: <a href="https://www.zhihu.com/people/kirin-momo/" target="_blank" rel="external">https://www.zhihu.com/people/kirin-momo/</a></p>
<p>Slack: <a href="https://androiddevsslack.slack.com" target="_blank" rel="external">https://androiddevsslack.slack.com</a></p>
<p>Weibo: <a href="http://weibo.com/u/5313690193" target="_blank" rel="external">http://weibo.com/u/5313690193</a></p>
<p>Medium: <a href="https://medium.com/@TonnyL" target="_blank" rel="external">https://medium.com/@TonnyL</a></p>
<p>Twitter: <a href="https://twitter.com/TonnyLZTL" target="_blank" rel="external">https://twitter.com/TonnyLZTL</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Realm(Java)的那些事]]></title>
      <url>http://tonnyl.github.io/2017/04/03/Realm-Java-%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      <content type="html"><![CDATA[<p>Realm:Create reactive mobile apps in a fraction of time.<br><a id="more"></a></p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gy1fe9omgy5jxj30xc0hfabm.jpg" alt="Realm"></p>
<h2 id="什么是Realm"><a href="#什么是Realm" class="headerlink" title="什么是Realm?"></a>什么是Realm?</h2><p>在Android平台上，有很多基于SQLite的ORM框架，例如<a href="http://greenrobot.org/greendao/" target="_blank" rel="external">GreenDAO</a>,  <a href="http://ormlite.com/" target="_blank" rel="external">OrmLite</a>, <a href="http://satyan.github.io/sugar/" target="_blank" rel="external">SugarORM</a>, <a href="https://github.com/LitePalFramework/LitePal" target="_blank" rel="external">LitePal</a>等等，对于写习惯了SQL语句的小伙伴们来说，看到SQLite这样的数据库肯定是倍感亲切了，有了这些框架更是如虎添翼。但是，在我们日常的开发中，数据量并不会特别的大，表的结构也不会特别复杂，用SQL语句有种大(过)材(于)小(繁)用(琐)的感觉，我们需要做的事情可能仅仅是把用户生成的数据对象快速的缓存起来。这个时候NoSQL就派上了用场，以Mongodb，Redis为代表的NoSQL都引入了一些相对现代化的方式存储数据，比如支持Json，Document的概念，流式api，数据变更通知等等，极大程度的降低了我们学习的成本提高了我们的开发效率。而Realm作为一款移动端的NoSQL框架，官方定位就是替代SQLite等关系型数据库。</p>
<p>Realm是一个由Y Combinator孵化的创业团队开源出来的MVCC(多版本并发控制)的数据库，支持运行在手机，平板和可穿戴设备等嵌入式设备上。</p>
<h2 id="Realm的优点"><a href="#Realm的优点" class="headerlink" title="Realm的优点"></a>Realm的优点</h2><ul>
<li><a href="#简单易用">简单易用</a></li>
<li><a href="#速度快">速度快</a></li>
<li><a href="#跨平台">跨平台</a></li>
<li><a href="#高级功能">高级功能</a></li>
<li><a href="#可视化">可视化</a></li>
<li><a href="#开源">开源</a></li>
</ul>
<h3 id="简单易用"><a href="#简单易用" class="headerlink" title="简单易用"></a>简单易用</h3><p>上面我们已经说过，Realm并不是基于SQLite上的ORM，它有自己的数据库引擎，使用也非常简单。我们先来看看一段简单的代码。</p>
<pre><code class="java">// 通过继承定义我们自己的model类
public class Dog extends RealmObject {
    private String name;
    private int age;

    // ... 生成 getter 和 setter ...
}

public class Person extends RealmObject {
    @PrimaryKey
    private long id;
    private String name;
    private RealmList&lt;Dog&gt; dogs; // 生命一对多的关系

    // ... 生成 getter 和 setter ...
}

// 像普通的Java对象一样使用他们
Dog dog = new Dog();
dog.setName(&quot;Rex&quot;);
dog.setAge(1);

// 初始化Realm
Realm.init(context);

// 在当前线程下获取Realm实例
Realm realm = Realm.getDefaultInstance();

// 查询Realm中所有年龄小于2岁的狗狗
final RealmResults&lt;Dog&gt; puppies = realm.where(Dog.class).lessThan(&quot;age&quot;, 2).findAll();
puppies.size(); // =&gt; 0 因为现在还没有狗狗添加到Realm中

// 在事物中持久化你的数据
realm.beginTransaction();
final Dog managedDog = realm.copyToRealm(dog);
Person person = realm.createObject(Person.class);  
person.getDogs().add(managedDog);
realm.commitTransaction();

// 当数据改变后，Listener会被通知
puppies.addChangeListener(new RealmChangeListener&lt;RealmResults&lt;Dog&gt;&gt;() {
    @Override
    public void onChange(RealmResults&lt;Dog&gt; results) {
        // 查询结果会被实时更新
        puppies.size(); // =&gt; 1
    }
});

// 在后台线程中异步地更新对象
realm.executeTransactionAsync(new Realm.Transaction() {
    @Override
    public void execute(Realm bgRealm) {
        Dog dog = bgRealm.where(Dog.class).equalTo(&quot;age&quot;, 1).findFirst();
        dog.setAge(3);
    }
}, new Realm.Transaction.OnSuccess() {
    @Override
    public void onSuccess() {

      // Realm对象会被自动地更新
        puppies.size(); // =&gt; 0 因为没有小狗狗的年龄小于两岁
        managedDog.getAge();   // =&gt; 3 狗狗的年龄已经被更新了
    }
});
</code></pre>
<h3 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h3><p>我们直接看Realm官方的对比测试数据吧。</p>
<p>每秒能在200K数据记录中进行查询后count的次数: Realm能够达到30.9次，而SQLite只能达到13.6次，Core Data只能达到可怜的一次。<br><img src="https://ww4.sinaimg.cn/large/006tNc79gy1fe9omypcycj30qe0g0gma.jpg" alt="Record of counts"></p>
<p>在200K条数据记录进行一次遍历查询，数据和前面的count相似: Realm能够达到每秒遍历200K数据记录31次，SQLite只能达到14次，而Core Data只有可怜的2次。<br><img src="https://ww3.sinaimg.cn/large/006tNc79gy1fe9onmh6bqj30qe0g0wf5.jpg" alt="Record of queries"></p>
<p>在一次事物中每秒插入数据量的对比，SQLite可以达到178K条记录，性能最好，Realm可以达到94K，而Core Data再次垫底，只有18K。<br><img src="https://ww3.sinaimg.cn/large/006tNc79gy1fe9onv5dvuj30qe0g0754.jpg" alt="Record of inserts"></p>
<p>我自己也进行一次简单的测试，以JSON格式插入641条记录(好吧，我知道数据量比较小，仅仅只是一个参考，具体的数据可以参考<a href="https://github.com/TonnyL/Espresso/blob/master/mobile/src/main/java/io/github/marktony/espresso/data/source/local/CompaniesLocalDataSource.java" target="_blank" rel="external">这里</a>)。</p>
<pre><code>04-03 19:06:13.837 11090-11245/io.github.marktony.espresso D/TAG: 1491217573837

04-03 19:06:14.044 11090-11245/io.github.marktony.espresso D/TAG: 1491217574044
</code></pre><p><img src="https://ww2.sinaimg.cn/large/006tNc79gy1fe9p947u3yj30vw02g0tc.jpg" alt="My Record"><br>207毫秒(Android 7.1.1, Realm 3.0)。</p>
<h3 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h3><p>Realm目前支持Objective-C(iOS), Swift(iOS), Java(Android), JavaScript, Xamarin等平台。</p>
<p>现在很多应用都需要兼顾iOS和Android两个平台，使用Realm可以使用Realm提供的API，在数据持久化层实现两个平台的无差异化移植，无需对内部数据的架构进行改动。</p>
<h3 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h3><p>Realm支持加密，格式化查询，流式API，JSON，数据变更通知等等。</p>
<h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>Realm官方提供了一个名为「<a href="https://itunes.apple.com/us/app/realm-browser/id1007457278?mt=12" target="_blank" rel="external">Realm Browser</a>」轻量级的数据库查看工具(目前还只支持macOS平台)，利用Realm Browser我们可以进行简单的插入，删除等基本操作。<br><img src="https://ww3.sinaimg.cn/large/006tNc79gy1fe9q6fqk7nj31kw0uth2j.jpg" alt="Realm Browser"></p>
<p>第三方开发者也提供了一些移动端的数据库查看工具，例如：</p>
<p><a href="https://github.com/jonasrottmann/realm-browser" target="_blank" rel="external">Realm Browser by Jonas Rottmann (Android)</a></p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gy1fe9rb6igm3j30u00zkq73.jpg" alt="Realm Browser by Jonas Rottmann (Android)"></p>
<p><a href="https://github.com/bearjaw/RBSRealmBrowser" target="_blank" rel="external">ealm Browser by Max Baumbach (iOS)</a></p>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79gy1fe9rfz16e0g30ai0iub2a.gif" alt="Realm Browser by Max Baumbach (iOS)"></p>
<h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><p><a href="https://github.com/realm" target="_blank" rel="external">Realm</a>已经将<a href="https://github.com/realm/realm-core" target="_blank" rel="external">Realm Core</a>, <a href="https://github.com/realm/realm-java" target="_blank" rel="external">Realm Java</a>，<a href="https://github.com/realm/realm-cocoa" target="_blank" rel="external">Realm Cocoa</a>, <a href="https://github.com/realm/realm-js" target="_blank" rel="external">Realm JS</a>, <a href="https://github.com/realm/realm-dotnet" target="_blank" rel="external">Realm Dotnet</a>等等项目开源，这也就意味着，你可以向Realm团队提bug，提建议等等，和Realm团队一起见证Realm的成长。</p>
<p>另外，还有一点一定要说明的是，Realm团队的<a href="https://realm.io/cn/news/" target="_blank" rel="external">博客</a>，干货满满，而且都有中文翻译哦~</p>
<h2 id="Realm的不足"><a href="#Realm的不足" class="headerlink" title="Realm的不足"></a>Realm的不足</h2><p>说完了优点，自然还要说说不足的地方。</p>
<ul>
<li><a href="#体积">体积</a></li>
<li><a href="#数据类型">数据类型</a></li>
<li><a href="#线程限制">线程限制</a></li>
</ul>
<h3 id="体积"><a href="#体积" class="headerlink" title="体积"></a>体积</h3><p>引入Realm之后，在不做任何处理的情况下，APK体积增大了一个非常恐怖的数字 <strong>5.6M</strong>，你没有看错，是5.6兆 <del>(5.6M是什么概念，四舍五入就是10M，在四舍五入就是100M啊)</del>。直接看图吧。</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gy1fe9t6n20c4j30ky0yqn2w.jpg" alt="APK size before implementing Realm"></p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gy1fe9t7ajo6lj30ky0yqn2u.jpg" alt="APK size using default configuration"></p>
<p>我们可以通过配置<code>build.gradle</code>的split，根据不同的设备类型对APK进行拆分，从而达到缩减体积的目的。下面我配置了split之后，APK体积的变化。</p>
<pre><code class="gradle">splits {
        // Split apks on build target ABI, view all options for the splits here:
        // http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits
        abi {
            enable true
            reset()
            include &#39;armeabi&#39;, &#39;armeabi-v7a&#39;, &#39;arm64-v8a&#39;, &#39;mips&#39;, &#39;x86&#39;, &#39;x86_64&#39;
        }
        universalApk true
}
</code></pre>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79gy1fe9t7nzglwj30ky0yq44c.jpg" alt="APK size using split"></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol>
<li>Realm要求当前Bean对象必须直接继承RealmObject，<del>或者间接实现(目前已经不再推荐使用)</del>，侵入性非常强。</li>
<li>Realm不支持内部类。</li>
<li>Realm修改了部分数据类型，例如List –&gt; RealmList。在内部实现上，RealmList与ArrayList等还是有比较大的区别的。</li>
<li><p>使用RealmList<t>时，泛型<code>T</code>类型必须是直接继承了RealmObject的类型，例如，如果是RealmList<string>类型，那么不好意思，这是不支持的😂。官方建议我们自定义一个<code>RealmString</code>继承自RealmObject，例如：</string></t></p>
<pre><code class="java"> public class RealmString extends RealmObject {

     private String string;

     public String getString() {
         return string;
     }

     public void setString(String string) {
         this.string = string;
     }
 }
</code></pre>
</li>
<li><p>Realm是不支持主键自增长的，所以，我们需要自己维护一个<code>PrimaryKey</code>来约束主键。例如：</p>
<pre><code class="java"> @PrimaryKey
 private String number;
</code></pre>
<p>另外，如果没有给RealmObject设置主键，insertOrUpdata的默认操作就是insert，这样 就会导致重复插入数据记录了。</p>
</li>
<li><p>Intent传值时，也会有一些坑。例如，我想要在a1中查询数据，然后将查询结果(RealmList)传递到a2中。不好意思，Realm不想和你说话，并向你丢了一个crash。这是因为，ArrayList实现了<code>Serializable</code>接口，而RealmList并没有。再例如，如果不是RealmList，而是一个普通的继承自RealmObject并实现了<code>Serializable</code>接口的实体类呢？也不行。这是因为，查询出来的数据并不是我们想要的对象，而是Realm利用apt帮我们生成的实体类的子类，或者说实体类的代理类，而在Realm中，起作用的就是这个代理类。</p>
</li>
</ol>
<p>那么，怎么解决呢？官方的建议不要传递整个RealmList或者RealmObject，而是传递对象的标识符，然后在接收方(Activity, Service, BroadcastReceiver等等)解析出这个标识符，然后利用Realm再次查询获得相应的结果。</p>
<h3 id="线程限制"><a href="#线程限制" class="headerlink" title="线程限制"></a>线程限制</h3><p>如果你在UI线程获取到了当前Realm对象，在异步线程中使用当前Realm对象进行操作，就会抛出异常了。RealmObject也是如此。所以，异步很重要。</p>
<p>另外，在调用了<code>Realm.close()</code>方法之后，所获取的对象就不能再访问了，所以，在获取到了RealmObject之后，官方提供了一个<code>copyFromRealm</code>来复制一份实例供我们使用。</p>
<h2 id="在Android中使用Realm"><a href="#在Android中使用Realm" class="headerlink" title="在Android中使用Realm"></a>在Android中使用Realm</h2><p>看到这里的客官，应该对Realm是真爱了。下面我们就来正经讨论一下，如何在Android中使用Realm数据库。</p>
<ul>
<li><a href="#先决条件">先决条件</a></li>
<li><a href="#安装">安装</a></li>
<li><a href="#获取Realm实例">获取Realm实例</a></li>
<li><a href="#创建Realm实体">创建Realm实体</a></li>
<li><a href="#增删改查">增删改查</a></li>
<li><a href="#高级用法">高级用法</a><ul>
<li><a href="#加密">加密</a></li>
<li><a href="#与Android系统结合">与Android系统结合</a></li>
<li><a href="#与其他第三方库结合使用">与其他第三方库结合使用</a></li>
</ul>
</li>
</ul>
<h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><ul>
<li><a href="https://developer.android.com/studio/index.html" target="_blank" rel="external">Android Studio</a> 1.5.1或以上版本</li>
<li>JDK 1.7或以上版本</li>
<li>较新版本的Android SDK</li>
<li>Android API Level 9 或者以上(即Android 2.3及以上)</li>
</ul>
<p>什么，你想要在Eclipse上使用Realm?<br><img src="https://ww2.sinaimg.cn/large/006tNc79gy1feapqxnhi6j30dw09a3yu.jpg" alt="Using Realm in Eclipse"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Realm是作为一个Gradle插件安装的。</p>
<ul>
<li><p>第一步：在project级别的<code>build.gradle</code>文件下添加：</p>
<pre><code class="gradle">  buildscript {
      repositories {
          jcenter()
      }
      dependencies {
          classpath &quot;io.realm:realm-gradle-plugin:3.0.0&quot;
      }
  }
</code></pre>
<p>  下面是project级别的<code>build.gradle</code>文件的位置：<br>  <img src="https://ww4.sinaimg.cn/large/006tNc79gy1feapw9tjepj30pi0lu79w.jpg" alt="build.gradle file of project level"></p>
</li>
<li><p>第二步：在application级别的<code>build.gradle</code>文件的顶部应用<code>realm-android</code>插件：</p>
<pre><code class="gradle">  apply plugin: &#39;realm-android&#39;
</code></pre>
<p>  下面是application级别的<code>build.gradle</code>文件的位置：<br>  <img src="https://ww4.sinaimg.cn/large/006tNc79gy1feaq13ys14j30pa0lsq8j.jpg" alt="build.gradle file of application level"></p>
</li>
</ul>
<p>添加完成后，刷新gradle依赖即可。</p>
<p>下面是两个级别的<code>build.gradle</code>文件示例：</p>
<ul>
<li><a href="https://github.com/realm/realm-java/blob/master/examples/build.gradle" target="_blank" rel="external">Project level build.gradle</a></li>
<li><a href="https://github.com/realm/realm-java/blob/master/examples/introExample/build.gradle" target="_blank" rel="external">Application level build.gradle</a></li>
</ul>
<p>除了gradle外，Realm并不支持像Maven和Ant这样的构建工具。如果你有需要的话，可以关注下面的两个issue。</p>
<ul>
<li><a href="https://github.com/realm/realm-java/issues/2342" target="_blank" rel="external">Maven support</a></li>
<li><a href="https://github.com/realm/realm-java/issues/1591" target="_blank" rel="external">Ant support</a></li>
</ul>
<h3 id="获取Realm实例"><a href="#获取Realm实例" class="headerlink" title="获取Realm实例"></a>获取Realm实例</h3><p>一般需要先在Application中完成Realm的初始化工作。例如：</p>
<pre><code class="java">public class App extends Application {

    @Override
    public void onCreate() {
        super.onCreate();
        Realm.init(this);
    }

}
</code></pre>
<p>然后我们可以通过一个Configuration来指定Realm生成的数据库的名字和版本等等。</p>
<pre><code class="java">Realm realm = Realm.getInstance(new RealmConfiguration.Builder()
                .deleteRealmIfMigrationNeeded()
                .name(&quot;MyAwsomeRealmName.realm&quot;)
                .build());
</code></pre>
<h3 id="创建Realm实体"><a href="#创建Realm实体" class="headerlink" title="创建Realm实体"></a>创建Realm实体</h3><p>Realm的实体类可以通过继承<code>RealmObject</code>的方式创建：</p>
<pre><code class="java">public class User extends RealmObject {

    private String          name;
    private int             age;

    @Ignore
    private int             sessionId;

    // 通过IDE生成的标准getters和setters...
    public String getName() { return name; }
    public void   setName(String name) { this.name = name; }
    public int    getAge() { return age; }
    public void   setAge(int age) { this.age = age; }
    public int    getSessionId() { return sessionId; }
    public void   setSessionId(int sessionId) { this.sessionId = sessionId; }
}
</code></pre>
<p>Realm实体类还是支持<code>public</code>, <code>protected</code>, <code>private</code>字段和方法的。</p>
<pre><code class="java">public class User extends RealmObject {

    public String name;

    public boolean hasLongName() {
      return name.length() &gt; 7;
    }

    @Override
    public boolean equals(Object o) {
      // 自定义equals操作
    }
}
</code></pre>
<h4 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h4><p>Realm支持的字段类型：</p>
<p><code>boolean</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>String</code>, <code>Date</code> and <code>byte[]</code>，其中integer类型<code>byte</code>, <code>short</code>, <code>int</code>，都被自动的包装成了<code>long</code>类型。<code>RealmObject</code>和<code>RealmList&lt;? extends RealmObject&gt;</code>的子类支持实体类之间的关系(一对一，一对多，多对多等)。</p>
<p>装箱类型<code>Boolean</code>, <code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code> 和 <code>Double</code>等也可以在实体类中使用，不过需要注意的是这些字段的值有可能为<code>null</code>。</p>
<h4 id="Required字段和null值"><a href="#Required字段和null值" class="headerlink" title="Required字段和null值"></a>Required字段和null值</h4><p>在有些情况下，字段值为<code>null</code>并不合适。在Realm中，<code>@Required</code>注解就是用来强制检查，不允许字段出现<code>null</code>值。只有<code>Boolean</code>, <code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code> 和 <code>Double</code>等可以使用<code>@Required</code>注解，如果其他类型的字段使用了此注解，编译时将会出现错误。原始字段类型和<code>RealmList</code>类型被隐含的标示为<code>Required</code>，而<code>RealmObject</code>类型字段是可以为nullable的。</p>
<h4 id="属性忽略"><a href="#属性忽略" class="headerlink" title="属性忽略"></a>属性忽略</h4><p>使用注解<code>@Ignore</code>意味着此字段可以不被存储到数据库中。</p>
<h4 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h4><p>对于底层数据而言，<code>RealmObject</code>是实时的，自动更新的，这也就意味着我们获取到的对象数据不需要我们手动的刷新。更改数据对查询的影响会被立刻反应在查询结果上。</p>
<pre><code class="java">realm.executeTransaction(new Realm.Transaction() {
    @Override
    public void execute(Realm realm) {
        Dog myDog = realm.createObject(Dog.class);
        myDog.setName(&quot;Fido&quot;);
        myDog.setAge(1);
    }
});
Dog myDog = realm.where(Dog.class).equalTo(&quot;age&quot;, 1).findFirst();

realm.executeTransaction(new Realm.Transaction() {
    @Override
    public void execute(Realm realm) {
        Dog myPuppy = realm.where(Dog.class).equalTo(&quot;age&quot;, 1).findFirst();
        myPuppy.setAge(2);
    }
});

myDog.getAge(); // =&gt; 2
</code></pre>
<h4 id="属性索引"><a href="#属性索引" class="headerlink" title="属性索引"></a>属性索引</h4><p>使用注解<code>@Index</code>会给字段添加一个搜索索引。这会导致插入速度变慢和数据文件变大，但是查询操作会更快。所以，Realm只推荐你在需要提高读性能的时候添加索引。索引支持的字段类型包括：<code>String</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>boolean</code> 和 <code>Date</code>。</p>
<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><p>数据库的使用，最常用的就是增删改查(CRUD)四种操作了，我们一起来看看Realm是如何实现上述四种操作的。</p>
<h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><p>在讨论具体的CRUD之前，我们要先了解一下写操作。读操作是隐式完成的，也就是说，任何时候你都可以对实体进行访问和查询。而所有的写操作(添加，修改，删除)都必须在写事物中完成。写事物能够被提交和取消。写操作同时也用于保证线程安全。</p>
<pre><code class="java">// 获取Realm实例
Realm realm = Realm.getDefaultInstance();

realm.beginTransaction();

//... 在这里添加或者升级对象 ...
User user = realm.createObject(User.class);

realm.commitTransaction();
// 取消写操作
// realm.cancelTransaction();
</code></pre>
<p>需要注意的是，写操作是互斥的。所以，如果我们同时在UI线程和后台线程中创建写操作就有可能导致ANR。当我们在UI线程创建写事物时，可以使用<a href="https://realm.io/docs/java/latest/#asynchronous-transactions" target="_blank" rel="external">异步事物</a>来避免ANR的出现。</p>
<p>Realm是crash安全的，所以如果在事物中产生了一个异常，Realm本身是不会被破坏的。不过在当前事物中的数据被丢失，不过为了避免异常产生的一系列问题，取消事物就非常重要了。如果使用<code>executeTransaction()</code>这些操作都会被自动完成。</p>
<p>由于Realm采用的MVCC架构，在写事物进行的同时，读操作也是被允许的。这也就意味着，除非需要在许多的线程中，同时处理许多的并行事务，我们可以使用大型事物，完成许多细粒度的事物。当我们向Realm提交一个写事物时，其他的Realm实例都会被通知，并且被<a href="https://realm.io/docs/java/latest/#auto-updating" target="_blank" rel="external">自动更新</a>。</p>
<p>读和写的操作在Realm中就是<a href="http://en.wikipedia.org/wiki/ACID" target="_blank" rel="external">ACID</a>.</p>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p>我们可以使用下面的代码将数据添加到Realm中：</p>
<pre><code class="java">realm.beginTransaction();
User user = realm.createObject(User.class); // 创建一个新的对象
user.setName(&quot;John&quot;);
user.setEmail(&quot;john@corporation.com&quot;);
realm.commitTransaction();
</code></pre>
<pre><code class="java">User user = new User(&quot;John&quot;);
user.setEmail(&quot;john@corporation.com&quot;);

// 将对象复制到Realm中，后面的操作必须在realmUser上进行。
realm.beginTransaction();
User realmUser = realm.copyToRealm(user);
realm.commitTransaction();
</code></pre>
<p>我们也可以使用<code>realm.executeTransaction()</code>方法替代手动的跟踪<code>realm.beginTransaction()</code>, <code>realm.commitTransaction()</code>和<code>realm.cancelTransaction()</code>，这个方法自动地处理了begin/commit，和错误发生后的cancel。</p>
<pre><code class="java">realm.executeTransaction(new Realm.Transaction() {
    @Override
    public void execute(Realm realm) {
        User user = realm.createObject(User.class);
        user.setName(&quot;John&quot;);
        user.setEmail(&quot;john@corporation.com&quot;);
    }
});
</code></pre>
<p>异步事物可以帮助我们处理同步事物可能带来的UI线程阻塞的问题。使用异步事物后，事物会在一个后台线程上运行，事物完成后会进行结果通知。</p>
<pre><code class="java">realm.executeTransactionAsync(new Realm.Transaction() {
            @Override
            public void execute(Realm bgRealm) {
                User user = bgRealm.createObject(User.class);
                user.setName(&quot;John&quot;);
                user.setEmail(&quot;john@corporation.com&quot;);
            }
        }, new Realm.Transaction.OnSuccess() {
            @Override
            public void onSuccess() {
                // 事物成功完成
            }
        }, new Realm.Transaction.OnError() {
            @Override
            public void onError(Throwable error) {
                // 事物失败，自动取消
            }
        });
</code></pre>
<p><code>onSuccess</code> 和 <code>onError</code> 回调都是可选的，但是如果提供了这些方法，它们会在事物成功完成或者失败后被调用。</p>
<p>我们可以通过<code>RealmAsyncTask</code>获取一个异步事物的对象，这个对象可以用在当事物未完成而Activity或者Fragment被销毁时取消事物。如果在回调中进行了更新UI的操作，而又忘记了取消事物，就会造成crash。</p>
<pre><code class="java">public void onStop () {
    if (transaction != null &amp;&amp; !transaction.isCancelled()) {
        transaction.cancel();
    }
}
</code></pre>
<p>Realm还提供了一个和神奇的功能，直接通过JSON(String, JSONObject, InputStream)添加数据，并且Realm会自动忽略没有在RealmObject中定义的字段。单个的对象可以通过<code>Realm.createObjectFromJson()</code>方法添加，对象表可以通过<code>Realm.createAllFromJson()</code>方法添加。</p>
<pre><code class="java">// 代表city的RealmObject
public class City extends RealmObject {
    private String city;
    private int id;
    // getters and setters left out ...
}

// 通过String添加
realm.executeTransaction(new Realm.Transaction() {
    @Override
    public void execute(Realm realm) {
        realm.createObjectFromJson(City.class, &quot;{ city: \&quot;Copenhagen\&quot;, id: 1 }&quot;);
    }
});

// 通过一个InputStream添加多个对象
realm.executeTransaction(new Realm.Transaction() {
    @Override
    public void execute(Realm realm) {
        try {
            InputStream is = new FileInputStream(new File(&quot;path_to_file&quot;));
            realm.createAllFromJson(City.class, is);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
});
</code></pre>
<p>Realm解析JSON时遵循下面的规则：</p>
<ul>
<li>使用包含null值的JSON创建对象<ul>
<li>对于非必须字段，设置为默认值null</li>
<li>对于必须字段，直接抛出异常</li>
</ul>
</li>
<li>使用包含null值的JSON更新对象<ul>
<li>对于非必须字段，设置为null</li>
<li>对于必须字段，直接抛出异常</li>
</ul>
</li>
<li>JSON不包含字段<ul>
<li>保持必须和非必须字段的值不变</li>
</ul>
</li>
</ul>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>首先定义一个<code>User</code>类：</p>
<pre><code class="java">public class User extends RealmObject {

    @PrimaryKey
    private String          name;
    private int             age;

    @Ignore
    private int             sessionId;

    // 使用IDE生成的标准getters和setters
    public String getName() { return name; }
    public void   setName(String name) { this.name = name; }
    public int    getAge() { return age; }
    public void   setAge(int age) { this.age = age; }
    public int    getSessionId() { return sessionId; }
    public void   setSessionId(int sessionId) { this.sessionId = sessionId; }
}
</code></pre>
<p>查询所有name为「John」或者「Peter」的User:</p>
<pre><code class="java">// 创建一个RealmQuery用于查找所有符合条件的user
RealmQuery&lt;User&gt; query = realm.where(User.class);

// 添加查询条件
query.equalTo(&quot;name&quot;, &quot;John&quot;);
query.or().equalTo(&quot;name&quot;, &quot;Peter&quot;);

// 执行查询
RealmResults&lt;User&gt; result1 = query.findAll();

// 或者进行简化
RealmResults&lt;User&gt; result2 = realm.where(User.class)
                                  .equalTo(&quot;name&quot;, &quot;John&quot;)
                                  .or()
                                  .equalTo(&quot;name&quot;, &quot;Peter&quot;)
                                  .findAll();
</code></pre>
<p>上面的代码就可以获取一个<code>RealmResults</code>类的实例，包含了名称为John或者Peter的所有user。当<code>findAll()</code>方法被调用时，查询便开始执行。<code>findAll()</code>是<code>findAll()</code>方法大家族的一员，类似的方法还有：<code>findAllSorted()</code>返回一个排好序之后的结果集合，<code>findAllAsync()</code>会在后台线程中异步的完成查询操作。</p>
<p>需要注意的是，查询得到的结果是没有被复制的。正如Realm的官方文档所言：</p>
<blockquote>
<p>All fetches (including queries) are lazy in Realm, and the data is never copied.</p>
</blockquote>
<p>我们得到了一个符合查询条件的对象列表的引用，但是如果我们直接操作，对象将会是原始的对象。所以，还是复制一份吧。</p>
<pre><code class="java">ArrayList array = realm. copyFromRealm(result2);
</code></pre>
<p><code>RealmResults</code>继承自Java的<code>AbstractList</code>，在许多方面的操作类似。例如，<code>RealmResults</code>是有序的，我们可以通过索引获取特定的对象。</p>
<p>当查询没有符合条件的结果时，返回值<code>RealmResults</code>并不会为null，但是<code>size()</code>方法会返回0。</p>
<p>如果我们想要修改或者删除<code>RealmResults</code>中的对象，也必须在写事物中进行。</p>
<h5 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h5><p>对于所有的数据类型，都有以下两种查询条件：</p>
<ul>
<li><code>equalTo()</code></li>
<li><code>notEqualTo()</code></li>
</ul>
<p>使用<code>in()</code>匹配某一特定字段而不是一个的值的列表。例如，查找名字 「Jill」, 「William」, 「Trillian」，我们可以使用<code>in(&quot;name&quot;, new String[]{&quot;Jill&quot;, &quot;William&quot;, &quot;Trillian&quot;})</code>。<code>in()</code>方法接收String, 二进制数据和数值型字段。</p>
<p>数值数据类型包括<code>Data</code>，都允许进行下面的查询条件:</p>
<ul>
<li><code>between()</code>(包含边界值)</li>
<li><code>greaterThan()</code> - 大于</li>
<li><code>lessThan()</code> - 小于</li>
<li><code>greaterThanOrEqualTo()</code> - 大于等于</li>
<li><code>lessThanOrEqualTo()</code> - 小于等于</li>
</ul>
<p>String类型字段允许使用以下查询条件：</p>
<ul>
<li><code>contains()</code> - 包含</li>
<li><code>beginsWith()</code> - 以…开头</li>
<li><code>endsWith()</code> - 以…结尾</li>
<li><code>like()</code> - 类似于</li>
</ul>
<p>所有的String类型都支持添加第三个参数来控制大小写的敏感类型。</p>
<ul>
<li>Case.INSENSITIVE -&gt; 大小写不敏感</li>
<li>Case.SENSITIVE -&gt; 大小写敏感(默认值)</li>
</ul>
<p>使用<code>like()</code>进行模糊匹配，匹配条件如下:</p>
<ul>
<li><code>*</code> - 匹配0个或者多个Unicode字符</li>
<li><code>?</code> - 匹配单个Unicode字符</li>
</ul>
<p>举个🌰，假设现在有一个RealmObject有一个<code>name</code>字段，其值有「William」, 「Bill」,「Jill」, 和 「Trillian」。 查询条件<code>like(&quot;name&quot;, &quot;?ill*&quot;)</code>会匹配开始的3个对象， 而<code>like(&quot;name&quot;, &quot;*ia?&quot;)</code>会匹配第一个和最后一个对象。</p>
<p>二进制数据，String，<code>RealmObject</code>的列表(<code>RealmList</code>)有可能为空，也就是长度为0，下面是检测是否为空的查询条件：</p>
<ul>
<li><code>isEmpty()</code></li>
<li><code>isNotEmpty()</code></li>
</ul>
<p>如果一个字段是非必须字段，那么它的值就有可能为<code>null</code>，我们可以用以下条件检测：</p>
<ul>
<li><code>isNull()</code></li>
<li><code>isNotNull()</code></li>
</ul>
<h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>每一个查询条件都被隐式地使用<code>AND</code>连接。而逻辑运算符<code>OR</code>必须使用<code>or()</code>显式地声明。</p>
<p>仍然以上面<code>User</code>类为例，我们可以使用<code>beginGroup()</code> 和 <code>endGroup()</code> 来声明一组查询条件。</p>
<pre><code class="java">RealmResults&lt;User&gt; r = realm.where(User.class)
                            .greaterThan(&quot;age&quot;, 10)  // 隐式地AND
                            .beginGroup()
                                .equalTo(&quot;name&quot;, &quot;Peter&quot;)
                                .or()
                                .contains(&quot;name&quot;, &quot;Jo&quot;)
                            .endGroup()
                            .findAll();
</code></pre>
<p>查询条件也可以使用<code>not()</code>进行否定，<code>not()</code>也可以和<code>beginGroup()</code> 和 <code>endGroup()</code> 用于否定一组子查询条件。再举个🌰，我们想要查询所有名字不为「Peter」和「Jo」的User：</p>
<pre><code class="java">RealmResult&lt;User&gt; r = realm.where(User.class)
                           .not()
                           .beginGroup()
                                .equalTo(&quot;name&quot;, &quot;Peter&quot;)
                                .or()
                                .contains(&quot;name&quot;, &quot;Jo&quot;)
                            .endGroup()
                            .findAll();
</code></pre>
<p>当然，我们也可以用<code>in()</code>进行简化：</p>
<pre><code class="java">RealmResult&lt;User&gt; r = realm.where(User.class)
                           .not()
                           .in(&quot;name&quot;, new String[]{&quot;Peter&quot;, &quot;Jo&quot;})
                           finalAll();
</code></pre>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>当我们的查询完成后，可以使用下面的代码对查询结果进行排序:</p>
<pre><code class="java">RealmResults&lt;User&gt; result = realm.where(User.class).findAll();
result = result.sort(&quot;age&quot;); // 升序排序
result = result.sort(&quot;age&quot;, Sort.DESCENDING);
</code></pre>
<p>默认采用的是按升序排序，如果需要改变的话，可以将<code>Sort.DESCENDING</code>作为可选参数传入。</p>
<h5 id="唯一值"><a href="#唯一值" class="headerlink" title="唯一值"></a>唯一值</h5><p>我们可以使用<code>distinct()</code>来查询某一字段共有多少类型的值。例如，我们要查询在我们的数据库中有多少不同的名字：</p>
<pre><code class="java">RealmResults&lt;Person&gt; unique = realm.where(Person.class).distinct(&quot;name&quot;);
</code></pre>
<p>此操作只支持integer和string类型的字段，对其他类型进行此操作会产生异常。我们也可以对多个字段进行排序。</p>
<h5 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h5><p>由于查询结果并不会进行复制和计算操作，我们可以一步一步的过滤我们的数据：</p>
<pre><code class="java">RealmResults&lt;Person&gt; teenagers = realm.where(Person.class).between(&quot;age&quot;, 13, 20).findAll();
Person firstJohn = teenagers.where().equalTo(&quot;name&quot;, &quot;John&quot;).findFirst();
</code></pre>
<p>我们也可以对子对象进行链式查询。假设上面的<code>Person</code>类还有一个<code>Dog</code>类型的list类型字段：</p>
<pre><code class="java">public class Dog extends RealmObject {
    private int age;
    // getters &amp; setters ...
}

public class Person extends RealmObject {
    private int age;
    private RealmList&lt;Dog&gt; dogs;
    // getters &amp; setters ...
}
</code></pre>
<p>我们可以通过链式查询，查找年龄在13至20之间，并且至少有一只年龄为1岁的狗狗的人：</p>
<pre><code class="java">RealmResults&lt;Person&gt; teensWithPups = realm.where(Person.class).between(&quot;age&quot;, 13, 20).equalTo(&quot;dogs.age&quot;, 1).findAll();
</code></pre>
<p>需要注意的是，链式查询的基础并不是<code>RealmQuery</code>，而是<code>RealmResults</code>。如果我们为一个已经存在的<code>RealmQuery</code>添加更多的查询条件，修改的是query本身，而不是链。</p>
<p>OK，到这里，查询的情况我们讨论的也差不多了。由于查询在增删改查四种操作中的使用频率最高，所以篇幅也最长，下面我们来讨论「修改」的情况。</p>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>事实上，我们在上面的内容中已经进行过修改的操作了，<a href="#自动更新">戳这里</a>。我们在查询到符合条件的对象后，开启一个事物，在事物中进行修改，然后提交事物即可:</p>
<pre><code class="java">realm.executeTransaction(new Realm.Transaction() {
    @Override
    public void execute(Realm realm) {
        Dog myPuppy = realm.where(Dog.class).equalTo(&quot;age&quot;, 1).findFirst();
        myPuppy.setAge(2);
    }
});
</code></pre>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除操作和修改操作类似，基本思想都是先查询，然后在事物中进行操作。我们可以通过下面的代码进行删除操作:</p>
<pre><code class="java">// 获取查询结果
final RealmResults&lt;Dog&gt; results = realm.where(Dog.class).findAll();

// 所有对数据的变更必须在事物中进行
realm.executeTransaction(new Realm.Transaction() {
    @Override
    public void execute(Realm realm) {
        // 移除符合条件的单个查询结果
        results.deleteFirstFromRealm();
        results.deleteLastFromRealm();

        // 移除单个对象
        Dog dog = results.get(5);
        dog.deleteFromRealm();

        // 移除所有符合条件的查询结果
        results.deleteAllFromRealm();
    }
});
</code></pre>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>Realm文件可以通过向<code>RealmConfiguration.Builder.encryptionKey()</code>传递一个512位(64字节)的密钥进行加密后存储在磁盘上。</p>
<pre><code class="java">byte[] key = new byte[64];
new SecureRandom().nextBytes(key);
RealmConfiguration config = new RealmConfiguration.Builder()
  .encryptionKey(key)
  .build();

Realm realm = Realm.getInstance(config);
</code></pre>
<p>这样的措施保证了所有存储在磁盘上的数据都是经过标准AES-256加密和解密的。当Realm文件创建后，每次创建Realm实例时都需要提供相同的密钥。</p>
<p>点击<a href="https://github.com/realm/realm-java/tree/master/examples/encryptionExample" target="_blank" rel="external">examples/encryptionExample</a>查看完整的示例，示例展示了如何通过Android KeyStore安全地存储密钥以保证其他应用不能读取此密钥。</p>
<h4 id="与Android系统结合"><a href="#与Android系统结合" class="headerlink" title="与Android系统结合"></a>与Android系统结合</h4><h5 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h5><p>Realm提供了一些抽象的工具类来方便地将 <code>OrderedRealmCollection</code><br>( <code>RealmResults</code> 和 <code>RealmList</code> 都实现了这个接口)展示到UI控件上。</p>
<ul>
<li><a href="https://realm.io/docs/java/latest/adapter/io/realm/RealmBaseAdapter.html" target="_blank" rel="external"><code>RealmBaseAdapter</code></a> 可以和 <code>ListView</code> 搭配使用。参考<a href="https://github.com/realm/realm-android-adapters/blob/master/example/src/main/java/io/realm/examples/adapters/ui/listview/MyListAdapter.java" target="_blank" rel="external">示例</a>。</li>
<li><a href="https://realm.io/docs/java/latest/adapter/io/realm/RealmRecyclerViewAdapter.html" target="_blank" rel="external"><code>RealmRecyclerViewAdapter</code></a> 可以和 <code>RecyclerView</code> 搭配使用。参见<a href="https://github.com/realm/realm-android-adapters/blob/master/example/src/main/java/io/realm/examples/adapters/ui/recyclerview/MyRecyclerViewAdapter.java" target="_blank" rel="external">示例</a>。</li>
</ul>
<p>在使用这些适配器之前，我们需要在application级别的<code>build.gradle</code>文件中添加额外的依赖:</p>
<pre><code class="gradle">dependencies {
    compile &#39;io.realm:android-adapters:2.0.0&#39;
}
</code></pre>
<h5 id="Intents"><a href="#Intents" class="headerlink" title="Intents"></a>Intents</h5><p>由于我们并不能直接在Intent之间传递<code>RealmObject</code>，所以Realm建议只传递<code>RealmObject</code>的标识符。举个很简单的🌰：如果一个一个对象拥有一个主键，那么我就可以通过<code>Intent</code>的<code>Bundle</code>传递这个值。</p>
<pre><code class="java">// 假设我们现在有一个person类，并且将其id字段设置为@PrimaryKey ...
Intent intent = new Intent(getActivity(), ReceivingService.class);
intent.putExtra(&quot;person_id&quot;, person.getId());
getActivity().startService(intent);
</code></pre>
<p>然后在接收组件中(Activity, Service, IntentService, BroadcastReceiver 等等)解析出传递的主键值并打开Realm,查询到该主键对应的<code>RealmObject</code>。</p>
<pre><code class="java">// 在onCreate(), onHandleIntent()等方法中完成
String personId = intent.getStringExtra(&quot;person_id&quot;);
Realm realm = Realm.getDefaultInstance();
try {
    Person person = realm.where(Person.class).equalTo(&quot;id&quot;, personId).findFirst();
    // 对person进行一些操作 ...
} finally {
    realm.close();
}
</code></pre>
<p>完整的示例可以在 <a href="https://github.com/realm/realm-java/tree/master/examples/threadExample" target="_blank" rel="external"><code>threading example</code></a> 的<code>Object Passing</code>部分找到。示例展示了在Android常用的如何传递id并得到对应的<code>RealmObject</code>。</p>
<h5 id="AsyncTask-amp-IntentService"><a href="#AsyncTask-amp-IntentService" class="headerlink" title="AsyncTask &amp; IntentService"></a>AsyncTask &amp; IntentService</h5><p>Realm和<code>AsyncTask</code>, <code>IntentService</code>搭配使用时，需要特别留心，<code>AsyncTask</code>类包含了一个在后台线程执行的<code>doInBackground()</code>方法，<code>IntentService</code>类包含了在工作线程执行的<code>onHandleIntent(Intent intent)</code>方法。如果我们需要在上述两个方法中使用Realm，我们需要先打开Realm，完成工作，然后在退出之前关闭Realm。下面是一些示例：</p>
<p>AsyncTask:在<code>doInBackground()</code>方法中打开和关闭Realm。</p>
<pre><code class="java">private class DownloadOrders extends AsyncTask&lt;Void, Void, Long&gt; {
    protected Long doInBackground(Void... voids) {
        // 现在已经在后台线程中了。

        // 打开Realm
        Realm realm = Realm.getDefaultInstance();
        try {
            // 使用Realm
            realm.createAllFromJson(Order.class, api.getNewOrders());
            Order firstOrder = realm.where(Order.class).findFirst();
            long orderId = firstOrder.getId(); // order的id
            return orderId;
        } finally {
            realm.close();
        }
    }

    protected void onPostExecute(Long orderId) {
        // 回到Android主线程
        // 完成一些和orderId有关的操作例如在Realm中
        // 查询order并做一些操作。
    }
}
</code></pre>
<p>IntentServie: 在<code>onHandleIntent()</code>方法中打开和关闭Realm。</p>
<pre><code class="java">
public class OrdersIntentService extends IntentService {
    public OrdersIntentService(String name) {
        super(&quot;OrdersIntentService&quot;);
    }

    @Override
    protected void onHandleIntent(Intent intent) {
        // 现在已经在后台线程中了。

        // 打开Realm
        Realm realm = Realm.getDefaultInstance();
        try {
            // 使用Realm
            realm.createAllFromJson(Order.class, api.getNewOrders());
            Order firstOrder = realm.where(Order.class).findFirst();
            long orderId = firstOrder.getId(); // order的id
        } finally {
            realm.close();
        }
    }
}
</code></pre>
<p>需要特别注意的是：在<code>IntentService</code>中，<code>ChangeListener</code>不能够正常的工作。尽管它是一个<code>Looper</code>线程，每一次调用<code>onHandleIntent()</code>不「loop」的分离事件。这也就意味着我们可以注册register listener，但是它永远也不会被触发。</p>
<h4 id="与其他第三方库结合使用"><a href="#与其他第三方库结合使用" class="headerlink" title="与其他第三方库结合使用"></a>与其他第三方库结合使用</h4><ul>
<li><a href="#Realm与GSON">Realm与GSON</a></li>
<li><a href="#Realm与Jackson-databind">Realm与Jackson-databind</a></li>
<li><a href="#Realm与Kotlin">Realm与Kotlin</a></li>
<li><a href="#Realm与Retrofit">Realm与Retrofit</a></li>
<li><a href="#Realm与RxJava">Realm与RxJava</a></li>
</ul>
<h5 id="Realm与GSON"><a href="#Realm与GSON" class="headerlink" title="Realm与GSON"></a>Realm与GSON</h5><p><a href="https://code.google.com/p/google-gson/" target="_blank" rel="external">GSON</a>是Google开发的JSON处理库，Realm和GSON可以无缝的配合使用。</p>
<pre><code class="java">// 使用User类
public class User extends RealmObject {
    private String name;
    private String email;
    // getters and setters ...
}

Gson gson = new GsonBuilder().create();
String json = &quot;{ name : &#39;John&#39;, email : &#39;john@corporation.com&#39; }&quot;;
User user = gson.fromJson(json, User.class);
</code></pre>
<p><strong>序列化(Serialization)</strong></p>
<p>我们有时需要序列化与反序列化一个Realm对象以便与其它库（比如<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a>）相配合。因为GSON使用<a href="https://groups.google.com/forum/#!topic/google-gson/4G6Lv9PghUY" target="_blank" rel="external">成员变量值而非getter和setter</a>，所以我们无法通过GSON的一般方法来序列化Realm对象。</p>
<p>我们需要为Realm模型对象自定义一个<a href="https://google.github.io/gson/apidocs/com/google/gson/JsonSerializer.html" target="_blank" rel="external">JsonSerializer</a>并且将其注册为一个<a href="https://google.github.io/gson/apidocs/com/google/gson/TypeAdapter.html" target="_blank" rel="external">TypeAdapter</a>。</p>
<p>请参考这个<a href="https://gist.github.com/cmelchior/ddac8efd018123a1e53a" target="_blank" rel="external">Gist</a>。</p>
<p><strong>数组(Primitive lists)</strong></p>
<p>某些JSON API会以数组的形式返回原始数据类型（例如String和integer），<a href="https://github.com/realm/realm-java/issues/575" target="_blank" rel="external">Realm暂时不支持对这种数组的处理</a>。但我们可以通过自定义<a href="https://google.github.io/gson/apidocs/com/google/gson/TypeAdapter" target="_blank" rel="external">TypeAdapter</a>来处理这种情况。</p>
<p>这个<a href="https://gist.github.com/cmelchior/1a97377df0c49cd4fca9" target="_blank" rel="external">Gist</a>展示了如何将JSON中的整型数组存入Realm。类似地，我们可以用这个方法来处理其它原始数据类型数组。</p>
<p><strong>Troubleshooting</strong></p>
<p>Realm 对象属性可能会包含循环引用。在这种情况下，GSON 会抛出 StackOverflowError。例如如下 Realm 对象拥有一个 Drawable 属性：</p>
<pre><code class="java">public class Person extends RealmObject {
    @Ignore
    Drawable avatar;
    // 其他字段
}
</code></pre>
<p>Person 类含有一个 Android Drawable 并且被 @Ignore 修饰。当 GSON 序列化时，Drawable 被读取并且造成了堆栈溢出。(<a href="https://github.com/realm/realm-java/issues/1798" target="_blank" rel="external">GitHub Issue</a>)。添加如下代码以避免类似问题：</p>
<pre><code class="java">public boolean shouldSkipField(FieldAttributes f) {
  return f.getDeclaringClass().equals(RealmObject.class) || f.getDeclaringClass().equals(Drawable.class);
}
</code></pre>
<p>请注意对 Drawable.class 的判定语句，它告诉 GSON 跳过这个属性的序列化以避免堆栈溢出错误。</p>
<h5 id="Realm与Jackson-databind"><a href="#Realm与Jackson-databind" class="headerlink" title="Realm与Jackson-databind"></a>Realm与Jackson-databind</h5><p><a href="https://github.com/FasterXML/jackson-databind" target="_blank" rel="external">Jackson-databind</a>是一个实现JSON数据和Java类之间绑定的库。</p>
<p>Jackson使用反射实现了数据绑定，而这与Realm对RxJava的支持产生了冲突因为对class loader而言，RxJava不一定可用。所造成的异常如下所示:</p>
<pre><code>java.lang.NoClassDefFoundError: rx.Observable
at libcore.reflect.InternalNames.getClass(InternalNames.java:55)
...
</code></pre><p>可以通过为项目引入RxJava或者在工程创建一个看起来包含下面的代码的空文件来修改上面的问题。</p>
<pre><code class="java">package rx;

public class Observable {
    // 为了支持Jackson-Databind，如果没有引入RxJava依赖，
    // 这样的空文件就是必须的
}
</code></pre>
<p>issue已经被提交到Jackson项目了，戳<a href="https://github.com/FasterXML/jackson-databind/issues/1070" target="_blank" rel="external">这里</a>。</p>
<h5 id="Realm与Kotlin"><a href="#Realm与Kotlin" class="headerlink" title="Realm与Kotlin"></a>Realm与Kotlin</h5><p>Realm 完全兼容 <a href="https://kotlinlang.org/" target="_blank" rel="external">Kotlin</a> 语言，但有些地方需要注意：</p>
<ul>
<li>我们的模型类需要是 <a href="https://kotlinlang.org/docs/reference/classes.html#overriding-members" target="_blank" rel="external">开放的(open)</a>。</li>
<li>我们可能需要在某些情况下添加注解 <code>@RealmCLass</code> 以保证编译通过。这是由于<a href="http://blog.jetbrains.com/kotlin/2015/06/better-annotation-processing-supporting-stubs-in-kapt/" target="_blank" rel="external">当前 Kotlin 注解处理器的一个限制</a>。</li>
<li>很多 Realm API 引用了 Java 类。我们必须在编译依赖中添加 <code>org.jetbrains.kotlin:kotlin-reflect:${kotlin_version}</code>。</li>
</ul>
<p><a href="https://github.com/realm/realm-java/tree/master/examples/kotlinExample" target="_blank" rel="external">参见示例</a>。</p>
<h5 id="Realm与Retrofit"><a href="#Realm与Retrofit" class="headerlink" title="Realm与Retrofit"></a>Realm与Retrofit</h5><p><a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a> 是一个由 <a href="https://github.com/square" target="_blank" rel="external">Square</a> 开发，保证类型安全（typesafe）的 REST API 处理工具。</p>
<p>Realm 可以与 Retrofit 1.x 和 2.x 无缝配合工作。但请注意 Retrofit 不会自动将对象存入 Realm。我们需要通过调用 <code>Realm.copyToRealm()</code> 或 <code>Realm.copyToRealmOrUpdate()</code> 来将它们存入 Realm。</p>
<pre><code>GitHubService service = restAdapter.create(GitHubService.class);
List&lt;Repo&gt; repos = service.listRepos(&quot;octocat&quot;);

// 从Retrofit复制数据元素到Realm
realm.beginTransaction();
List&lt;Repo&gt; realmRepos = realm.copyToRealmOrUpdate(repos);
realm.commitTransaction();
</code></pre><h5 id="Realm与RxJava"><a href="#Realm与RxJava" class="headerlink" title="Realm与RxJava"></a>Realm与RxJava</h5><p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a> 是 Netflix 发布的一个 <a href="http://reactivex.io/" target="_blank" rel="external">Reactive</a> 的扩展 库以支持 <a href="https://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="external">观察者模式</a>。</p>
<p>Realm 包含了对 RxJava 的原生支持。如下类可以被暴露为一个 <a href="https://github.com/ReactiveX/RxJava/wiki/Observable" target="_blank" rel="external"><code>Observable</code></a>：<a href="https://realm.io/docs/java/latest/api/io/realm/Realm.html#asObservable--" target="_blank" rel="external"><code>Realm</code></a>, <a href="https://realm.io/docs/java/latest/api/io/realm/RealmResults.html#asObservable--" target="_blank" rel="external"><code>RealmResults</code></a>, <a href="https://realm.io/docs/java/latest/api/io/realm/RealmObject.html#asObservable--" target="_blank" rel="external"><code>RealmObject</code></a>, <a href="https://realm.io/docs/java/latest/api/io/realm/DynamicRealm.html#asObservable--" target="_blank" rel="external"><code>DynamicRealm</code></a> 和 <a href="https://realm.io/docs/java/latest/api/io/realm/DynamicRealmObject.html#asObservable--" target="_blank" rel="external"><code>DynamicRealmObject</code></a>。</p>
<pre><code class="java">// 综合使用Realm, Retrofit 和 RxJava(使用Retrolambda使语法更简洁)
// 加载所有用户并将它们的GitHub的最新stats合并(如果有的话)
Realm realm = Realm.getDefaultInstance();
GitHubService api = retrofit.create(GitHubService.class);
realm.where(Person.class).isNotNull(&quot;username&quot;).findAllAsync().asObservable()
    .filter(persons.isLoaded)
    .flatMap(persons -&gt; Observable.from(persons))
    .flatMap(person -&gt; api.user(person.getGithubUserName())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(user -&gt; showUser(user));
</code></pre>
<p>请注意 <a href="https://realm.io/cn/docs/java/latest/#asynchronous-queries" target="_blank" rel="external">异步查询</a> 不会阻塞当前线程，如上代码会立即返回一个 RealmResults 实例。如果我们想确定该 RealmResults 已经加载完成请使用 <a href="http://reactivex.io/documentation/operators/filter.html" target="_blank" rel="external">filter operator</a> 和 <a href="https://realm.io/cn/docs/java/latest/api/io/realm/RealmResults.html#isLoaded--" target="_blank" rel="external">`RealmResults<e>.isLoaded()</e></a> 方法。通过判断 RealmResults 是否已经加载可以得知查询是否已经完成。</p>
<p>参考 <a href="https://github.com/realm/realm-java/tree/master/examples/rxJavaExample" target="_blank" rel="external">RxJava sample project</a>。</p>
<p><strong>配置</strong><br>RxJava 是可选依赖，这意味着 Realm 不会自动包含它。这样做的好处是我们可以选择需要的 RxJava 版本以及防止过多的无用方法被打包。如果我们要使用相关功能，需要手动添加 RxJava 到 <code>build.gradle</code> 文件。</p>
<pre><code>dependencies {
  compile &#39;io.reactivex:rxjava:1.1.0&#39;
}
</code></pre><p>我们也可以通过继承 <a href="https://realm.io/cn/docs/java/latest/api/io/realm/rx/RxObservableFactory.html" target="_blank" rel="external"><code>RxObservableFactory</code></a> 来决定 <code>Observable</code> 的生成方式，然后通过 <code>RealmConfiguration</code> 进行配置。</p>
<pre><code class="java">RealmConfiguration config = new RealmConfiguration.Builder()
  .rxFactory(new MyRxFactory())
  .build()
</code></pre>
<p>如果没有 <code>RxObservableFactory</code> 被定义，<code>RealmObservableFactory</code> 会被默认使用，它支持 RxJava &lt;= 1.1.*(也就意味着目前在RxJava2.0上现在还没有办法使用…)。</p>
<h2 id="版本迁移"><a href="#版本迁移" class="headerlink" title="版本迁移"></a>版本迁移</h2><p>当我们的数据结构发生了变化时，我们就需要对数据库进行升级了。而在Realm上，数据库的升级是通过迁移操作完成的，也就是把原来的数据迁移到具有新数据结构的数据库。通常，这样的操作可以分成两部完成。</p>
<ol>
<li><p>创建迁移类</p>
<pre><code class="java"> // 迁移类示例
 public class MyMigration implements RealmMigration{

       @Override
       public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {

          // DynamicRealm 暴露了一个可编辑的schema
          RealmSchema schema = realm.getSchema();

          // 迁移到版本 1 : 添加一个新的类
          // 示例:
          // public Person extends RealmObject {
          //     private String name;
          //     private int age;
          //     // getters and setters left out for brevity
          // }
          if (oldVersion == 0) {
             schema.create(&quot;Person&quot;)
                 .addField(&quot;name&quot;, String.class)
                 .addField(&quot;age&quot;, int.class);
             oldVersion++;
          }

          // 迁移到版本 2 :添加一个primary key + 对象引用
          // 示例:
          // public Person extends RealmObject {
          //     private String name;
          //     @PrimaryKey
          //     private int age;
          //     private Dog favoriteDog;
          //     private RealmList&lt;Dog&gt; dogs;
          //     // getters and setters left out for brevity
          // }
          if (oldVersion == 1) {
             schema.get(&quot;Person&quot;)
                 .addField(&quot;id&quot;, long.class, FieldAttribute.PRIMARY_KEY)
                 .addRealmObjectField(&quot;favoriteDog&quot;, schema.get(&quot;Dog&quot;))
                 .addRealmListField(&quot;dogs&quot;, schema.get(&quot;Dog&quot;));
             oldVersion++;
          }
       }

 }
</code></pre>
</li>
<li><p>使用<code>Builder.migration</code>升级数据库</p>
<p> 将版本号改为2，当Realm发现新旧版本号不一致时，会自动使用该迁移类完成迁移操作。</p>
<pre><code class="java"> RealmConfiguration config = new RealmConfiguration.Builder()
     .schemaVersion(2) // 在schema改变后，必须进行升级
     .migration(new MyMigration()) // 开始迁移
     .build()
</code></pre>
</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>写到这里，基本的内容就差不多讨论完了，事实上，Realm还有很多其他的玩法，感兴趣的话，可以戳<a href="https://realm.io/" target="_blank" rel="external">这里</a>，详细的了解。</p>
<p>我自己写了一个应用<a href="https://github.com/TonnyL/Espresso" target="_blank" rel="external">Espresso是一款基于MVP(Model-View-Presenter)架构, Material Design设计风格, 采用RxJava2, Retrofit2, Realm数据库和ZXing开发的快递追踪应用</a>，用到了Realm，感兴趣的话，可以看看。</p>
<p>本文同步发表于<a href="http://www.jianshu.com/p/42584d637fb1" target="_blank" rel="external">TonnyL的简书</a>, <a href="https://tonnyl.github.io/2017/04/03/Realm-Java-%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/">TonnyL的博客</a>, <a href="https://zhuanlan.zhihu.com/p/26173366" target="_blank" rel="external">知乎专栏Tonny的咖啡馆-人·技术·生活</a>，转载请注明作者和出处。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://realm.io/" target="_blank" rel="external">Realm:Create reactive mobile apps in a fraction of time</a></p>
<p><a href="https://youngytj.github.io/2017/01/01/Realm-Java/" target="_blank" rel="external">Android下Realm使用的2、3事</a></p>
<p><a href="http://www.jianshu.com/p/cd368b1996a7" target="_blank" rel="external">Android Realm入坑指南</a></p>
<p><a href="https://juejin.im/entry/5827f4dac4c971005438378f" target="_blank" rel="external">说说 Realm 在 Android 上的坑</a></p>
<p><a href="http://www.jianshu.com/p/37af717761cc" target="_blank" rel="external">【Android】Realm详解</a></p>
<p><a href="http://www.jianshu.com/p/8cb639a78975" target="_blank" rel="external">在Android中使用Realm作本地存储</a></p>
<p>以上所有测试均基于Realm 3.0, 设备为OnePlus 3(Android 7.1.1), 环境为macOS 10.12.4.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GitHub入门与实践]]></title>
      <url>http://tonnyl.github.io/2017/03/15/GitHub%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<p>欢迎来到GitHub的世界~<br><a id="more"></a></p>
<blockquote>
<p>本文同步发表于<a href="http://www.jianshu.com/p/f74b6900997b" target="_blank" rel="external">TonnyL的简书</a>, <a href="https://zhuanlan.zhihu.com/p/25960534" target="_blank" rel="external">知乎专栏</a>, <a href="https://tonnyl.github.io/2017/03/15/GitHub%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/">TonnyL的博客</a>, 转载请注明作者和出处。</p>
</blockquote>
<h2 id="Welcome-to-GitHub"><a href="#Welcome-to-GitHub" class="headerlink" title="Welcome to GitHub"></a>Welcome to GitHub</h2><h3 id="什么是GitHub"><a href="#什么是GitHub" class="headerlink" title="什么是GitHub"></a>什么是GitHub</h3><p><a href="https://github.com/" target="_blank" rel="external">GitHub</a>是一个<del>同性交友社区</del>，不好意思，拿错剧本了。<a href="https://github.com/" target="_blank" rel="external">GitHub</a>在<a href="https://zh.wikipedia.org/wiki/Wikipedia:%E9%A6%96%E9%A1%B5" target="_blank" rel="external">Wikipedia</a>上的介绍是<a href="https://zh.wikipedia.org/wiki/GitHub" target="_blank" rel="external">这样</a>的：</p>
<blockquote>
<p>GitHub是一个通过<a href="https://zh.wikipedia.org/wiki/Git" target="_blank" rel="external">Git</a>进行<a href="https://zh.wikipedia.org/wiki/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6" target="_blank" rel="external">版本控制</a>的软件源代码托管服务，由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用<a href="https://zh.wikipedia.org/wiki/Ruby_on_Rails" target="_blank" rel="external">Ruby on Rails</a>编写而成。</p>
</blockquote>
<p>简单来说，GitHub是一个让开发者与他人共享代码的地方。其公司总部位于美国加利福利亚州旧金山，其logo是一只名为Octocat的可爱章鱼猫，就是下面的这个小萌萌了↓</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fdng5xb7ckj30m80ih1ky.jpg" alt="Octocat"></p>
<p>当然，她还有可能是这样的🙃<br><img src="https://ww1.sinaimg.cn/large/006tNbRwgy1fdngajog08j308c08cq33.jpg" alt="Octocat"></p>
<h3 id="GitHub与Git有什么区别"><a href="#GitHub与Git有什么区别" class="headerlink" title="GitHub与Git有什么区别"></a>GitHub与Git有什么区别</h3><p>Git其实是一种版本控制的协议，定义了一个版本控制的各种操作，类似的还有SVN/CVS，但是和SVN/CVS不同的是，Git采用的是分布式的方式，并不需要服务器端的软件。</p>
<p>而GitHub是基于Git协议的一个网络代码仓库，也就是说，GitHub上公开的软件源代码都是有Git进行管理，但是GitHub除了提供Git仓库的托管服务外，还为开发者或团队提供了一系列的功能(后面会详细说明)，例如在线浏览、搜索和管理、社交等等，帮助开发者和团队高效率、高品质的编写代码。</p>
<p>(好吧，说了这么多拗口的话，简单来说，你可以将Git与GitHub的关系理解为「魔兽争霸」和「对战平台」的关系。)</p>
<h3 id="GitHub的使用情况"><a href="#GitHub的使用情况" class="headerlink" title="GitHub的使用情况"></a>GitHub的使用情况</h3><p>截止到2015年，GitHub已经有超过九百万注册用户和2110万代码库。事实上已经成为了世界上最大的代码存放网站和开源社区。全世界每时每刻都有开发者在使用它。</p>
<h3 id="GitHub提供的主要功能"><a href="#GitHub提供的主要功能" class="headerlink" title="GitHub提供的主要功能"></a>GitHub提供的主要功能</h3><ul>
<li><p>Git仓库</p>
<p>一般情况下，当我们注册了GitHub账户之后，我们免费新建任意个GitHub提供的Git仓库。如果需要建立只对特定用户或自己公开的私有仓库，则需要按照<a href="https://github.com/pricing" target="_blank" rel="external">Plans for all workflows</a>支付每月最低7美元的费用。<br><img src="https://ww4.sinaimg.cn/large/006tNc79gy1fdomdvwo4kj31kw0zaal1.jpg" alt="Plans for all workflows"></p>
</li>
<li><p><a href="https://github.com/blog/674-introducing-organizations" target="_blank" rel="external">Organization</a></p>
<p>通常情况下，如果只是个人使用，个人账户就足够了。但如果是团队或者公司，建议使用Organization账户，它可以统一管理账户和权限，同时也能统一支付一些费用。</p>
<p>和个人账户类似，如果只是创建公开仓库，创建Organization账户是不收费的。因此，对于小型开发团队而言，Organization或许是个不错的选择。<br><img src="https://ww3.sinaimg.cn/large/006tNc79gy1fdomm5qn0tj30sq0o6q69.jpg" alt="Organization"></p>
<p>下面是Google Organization账户信息:<br><img src="https://ww2.sinaimg.cn/large/006tNc79gy1fdprpuqo8lj31kw119gz2.jpg" alt="Google Organization Account"></p>
</li>
<li><p>Issue</p>
<p>Issue用于对有一个任务或问题进行追踪和管理。这有点类似于BUG管理系统(例如Mozilla公司出品的<a href="https://bugzilla.mozilla.org/" target="_blank" rel="external">Bugzilla</a>)。在GitHub上，我们每次创建一个Pull Request时，都会要求创建一个Issue。</p>
<p>每次将要对功能进行更改或者修正时，都应该创建一个Issue(除非是有特殊的原因，最好使用英文，如果使用中文，项目所有者还需要耗费时间和精力替你翻译，而这本是你应该完成的事物)，讨论或者修正都围绕这个Issue为中心进行。只要查看Issue，就能了解和这个更改有关的信息，并以此进行管理。</p>
<p>在Git的提交信息中写上Issue的ID(例如「#7」)，GitHub就会自动生成从Issue到对应提交的链接。另外，只要按照特定的格式描述提交信息，还可以关闭Issue。</p>
<p>下面是<a href="https://github.com/google/gson" target="_blank" rel="external">google-gson</a>项目的一个Issue。<br><img src="https://ww4.sinaimg.cn/large/006tNc79gy1fdps9ly95bj31kw10348p.jpg" alt=""></p>
<p>ps:请不要在Issue中讨论和项目无关的内容(例如灌水、无意义的聊天等),也不要连着发帖,因为你每发布一次无意义的内容，项目的作者和关注(Watch)这个项目的人就会收到一封垃圾邮件。所以，请共同维护GitHub的良好氛围。</p>
</li>
<li><p>Wiki</p>
<p>通过Wiki功能，任何人都可以随时对一篇文章进行更改并保存，因此可以多人共同完成一篇文章。该功能常用于在开发文档或手册的编写中。</p>
<p>Wiki也是作为Git仓库进行管理的，改进的历史记录也会被切实保存，使用者可以放心的改写，并且支持克隆到本地进行编辑。</p>
<p>这是开源大户<a href="https://github.com/square" target="_blank" rel="external">square</a>的项目<a href="https://github.com/square/okhttp" target="_blank" rel="external">okhttp</a>的wiki首页:<br><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fdwyuitbj5j31kw101jw0.jpg" alt="[okhttp wiki](https://github.com/square/okhttp/wiki)"></p>
</li>
<li><p>Pull Request</p>
<p>当我们fork了别人的代码，并做了相应的修改之后，就可以Pull Request向仓库的所有者提出申请，请求对方合并自己修改之后的代码。发出Pull Request之后，对方的管理人员可以查看Pull Request的内容及其中包含的代码更改。</p>
<p>同时，你可以利用GitHub提供的对Pull Request和源代码差别评论的功能，以行为单位对代码进行讨论。</p>
<p>square的另外一个项目<a href="https://github.com/square/retrofit" target="_blank" rel="external">retrofit</a>的<a href="https://github.com/square/retrofit/pulls" target="_blank" rel="external">Pull Request</a>:<br><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fdwyzenqh6j31kw11gdpa.jpg" alt="[Pull Request](https://github.com/square/retrofit/pulls)"></p>
</li>
<li><p><a href="https://gist.github.com/" target="_blank" rel="external">Gist</a></p>
<p>有时候我们并不需要为了一个小小的代码片段而开启一个仓库，这个时候Gist就派上用场了。Gist是一个有趣的服务，最简单的功能就是分享代码片段，但她的功能并不局限于此，Gist并不仅仅为开发者服务，任何人(允许匿名)都可以利用她分享内容。</p>
</li>
<li><p><a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages</a></p>
<p>GitHub Pages 是免费的静态空间服务，可以架设静态网站，包括静态博客。我们可以利用GitHub Pages搭配<a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>或者<a href="https://jekyllrb.com/" target="_blank" rel="external">Jekyll</a>等静态博客系统搭建我们自己的博客。</p>
<p>这是我利用GitHub Pages和Hexo搭配的博客:<br><a href="https://tonnyl.github.io/">https://tonnyl.github.io/</a></p>
</li>
</ul>
<h3 id="GitHub上的一些知名项目"><a href="#GitHub上的一些知名项目" class="headerlink" title="GitHub上的一些知名项目"></a>GitHub上的一些知名项目</h3><ul>
<li><a href="https://github.com/torvalds/linux" target="_blank" rel="external">Linux</a> - Linux kernel source tree.(43k star, 无穷个贡献者)</li>
<li><a href="https://github.com/git/git" target="_blank" rel="external">Git</a></li>
<li><a href="https://github.com/nodejs/node" target="_blank" rel="external">node</a> - Node.js JavaScript runtime.</li>
<li><a href="https://github.com/rails/rails" target="_blank" rel="external">rails</a> - Ruby on Rails.</li>
</ul>
<h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1fdx06fy4drj30us0q8q8x.jpg" alt="[GitHub](https://github.com/TonnyL)"></p>
<p>GitHub，同性交友，真人约会，排解寂寞，释放压力。百分百真人，谁没事会去注册GitHub啊，通过“Follow”交到同性好友；通过Issue和PR互动和交流。So, f**k, oh no, follow me on GitHub。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何用一周时间开发一款Android APP并在Google Play上线]]></title>
      <url>http://tonnyl.github.io/2017/02/08/%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%80%E5%91%A8%E6%97%B6%E9%97%B4%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BEAndroid-APP%E5%B9%B6%E5%9C%A8Google-Play%E4%B8%8A%E7%BA%BF/</url>
      <content type="html"><![CDATA[<p>目标：实现<a href="https://github.com/TonnyL/PaperPlane" target="_blank" rel="external">纸飞机</a>App - 采用MVP架构，集合了知乎日报、果壳精选和豆瓣一刻的综合性阅读客户端。效果图如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2440049-75f9c938a87c3c46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PaperPlane"></p>
<p>本次教程分为7天，内容分别为：</p>
<ul>
<li>第一天，准备<ul>
<li>功能需求</li>
<li>可行性分析</li>
<li>其他准备</li>
</ul>
</li>
<li>第二天，UI<ul>
<li>选择合适的UI</li>
</ul>
</li>
<li>第三天，整体架构</li>
<li>第四天，首页列表<ul>
<li>界面编写</li>
<li>实体类</li>
<li>显示数据</li>
<li>缓存内容</li>
</ul>
</li>
<li>第五天，详情页与其他<ul>
<li>界面编写</li>
<li>实体类</li>
<li>显示数据</li>
<li>设置与关于</li>
</ul>
</li>
<li>第六天，高级功能<ul>
<li>文章收藏</li>
<li>夜间模式</li>
<li>版本适配</li>
</ul>
</li>
<li>第七天，发布与开源<ul>
<li>在Google Play上线</li>
<li>在GitHub开源</li>
<li>Q&amp;A</li>
</ul>
</li>
</ul>
<p>好了，废话不多说了。现在就开始吧。</p>
<h3 id="DAY-1"><a href="#DAY-1" class="headerlink" title="DAY 1"></a>DAY 1</h3><p>俗话说，万事开头难，准备工作做好了，可以起到事半功倍的作用。磨刀不误砍柴工嘛。</p>
<h4 id="Day-1-功能需求"><a href="#Day-1-功能需求" class="headerlink" title="Day 1,功能需求"></a>Day 1,功能需求</h4><p>在开始正式编码之前，咱们还是得先把要实现的功能一一列出来，后面实现起来才有方向嘛。我认为咱们需要实现的功能有：</p>
<ul>
<li>正确获取消息列表并展示</li>
<li>能够获取历史消息</li>
<li>展示内容详情</li>
<li>后台自动缓存内容详情，方便用户在无网络连接时查看</li>
<li>收藏特定消息</li>
<li>夜间模式</li>
</ul>
<p>一共6个大的需求，不多，但是我们仔细的研究一下，实际上这6个需求涉及到了网络，UI，数据存储，后台服务等内容。相信对于聪明的你不算困难，现在我们来研究一下可行性。</p>
<h4 id="Day-1，可行性分析"><a href="#Day-1，可行性分析" class="headerlink" title="Day 1，可行性分析"></a>Day 1，可行性分析</h4><p>我们首先需要考虑的问题就是：<strong>数据从哪里来？</strong>感谢开源，GitHub上<a href="https://github.com/izzyleung" target="_blank" rel="external">izzyleung</a>大神分析了知乎日报的API并开源了，项目地址请戳这里：<a href="https://github.com/izzyleung/ZhihuDailyPurify/wiki/%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A5-API-%E5%88%86%E6%9E%90" target="_blank" rel="external">知乎日报 API 分析</a>，分析的非常详细，纸飞机项目在初期，也就是版本3.0之前也只使用了这一个API，在3.0之后还使用果壳精选和豆瓣一刻的API。如果你还想要展示更多的内容，可以戳这里：<a href="https://github.com/TonnyL/Awesome_APIs" target="_blank" rel="external">Awsome_API</a>，收集了一些国内外常用的API。</p>
<p>我们来粗略的看一下数据的内容。获取知乎日报2017年1月22日的消息列表：</p>
<pre><code>http://news-at.zhihu.com/api/4/news/before/20170122
</code></pre><p>服务器向我们返回JSON格式的内容：</p>
<pre><code class="json">{
  &quot;date&quot;: &quot;20170121&quot;,
  &quot;stories&quot;: [
    {
      &quot;images&quot;: [
        &quot;http://pic1.zhimg.com/ffcca2b2853f2af791310e6a6d694e80.jpg&quot;
      ],
      &quot;type&quot;: 0,
      &quot;id&quot;: 9165434,
      &quot;ga_prefix&quot;: &quot;012121&quot;,
      &quot;title&quot;: &quot;谁说普通人的生活就不能精彩有趣呢？&quot;
    },
    ...
    ]
}
</code></pre>
<p>OK，获取到了列表之后，我们就可以获取详细的内容了，例如，我们获取id为9165434的内容，只需要将id拼接到<code>http://news-at.zhihu.com/api/4/news/</code>之后：</p>
<pre><code>http://news-at.zhihu.com/api/4/news/9165434
</code></pre><p>获取到的内容为：</p>
<pre><code>{
  &quot;body&quot;: &quot;html格式的内容&quot;,
  &quot;image_source&quot;: &quot;《帕特森》&quot;,
  &quot;title&quot;: &quot;谁说普通人的生活就不能精彩有趣呢？&quot;,
  &quot;image&quot;: &quot;http://pic4.zhimg.com/e39083107b7324c6dbb725da83b1d7fb.jpg&quot;,
  &quot;share_url&quot;: &quot;http://daily.zhihu.com/story/9165434&quot;,
  &quot;js&quot;: [],
  &quot;ga_prefix&quot;: &quot;012121&quot;,
  &quot;section&quot;: {
    &quot;thumbnail&quot;: &quot;http://pic1.zhimg.com/ffcca2b2853f2af791310e6a6d694e80.jpg&quot;,
    &quot;id&quot;: 28,
    &quot;name&quot;: &quot;放映机&quot;
  },
  &quot;images&quot;: [
    &quot;http://pic1.zhimg.com/ffcca2b2853f2af791310e6a6d694e80.jpg&quot;
  ],
  &quot;type&quot;: 0,
  &quot;id&quot;: 9165434,
  &quot;css&quot;: [
    &quot;http://news-at.zhihu.com/css/news_qa.auto.css?v=4b3e3&quot;
  ]
}
</code></pre><p><code>body</code>字段中就是html格式的内容详情，我们就可以使用WebView来展示了。当然，知乎日报的API接口不止上面的两个，你可以点击上面的链接查看。获取果壳精选和豆瓣一刻的内容，你可以在我的项目中直接查看文件<a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/util/Api.java" target="_blank" rel="external">Api</a>。</p>
<h4 id="Day-1，其他准备"><a href="#Day-1，其他准备" class="headerlink" title="Day 1，其他准备"></a>Day 1，其他准备</h4><p>工欲善其事，必先利其器。工具准备好总是没错的。</p>
<ul>
<li>一台电脑 这个怎么说呢，没有这个的话，要进行开发工作还是很难的，咱们总不能用石器写代码吧。</li>
<li>软件：<ul>
<li><a href="https://developer.android.com/studio/index.html" target="_blank" rel="external">Android Studio</a> 标配</li>
<li><a href="https://www.google.com/chrome/" target="_blank" rel="external">Chrome</a> 程序员用360浏览器，百度浏览器什么的总觉得有点不够GEEK。</li>
<li><a href="https://www.getpostman.com/docs/introduction" target="_blank" rel="external">Postman</a> 一款功能强大的网页调试与发送网页HTTP请求的Chrome插件，我们做网络请求分析时需要用到。</li>
<li><a href="https://www.genymotion.com/" target="_blank" rel="external">Genymotion</a> 如果你嫌AS自带的模拟器慢的话，可以试试这个。</li>
<li><a href="https://git-scm.com/" target="_blank" rel="external">Git</a> 版本控制，命令行敲起来炒鸡带感哦。</li>
</ul>
</li>
<li>最好是能有一台Android手机。</li>
<li>科学上网，确保能够正常访问Google和StackOverFlow。让百度去死吧。</li>
</ul>
<p>好了，第一天的工作差不多就是这么多，熟悉一下API，把工具备好，收拾一下心情，准备明天的工作。</p>
<h3 id="DAY-2"><a href="#DAY-2" class="headerlink" title="DAY 2"></a>DAY 2</h3><p>今天主要完成的是UI设计。你可能会问了，这不是设计师的工作么。然而，我在开发纸飞机的过程中，并没有射鸡湿这种生物，UI就我自己完成了。相信大多数的程序员，美术方面应该不是那么地擅长。</p>
<p>当然，有美术和相关基础的同学可以试试用Sketch或者PS把原型图画出来，对于没有美术基础的童鞋，最简单的方法当然就是模仿现成的APP了。当然，你也可以在下列网站寻找合适的设计图：</p>
<ul>
<li><a href="https://dribbble.com/" target="_blank" rel="external">Dribbble</a></li>
<li><a href="https://www.uplabs.com/" target="_blank" rel="external">UpLabs</a></li>
<li><a href="http://www.ui.cn/" target="_blank" rel="external">UI中国</a></li>
<li><a href="http://www.zcool.com.cn/" target="_blank" rel="external">站酷ZCOOL</a></li>
</ul>
<p>另外，还有一些小的注意事项：</p>
<ul>
<li>遵守<a href="https://material.io/guidelines/" target="_blank" rel="external">Material Design设计规范</a> - 这不是强制性的要求，但是，既然我们是开发一款Android App，如果我们自己都不遵守规范，还怎么指望Android环境变好呢。</li>
<li><strong>正确使用BottomNavigation</strong> - BottomNavigation作为Google的打脸之作，诞生之初就倍受争议。我个人的建议是使用TabLayout代替底部导航，这是涉及到信仰的大事情。如果一定要用，请不要把iOS上的标准直接放在Android上使用，请参考这一篇文章:<a href="https://zhuanlan.zhihu.com/p/22005972" target="_blank" rel="external">Material Design 中的 Bottom Navigation 并不是无脑移植 iOS 导航模式的许可证</a>,并且，我向你投来一个鄙视的眼神。</li>
<li>使用正确的图标 - 尽量使用 <a href="https://material.io/icons/" target="_blank" rel="external">https://material.io/icons/</a> 网站上的图标，如果你使用iOS版本的图标，我再次向你投来一个鄙视的眼神。</li>
</ul>
<p>纸飞机的最终设计效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2440049-75f9c938a87c3c46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PaperPlane"></p>
<p>首页使用Drawer作为顶级导航，Tab为二级导航，列表项使用卡牌布局，使用FloatingActionButton作为日期选择按钮；详情页面使用可收缩的Toolbar，图片搭配文字的形式。其他高深的我也不懂了。(到后面你会发现，这里我犯了一个错误，卡牌布局用在这里是不合适的。参见：<a href="https://material.io/guidelines/components/cards.html#cards-usage" target="_blank" rel="external">https://material.io/guidelines/components/cards.html#cards-usage</a>)</p>
<h3 id="DAY-3"><a href="#DAY-3" class="headerlink" title="DAY 3"></a>DAY 3</h3><p>现在开始就要真正的写代码了。</p>
<p>新建Android Studio项目什么的就不说了，下面的是我的项目结构图：</p>
<p><img src="https://ww2.sinaimg.cn/large/006y8lVagy1fcfh31l5g1j30ni14qdk8.jpg" alt="项目结构"></p>
<pre><code>·
├── app
|   ├── libs 存放相关的jar文件等
|   ├── src
|   |   ├── androidTest 测试相关目录
|   |   ├── main
|   |   |   ├── assets 存放资源原文件
|   |   |   ├── java
|   |   |   |   ├── com.marktony.zhihudaily java包
|   |   |   |   |   ├── about 关于页面
|   |   |   |   |   ├── adapter RecyclerView与ViewPager等控件的Adapter
|   |   |   |   |   ├── app Application
|   |   |   |   |   ├── bean 存放实体类
|   |   |   |   |   ├── bookmarks 收藏页面
|   |   |   |   |   ├── customtabs Chrome Custom Tabs相关
|   |   |   |   |   ├── db 数据库相关
|   |   |   |   |   ├── detail 详细内容页面
|   |   |   |   |   ├── homepage 首页页面
|   |   |   |   |   ├── innerbrowser 内置浏览器页面
|   |   |   |   |   ├── interfaze 接口集合
|   |   |   |   |   ├── license 开源许可证页面
|   |   |   |   |   ├── search 搜索页面
|   |   |   |   |   ├── service Service集合
|   |   |   |   |   ├── settings 设置页面
|   |   |   |   |   ├── util 工具类集合
|   |   |   |   |   ├── BasePresenter.java Presenter基类
|   |   |   |   |   ├── BaseView.java View基类
|   |   |   ├── res
|   |   |   ├── AndroidManifest.xml 清单文件
</code></pre><p>(不难看出，我是按照页面和功能进行分包的。)</p>
<p>包建立完成后，我们开始导入第三方的开源库，便于简化代码的编写和实现特定的效果。找到工程目录下app文件夹，打开<code>build.gradle</code>文件，添加如下内容。</p>
<pre><code>dependencies {
    compile fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)
    // 使用volley简化网络请求
    compile files(&#39;libs/library-1.0.19.jar&#39;)
    // appcompat兼容包
    compile &#39;com.android.support:appcompat-v7:25.1.0&#39;
    // material design 设计包
    compile &#39;com.android.support:design:25.1.0&#39;
    // recycler view控件
    compile &#39;com.android.support:recyclerview-v7:25.1.0&#39;
    // preference screen 设置和关于页面的配置
    compile &#39;com.android.support:preference-v14:25.1.0&#39;
    // 支持Chrome Custom Tabs
    compile &#39;com.android.support:customtabs:25.1.0&#39;
    // card view 控件
    compile &#39;com.android.support:cardview-v7:25.1.0&#39;
    // 解析JSON数据
    compile &#39;com.google.code.gson:gson:2.7&#39;
    // 图片加载
    compile &#39;com.github.bumptech.glide:glide:3.7.0&#39;
    // 为了保持在低版本SDK中的UI一致性，引入material data time picker库
    compile &#39;com.wdullaer:materialdatetimepicker:2.5.0&#39;
    testCompile &#39;junit:junit:4.12&#39;
</code></pre><p>由于一些历史遗留问题，我并没有使用OkHttp作为网络请求包，而是选择了volley。如果你有一定的基础，可以选择使用OkHttp。</p>
<p>导入volley有两种方式：</p>
<ul>
<li><p>在<code>app</code>目录下的<code>lib</code>目录下粘贴volley的jar包，你可以在这里下载到：<a href="https://github.com/TonnyL/PaperPlane/blob/master/app/libs/library-1.0.19.jar" target="_blank" rel="external">Volley</a>。</p>
</li>
<li><p>当然也可以通过gradle引入。</p>
</li>
</ul>
<pre><code>compile &#39;com.android.volley:volley:1.0.0&#39;
</code></pre><p>然后点击Sync Project with Gradle files。</p>
<p>首先是整体的架构：MVP。关于整体架构的选择以及更加详细的介绍部分，可以戳这篇文章:<a href="https://TonnyL.github.io/2016/09/27/%E9%87%8D%E6%9E%84%EF%BC%81%E5%B0%86Google-MVP%E5%BA%94%E7%94%A8%E4%BA%8E%E5%B7%B2%E6%9C%89%E9%A1%B9%E7%9B%AE/">重构！将Google-MVP应用于已有项目</a>。这里我们仿照Google的<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">Android Architecture Blueprints [beta]</a>中的<a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">todo-mvp</a>。</p>
<ol>
<li><p>首先创建最基本的BaseView和BasePresenter,他们分别是所有View和Presenter的基类。</p>
<p> <a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/BaseView.java" target="_blank" rel="external">Baseview.java</a></p>
<pre><code class="java"> public interface BaseView&lt;T&gt; {
     // 为View设置Presenter
     void setPresenter(T presenter);
    // 初始化界面控件
     void initViews(View view);
 }
</code></pre>
<p> <a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/BasePresenter.java" target="_blank" rel="external">BasePresenter.java</a></p>
<pre><code class="java"> public interface BasePresenter {
     // 获取数据并改变界面显示，在todo-mvp的项目中的调用时机为Fragment的OnResume()方法中
     void start();
 }
</code></pre>
</li>
<li><p>然后创建一个契约类，用于同一管理View和Presenter。这里以知乎日报的部分为例(如果没有特别说明，后面的代码均以知乎日报的部分为例，果壳精选与豆瓣一刻的代码类似，详细代码可以在GitHub的repo中找到)。</p>
<p> <a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/homepage/ZhihuDailyContract.java" target="_blank" rel="external">ZhihuDailyContract.java</a></p>
<pre><code class="java"> public interface ZhihuDailyContract {

     interface View extends BaseView&lt;Presenter&gt; {

         // 显示加载或其他类型的错误
         void showError();
         // 显示正在加载
         void showLoading();
         // 停止显示正在加载
         void stopLoading();
         // 成功获取到数据后，在界面中显示
         void showResults(ArrayList&lt;ZhihuDailyNews.Question&gt; list);
         // 显示用于加载指定日期的date picker dialog
         void showPickDialog();

     }

     interface Presenter extends BasePresenter {
         // 请求数据
         void loadPosts(long date, boolean clearing);
         // 刷新数据
         void refresh();
         // 加载更多文章
         void loadMore(long date);
         // 显示详情
         void startReading(int position);
         // 随便看看
         void feelLucky();

     }

 }
</code></pre>
</li>
<li><p>在上面已经分好的子包中，创建相应的子类View和Presenter。</p>
<p> <a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/homepage/ZhihuDailyFragment.java" target="_blank" rel="external">ZhihuDailyFragment.java</a></p>
<p> ```java<br> public class ZhihuDailyFragment extends Fragment</p>
<pre><code> implements ZhihuDailyContract.View {

 public ZhihuDailyFragment() {}

 public static ZhihuDailyFragment newInstance() {
     return new ZhihuDailyFragment();
 }
</code></pre></li>
</ol>
<pre><code>    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
    }

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        return null;
    }

    @Override
    public void setPresenter(ZhihuDailyContract.Presenter presenter) {

    }

    @Override
    public void initViews(View view) {

    }

    @Override
    public void showError() {

    }

    @Override
    public void showLoading() {

    }

    @Override
    public void stopLoading() {

    }

    @Override
    public void showResults(ArrayList&lt;ZhihuDailyNews.Question&gt; list) {

    }

    @Override
    public void showPickDialog() {

    }

}
```


[ZhihuDailyPresenter.java](https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/homepage/ZhihuDailyPresenter.java)

```java
public class ZhihuDailyPresenter implements ZhihuDailyContract.Presenter {

    public ZhihuDailyPresenter(Context context, ZhihuDailyContract.View view) {

    }

    @Override
    public void loadPosts(long date, final boolean clearing) {

    }

    @Override
    public void refresh() {

    }

    @Override
    public void loadMore(long date) {

    }

    @Override
    public void startReading(int position) {

    }

    @Override
    public void feelLucky() {

    }

    @Override
    public void start() {

    }

}
```

然后完成果壳精选页面，豆瓣一刻的内容，就可以进行下面的工作了。
</code></pre><ol>
<li><p>创建VolleySingleton，即Volley的单例。这样，整个应用就可以只维护一个请求队列，加入新的网络请求也会更加的方便。</p>
<p> <a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/app/VolleySingleton.java" target="_blank" rel="external">VolleySingleton.java</a></p>
<pre><code class="java">     public class VolleySingleton {

     private static VolleySingleton volleySingleton;
     private RequestQueue requestQueue;

     private VolleySingleton(Context context){
         requestQueue = Volley.newRequestQueue(context.getApplicationContext());
     }

     public static synchronized VolleySingleton getVolleySingleton(Context context){
         if(volleySingleton == null){
             volleySingleton = new VolleySingleton(context);
         }
         return volleySingleton;
     }

     public RequestQueue getRequestQueue(){
         return this.requestQueue;
     }

     public &lt;T&gt; void addToRequestQueue(Request&lt;T&gt; req){
         getRequestQueue().add(req);
     }

 }
</code></pre>
</li>
<li><p>然后是Model层的实现。使用了Gson之后，对JSON的转换更加方便了，所以，我们只需要返回类型为String即可。</p>
<p> <a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/interfaze/OnStringListener.java" target="_blank" rel="external">OnStringListener.java</a></p>
<pre><code class="java"> public interface OnStringListener {
     /**
      * 请求成功时回调
      * @param result
      */
     void onSuccess(String result);
     /**
      * 请求失败时回调
      * @param error
      */
     void onError(VolleyError error);
 }
</code></pre>
<p> 定义了两个方法，分别为请求成功时和请求失败时的回调。</p>
<p> 然后定义一个StringModel的实现类–StringModelImpl。</p>
<p> <a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/bean/StringModelImpl.java" target="_blank" rel="external">StringModelImpl.java</a></p>
<pre><code class="java"> public class StringModelImpl {
     private Context context;
     public StringModelImpl(Context context) {
         this.context = context;
     }
     public void load(String url, final OnStringListener listener) {
         StringRequest request = new StringRequest(url, new Response.Listener&lt;String&gt;() {

 @Override
             public void onResponse(String s) {
                 listener.onSuccess(s);
             }
         }, new Response.ErrorListener() {

 @Override
             public void onErrorResponse(VolleyError volleyError) {
                 listener.onError(volleyError);
             }
         });
         VolleySingleton.getVolleySingleton(context).addToRequestQueue(request);
     }
 }
</code></pre>
</li>
<li><p>到这里，基本的架构就搭建完成了。现在可以喝杯咖啡，然后完成今天的最后一点工作，为后面的工作做准备。</p>
<p>创建<code>Api.java</code>文件，用于存储app所用到的所有API。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/util/Api.java" target="_blank" rel="external">Api.java</a></p>
<pre><code class="java">public class Api {

    // 消息内容获取与离线下载
    // 在最新消息中获取到的id，拼接到这个NEWS之后，可以获得对应的JSON格式的内容
    public static final String ZHIHU_NEWS = &quot;http://news-at.zhihu.com/api/4/news/&quot;;

    // 过往消息
    // 若要查询的11月18日的消息，before后面的数字应该为20161118
    // 知乎日报的生日为2013 年 5 月 19 日，如果before后面的数字小于20130520，那么只能获取到空消息
    public static final String ZHIHU_HISTORY = &quot;http://news.at.zhihu.com/api/4/news/before/&quot;;

    // 获取果壳精选的文章列表,通过组合相应的参数成为完整的url
    public static final String GUOKR_ARTICLES = &quot;http://apis.guokr.com/handpick/article.json?retrieve_type=by_since&amp;category=all&amp;limit=25&amp;ad=1&quot;;

    // 获取果壳文章的具体信息 V1
    public static final String GUOKR_ARTICLE_LINK_V1 = &quot;http://jingxuan.guokr.com/pick/&quot;;

    // 豆瓣一刻
    // 根据日期查询消息列表
    public static final String DOUBAN_MOMENT = &quot;https://moment.douban.com/api/stream/date/&quot;;

    // 获取文章具体内容
    public static final String DOUBAN_ARTICLE_DETAIL = &quot;https://moment.douban.com/api/post/&quot;;

}
</code></pre>
<p>创建<code>NetworkState.java</code>文件，判断当前的网络状态，是否有网络连接，WiFi或者是移动数据。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/util/NetworkState.java" target="_blank" rel="external">NetworkState.java</a></p>
<pre><code class="java">public class NetworkState {

    // 检查是否连接到网络
    public static boolean networkConnected(Context context){

        if (context != null){
            ConnectivityManager manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
            NetworkInfo info = manager.getActiveNetworkInfo();
            if (info != null)
                return info.isAvailable();
        }

        return false;
    }

    // 检查WiFi是否连接
    public static boolean wifiConnected(Context context){
        if (context != null){
            ConnectivityManager manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
            NetworkInfo info = manager.getActiveNetworkInfo();
            if (info != null){
                if (info.getType() == ConnectivityManager.TYPE_WIFI)
                    return info.isAvailable();
            }
        }
        return false;
    }

    // 检查移动网络是否连接
    public static boolean mobileDataConnected(Context context){
        if (context != null){
            ConnectivityManager manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
            NetworkInfo info = manager.getActiveNetworkInfo();
            if (info != null){
                if (info.getType() == ConnectivityManager.TYPE_MOBILE)
                    return true;
            }
        }
        return false;
    }

}
</code></pre>
<p>创建<code>DateFormatter .java</code>文件，方便将<code>long</code>类型的日期转换为<code>String</code>类型。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/util/DateFormatter.java" target="_blank" rel="external">DateFormatter.java</a></p>
<pre><code class="java">public class DateFormatter {

    /**
     * 将long类date转换为String类型
     * @param date date
     * @return String date
     */
    public String ZhihuDailyDateFormat(long date) {
        String sDate;
        Date d = new Date(date + 24*60*60*1000);
        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyyMMdd&quot;);
        sDate = format.format(d);

        return sDate;
    }

    public String DoubanDateFormat(long date){
        String sDate;
        Date d = new Date(date);
        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        sDate = format.format(d);

        return sDate;
    }

}
</code></pre>
<p>OK，day 3工作完成。</p>
</li>
</ol>
<h3 id="DAY-4"><a href="#DAY-4" class="headerlink" title="DAY 4"></a>DAY 4</h3><p>今天的只要任务是完成首页。</p>
<h4 id="Day-4，界面编写"><a href="#Day-4，界面编写" class="headerlink" title="Day 4，界面编写"></a>Day 4，界面编写</h4><p>我们的首页，使用的是Activity + Fragment搭配的方式，即一个MainActivity + MainFragment + BookmarksFragment的方式。其中，MainActivity的布局文件中包含了DrawerLayout, Toolbar以及Fragment所在的容器。</p>
<p>MainActivity对应布局文件如下:</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/res/layout/activity_main.xml" target="_blank" rel="external">activity_main.xml</a></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:id=&quot;@+id/drawer_layout&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;
    tools:openDrawer=&quot;start&quot;&gt;

    &lt;include layout=&quot;@layout/app_bar_main&quot; /&gt;

    &lt;android.support.design.widget.NavigationView
        android:id=&quot;@+id/nav_view&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_gravity=&quot;start&quot;
        android:fitsSystemWindows=&quot;true&quot;
        app:headerLayout=&quot;@layout/nav_header_main&quot;
        app:menu=&quot;@menu/activity_main_drawer&quot; /&gt;

&lt;/android.support.v4.widget.DrawerLayout&gt;
</code></pre><p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/res/layout/nav_header_main.xml" target="_blank" rel="external">nav_header_main.xml</a></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;@dimen/nav_header_height&quot;
    android:background=&quot;@drawable/nav_header&quot;
    android:gravity=&quot;bottom&quot;
    android:orientation=&quot;vertical&quot;
    android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark&quot;&gt;

&lt;/LinearLayout&gt;
</code></pre><p>nav_header实际上就只是一个简单的ImageView。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/res/layout/app_bar_main.xml" target="_blank" rel="external">app_bar_main.xml</a></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;
    tools:context=&quot;.homepage.MainActivity&quot;&gt;

    &lt;android.support.design.widget.AppBarLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        app:elevation=&quot;0dp&quot;
        android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;&gt;

        &lt;android.support.v7.widget.Toolbar
            android:id=&quot;@+id/toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;?attr/actionBarSize&quot;
            android:background=&quot;@color/colorPrimary&quot;
            app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot; /&gt;

    &lt;/android.support.design.widget.AppBarLayout&gt;

    &lt;FrameLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:id=&quot;@+id/layout_fragment&quot;
        android:layout_marginTop=&quot;?actionBarSize&quot;/&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre><p>OK，Activity的布局文件完成。然后就可以写java代码了。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/homepage/MainActivity.java" target="_blank" rel="external">MainActivity.java</a></p>
<pre><code class="java">public class MainActivity extends AppCompatActivity
        implements NavigationView.OnNavigationItemSelectedListener{

    private MainFragment mainFragment;
    private BookmarksFragment bookmarksFragment;

    private NavigationView navigationView;
    private DrawerLayout drawer;
    private Toolbar toolbar;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 初始化控件
        initViews();

        // 恢复fragment的状态
        if (savedInstanceState != null) {
            mainFragment = (MainFragment) getSupportFragmentManager().getFragment(savedInstanceState, &quot;MainFragment&quot;);
            bookmarksFragment = (BookmarksFragment) getSupportFragmentManager().getFragment(savedInstanceState, &quot;BookmarksFragment&quot;);
        } else {
            mainFragment = MainFragment.newInstance();
            bookmarksFragment = BookmarksFragment.newInstance();
        }

        if (!mainFragment.isAdded()) {
            getSupportFragmentManager().beginTransaction()
                    .add(R.id.layout_fragment, mainFragment, &quot;MainFragment&quot;)
                    .commit();
        }

        if (!bookmarksFragment.isAdded()) {
            getSupportFragmentManager().beginTransaction()
                    .add(R.id.layout_fragment, bookmarksFragment, &quot;BookmarksFragment&quot;)
                    .commit();
        }

        // 实例化BookmarksPresenter
        new BookmarksPresenter(MainActivity.this, bookmarksFragment);

        // 默认显示首页内容
        showMainFragment();

    }

    // 初始化控件
    private void initViews() {

        toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
        ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(
                this,
                drawer,
                toolbar,
                R.string.navigation_drawer_open,
                R.string.navigation_drawer_close);
        drawer.setDrawerListener(toggle);
        toggle.syncState();

        navigationView = (NavigationView) findViewById(R.id.nav_view);
        navigationView.setNavigationItemSelectedListener(this);

    }

    // 显示MainFragment并设置Title
    private void showMainFragment() {

        FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
        fragmentTransaction.show(mainFragment);
        fragmentTransaction.hide(bookmarksFragment);
        fragmentTransaction.commit();

        toolbar.setTitle(getResources().getString(R.string.app_name));

    }

    // 显示BookmarksFragment并设置Title
    private void showBookmarksFragment() {

        FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
        fragmentTransaction.show(bookmarksFragment);
        fragmentTransaction.hide(mainFragment);
        fragmentTransaction.commit();

        toolbar.setTitle(getResources().getString(R.string.nav_bookmarks));

    }

    @Override
    public boolean onNavigationItemSelected(@NonNull MenuItem item) {

        drawer.closeDrawer(GravityCompat.START);

        int id = item.getItemId();
        if (id == R.id.nav_home) {
            showMainFragment();
        } else if (id == R.id.nav_bookmarks) {
            showBookmarksFragment();
        } else if (id == R.id.nav_change_theme) {

        } else if (id == R.id.nav_settings) {

        } else if (id == R.id.nav_about) {

        }

        return true;
    }

    // 存储Fragment的状态
    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        if (mainFragment.isAdded()) {
            getSupportFragmentManager().putFragment(outState, &quot;MainFragment&quot;, mainFragment);
        }

        if (bookmarksFragment.isAdded()) {
            getSupportFragmentManager().putFragment(outState, &quot;BookmarksFragment&quot;, bookmarksFragment);
        }
    }

}
</code></pre>
<p>从代码中可以看出,MainActivity负责处理DrawerLayout的点击事件，即控制显示或者隐藏特定的Fragment。而Fragment的状态的保存与恢复也是在这里进行的。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/homepage/MainFragment.java" target="_blank" rel="external">MainFragment.java</a></p>
<pre><code class="java">public class MainFragment extends Fragment {

    private Context context;
    private MainPagerAdapter adapter;

    private TabLayout tabLayout;

    private ZhihuDailyFragment zhihuDailyFragment;
    private GuokrFragment guokrFragment;
    private DoubanMomentFragment doubanMomentFragment;

    private ZhihuDailyPresenter zhihuDailyPresenter;
    private GuokrPresenter guokrPresenter;
    private DoubanMomentPresenter doubanMomentPresenter;

    public MainFragment() {}

    public static MainFragment newInstance() {
        return new MainFragment();
    }

    @Override
    public void onAttach(Context context) {
        super.onAttach(context);
    }

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        this.context = getActivity();

        // Fragment状态恢复
        if (savedInstanceState != null) {
            FragmentManager manager = getChildFragmentManager();
            zhihuDailyFragment = (ZhihuDailyFragment) manager.getFragment(savedInstanceState, &quot;zhihu&quot;);
            guokrFragment = (GuokrFragment) manager.getFragment(savedInstanceState, &quot;guokr&quot;);
            doubanMomentFragment = (DoubanMomentFragment) manager.getFragment(savedInstanceState, &quot;douban&quot;);
        } else {
            // 创建View实例
            zhihuDailyFragment = ZhihuDailyFragment.newInstance();
            guokrFragment = GuokrFragment.newInstance();
            doubanMomentFragment = DoubanMomentFragment.newInstance();
        }

        // 创建Presenter实例
        zhihuDailyPresenter = new ZhihuDailyPresenter(context, zhihuDailyFragment);
        guokrPresenter = new GuokrPresenter(context, guokrFragment);
        doubanMomentPresenter = new DoubanMomentPresenter(context, doubanMomentFragment);

    }

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_main, container, false);

        // 初始化控件
        initViews(view);

        // 显示菜单
        setHasOptionsMenu(true);

        // 当tab layout位置为果壳精选时，隐藏fab
        tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() {
            @Override
            public void onTabSelected(TabLayout.Tab tab) {
                FloatingActionButton fab = (FloatingActionButton) getActivity().findViewById(R.id.fab);
                if (tab.getPosition() == 1) {
                    fab.hide();
                } else {
                    fab.show();
                }

            }

            @Override
            public void onTabUnselected(TabLayout.Tab tab) {

            }

            @Override
            public void onTabReselected(TabLayout.Tab tab) {

            }

        });

        return view;
    }


    // 初始化控件
    private void initViews(View view) {

        tabLayout = (TabLayout) view.findViewById(R.id.tab_layout);
        ViewPager viewPager = (ViewPager) view.findViewById(R.id.view_pager);
        // 设置离线数为3
        viewPager.setOffscreenPageLimit(3);

        adapter = new MainPagerAdapter(
                getChildFragmentManager(),
                context,
                zhihuDailyFragment,
                guokrFragment,
                doubanMomentFragment);

        viewPager.setAdapter(adapter);
        tabLayout.setupWithViewPager(viewPager);

    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        super.onCreateOptionsMenu(menu, inflater);
        inflater.inflate(R.menu.main, menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        int id = item.getItemId();

        if (id == R.id.action_feel_lucky) {
            feelLucky();
        }
        return true;
    }

    // 保存状态
    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        FragmentManager manager = getChildFragmentManager();
        manager.putFragment(outState, &quot;zhihu&quot;, zhihuDailyFragment);
        manager.putFragment(outState, &quot;guokr&quot;, guokrFragment);
        manager.putFragment(outState, &quot;douban&quot;, doubanMomentFragment);
    }

    // 随便看看
    public void feelLucky() {
        Random random = new Random();
        int type = random.nextInt(3);
        switch (type) {
            case 0:
                zhihuDailyPresenter.feelLucky();
                break;
            case 1:
                guokrPresenter.feelLucky();
                break;
            default:
                doubanMomentPresenter.feelLucky();
                break;
        }
    }

    public MainPagerAdapter getAdapter() {
        return adapter;
    }
}
</code></pre>
<p>首页的MainFragment主要负责显示与TabLayout + ViewPager相关的内容。</p>
<p>OK，终于把首页的UI框架搭建好了，喝杯咖啡，休息一下，冷静冷静。</p>
<p>现在开始实现具体的<code>ZhihuDailyFragment</code>的布局。仔细观察，实际上，ZhihuDailyFragment所包含的控件就只有一个<code>RecyclerView</code>，将获取到的内容以列表的形式显示出来。并且，不难发现，果壳精选与豆瓣一刻的布局与知乎日报的列表布局相同，可以复用。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/res/layout/fragment_list.xml" target="_blank" rel="external">fragment_list.xml</a></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.v4.widget.SwipeRefreshLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:id=&quot;@+id/refreshLayout&quot;&gt;

    &lt;FrameLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:focusable=&quot;true&quot;
        android:clickable=&quot;true&quot;&gt;

        &lt;android.support.v7.widget.RecyclerView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;
            android:id=&quot;@+id/recyclerView&quot;
            android:scrollbars=&quot;vertical&quot;
            android:scrollbarFadeDuration=&quot;1&quot;
            android:fadeScrollbars=&quot;true&quot;/&gt;

    &lt;/FrameLayout&gt;

&lt;/android.support.v4.widget.SwipeRefreshLayout&gt;
</code></pre><p>布局实际上还包含了SwipeRefreshLayout，用于显示正在加载和手动刷新。</p>
<p>列表子项的布局有很多种，分别是:</p>
<ol>
<li>普通仅文字</li>
<li>普通文字 + 图片</li>
<li>头部项，用于显示子项类型(如知乎日报，在收藏页面会用到)</li>
<li>底部项，加载更多等</li>
</ol>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/res/layout/home_list_item_without_image.xml" target="_blank" rel="external">home_list_item_without_image.xml</a> - 普通仅文字</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.v7.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_height=&quot;96dp&quot;
    android:layout_width=&quot;match_parent&quot;
    android:focusable=&quot;true&quot;
    android:clickable=&quot;true&quot;
    android:foreground=&quot;?android:attr/selectableItemBackground&quot;
    app:cardCornerRadius=&quot;4dp&quot;
    app:cardElevation=&quot;1dp&quot;
    app:cardPreventCornerOverlap=&quot;true&quot;
    android:layout_marginTop=&quot;8dp&quot;
    android:layout_marginLeft=&quot;8dp&quot;
    android:layout_marginRight=&quot;8dp&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:id=&quot;@+id/textViewTitle&quot;
        android:paddingTop=&quot;8dp&quot;
        android:paddingBottom=&quot;8dp&quot;
        android:paddingLeft=&quot;8dp&quot;
        android:paddingRight=&quot;8dp&quot;
        android:gravity=&quot;center_vertical&quot;
        android:maxLines=&quot;3&quot;
        android:ellipsize=&quot;end&quot;
        android:textSize=&quot;18sp&quot; /&gt;

&lt;/android.support.v7.widget.CardView&gt;
</code></pre><p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/res/layout/home_list_item_layout.xml" target="_blank" rel="external">home_list_item_layout.xml</a> - 普通文字 + 图片</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.v7.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_height=&quot;96dp&quot;
    android:layout_width=&quot;match_parent&quot;
    android:focusable=&quot;true&quot;
    android:clickable=&quot;true&quot;
    android:foreground=&quot;?android:attr/selectableItemBackground&quot;
    app:cardCornerRadius=&quot;4dp&quot;
    app:cardElevation=&quot;1dp&quot;
    app:cardPreventCornerOverlap=&quot;true&quot;
    android:layout_marginTop=&quot;8dp&quot;
    android:layout_marginLeft=&quot;8dp&quot;
    android:layout_marginRight=&quot;8dp&quot;&gt;

    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;horizontal&quot;
        android:paddingLeft=&quot;8dp&quot;
        android:paddingRight=&quot;8dp&quot; &gt;

        &lt;TextView
            android:layout_width=&quot;0dp&quot;
            android:layout_height=&quot;match_parent&quot;
            android:layout_weight=&quot;1&quot;
            android:id=&quot;@+id/textViewTitle&quot;
            android:paddingTop=&quot;8dp&quot;
            android:paddingBottom=&quot;8dp&quot;
            android:layout_marginRight=&quot;8dp&quot;
            android:layout_marginEnd=&quot;8dp&quot;
            android:gravity=&quot;center_vertical&quot;
            android:maxLines=&quot;3&quot;
            android:ellipsize=&quot;end&quot;
            android:textSize=&quot;18sp&quot; /&gt;

        &lt;ImageView
            android:layout_width=&quot;80dp&quot;
            android:layout_height=&quot;80dp&quot;
            android:id=&quot;@+id/imageViewCover&quot;
            android:layout_gravity=&quot;center_vertical&quot; /&gt;

    &lt;/LinearLayout&gt;

&lt;/android.support.v7.widget.CardView&gt;
</code></pre><p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/res/layout/bookmark_header.xml" target="_blank" rel="external">bookmark_header.xml</a> - 头部项</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:id=&quot;@+id/textViewType&quot;
    android:paddingLeft=&quot;8dp&quot;
    android:paddingStart=&quot;8dp&quot;
    android:paddingRight=&quot;8dp&quot;
    android:paddingEnd=&quot;8dp&quot;
    android:paddingTop=&quot;8dp&quot;
    android:gravity=&quot;center_vertical&quot;
    android:textColor=&quot;@color/colorPrimary&quot;
    android:textAllCaps=&quot;true&quot;/&gt;
</code></pre><p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/res/layout/list_footer.xml" target="_blank" rel="external">list_footer.xml</a> - 底部项，加载更多</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;horizontal&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;48dp&quot;
    android:layout_marginTop=&quot;8dp&quot;
    android:layout_marginBottom=&quot;8dp&quot;
    android:gravity=&quot;center_horizontal&quot;
    android:background=&quot;@color/viewBackground&quot;&gt;

    &lt;android.support.v4.widget.ContentLoadingProgressBar
        android:id=&quot;@+id/address_looking_up&quot;
        style=&quot;?android:attr/progressBarStyleInverse&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_gravity=&quot;center_horizontal&quot;
        android:visibility=&quot;visible&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;match_parent&quot;
        android:text=&quot;@string/loading_more&quot;
        android:layout_marginLeft=&quot;16dp&quot;
        android:layout_marginStart=&quot;8dp&quot;
        android:gravity=&quot;center_vertical&quot;/&gt;

&lt;/LinearLayout&gt;
</code></pre><p>布局文件到这里基本就完成了。</p>
<h4 id="Day-4，实体类"><a href="#Day-4，实体类" class="headerlink" title="Day 4，实体类"></a>Day 4，实体类</h4><p>我们可以直接通过JSON格式的返回数据设计实体类。可以手动编写代码，也可以利用Android Studio插件<a href="https://github.com/zzz40500/GsonFormat" target="_blank" rel="external">GsonFormat</a>实现。</p>
<p>Json格式数据:</p>
<pre><code class="json">{
  &quot;date&quot;: &quot;20170121&quot;,
  &quot;stories&quot;: [
    {
      &quot;images&quot;: [
        &quot;http://pic1.zhimg.com/ffcca2b2853f2af791310e6a6d694e80.jpg&quot;
      ],
      &quot;type&quot;: 0,
      &quot;id&quot;: 9165434,
      &quot;ga_prefix&quot;: &quot;012121&quot;,
      &quot;title&quot;: &quot;谁说普通人的生活就不能精彩有趣呢？&quot;
    },
    ...
    ]
}
</code></pre>
<p>对应的bean:<a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/bean/ZhihuDailyNews.java" target="_blank" rel="external">ZhihuDailyNews.java</a></p>
<pre><code class="java">public class ZhihuDailyNews {

    private String date;
    private ArrayList&lt;Question&gt; stories;

    public String getDate() {
        return date;
    }

    public void setDate(String date) {
        this.date = date;
    }

    public ArrayList&lt;Question&gt; getStories() {
        return stories;
    }

    public void setStories(ArrayList&lt;Question&gt; stories) {
        this.stories = stories;
    }

    public class Question {

        private ArrayList&lt;String&gt; images;
        private int type;
        private int id;
        private String ga_prefix;
        private String title;

        public ArrayList&lt;String&gt; getImages() {
            return images;
        }

        public void setImages(ArrayList&lt;String&gt; images) {
            this.images = images;
        }

        public int getType() {
            return type;
        }

        public void setType(int type) {
            this.type = type;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public String getGa_prefix() {
            return ga_prefix;
        }

        public void setGa_prefix(String ga_prefix) {
            this.ga_prefix = ga_prefix;
        }

        public String getTitle() {
            return title;
        }

        public void setTitle(String title) {
            this.title = title;
        }

    }

}
</code></pre>
<h4 id="Day-4，显示数据"><a href="#Day-4，显示数据" class="headerlink" title="Day 4，显示数据"></a>Day 4，显示数据</h4><p>首先，我们得有一个adapter。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/adapter/ZhihuDailyNewsAdapter.java" target="_blank" rel="external">ZhihuDailyNewsAdapter.java</a></p>
<pre><code class="java">public class ZhihuDailyNewsAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; {

    private final Context context;
    private final LayoutInflater inflater;
    private List&lt;ZhihuDailyNews.Question&gt; list = new ArrayList&lt;ZhihuDailyNews.Question&gt;();
    private OnRecyclerViewOnClickListener mListener;

    // 文字 + 图片
    private static final int TYPE_NORMAL = 0;
    // footer，加载更多
    private static final int TYPE_FOOTER = 1;

    public ZhihuDailyNewsAdapter(Context context, List&lt;ZhihuDailyNews.Question&gt; list){
        this.context = context;
        this.list = list;
        this.inflater = LayoutInflater.from(context);
    }

    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        // 根据ViewType加载不同布局
        switch (viewType) {
            case TYPE_NORMAL:
                return new NormalViewHolder(inflater.inflate(R.layout.home_list_item_layout, parent, false), mListener);
            case TYPE_FOOTER:
                return new FooterViewHolder(inflater.inflate(R.layout.list_footer, parent, false));
        }
        return null;
    }

    @Override
    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {

        // 对不同的ViewHolder做不同的处理
        if (holder instanceof NormalViewHolder) {

            ZhihuDailyNews.Question item = list.get(position);

            if (item.getImages().get(0) == null){
                ((NormalViewHolder)holder).itemImg.setImageResource(R.drawable.placeholder);
            } else {
                Glide.with(context)
                        .load(item.getImages().get(0))
                        .asBitmap()
                        .placeholder(R.drawable.placeholder)
                        .diskCacheStrategy(DiskCacheStrategy.SOURCE)
                        .error(R.drawable.placeholder)
                        .centerCrop()
                        .into(((NormalViewHolder)holder).itemImg);
            }
            ((NormalViewHolder)holder).tvLatestNewsTitle.setText(item.getTitle());
        }

    }

    // 因为含有footer，返回值需要 + 1
    @Override
    public int getItemCount() {
        return list.size() + 1;
    }

    @Override
    public int getItemViewType(int position) {
        if (position == list.size()) {
            return ZhihuDailyNewsAdapter.TYPE_FOOTER;
        }
        return ZhihuDailyNewsAdapter.TYPE_NORMAL;
    }

    public void setItemClickListener(OnRecyclerViewOnClickListener listener){
        this.mListener = listener;
    }

    public class NormalViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener {

        private ImageView itemImg;
        private TextView tvLatestNewsTitle;
        private OnRecyclerViewOnClickListener listener;

        public NormalViewHolder(View itemView, OnRecyclerViewOnClickListener listener) {
            super(itemView);
            itemImg = (ImageView) itemView.findViewById(R.id.imageViewCover);
            tvLatestNewsTitle = (TextView) itemView.findViewById(R.id.textViewTitle);
            this.listener = listener;
            itemView.setOnClickListener(this);
        }

        @Override
        public void onClick(View v) {
            if (listener != null){
                listener.OnItemClick(v,getLayoutPosition());
            }
        }
    }

    public class FooterViewHolder extends RecyclerView.ViewHolder{

        public FooterViewHolder(View itemView) {
            super(itemView);
        }

    }

}
</code></pre>
<p>adapter中含有两个常量，<code>TYPE_NORMAL</code>,<code>TYPE_FOOTER</code>,用于区别item的类型，从而加载不同的布局。众所周知，RecyclerView原生并没有设置item点击事件的方法，所有我们需要自己定义一个接口–<code>OnRecyclerViewOnClickListener</code>。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/interfaze/OnRecyclerViewOnClickListener.java" target="_blank" rel="external">OnRecyclerViewOnClickListener.java</a></p>
<pre><code class="java">package com.marktony.zhihudaily.interfaze;

import android.view.View;

public interface OnRecyclerViewOnClickListener {

    void OnItemClick(View v,int position);

}
</code></pre>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/homepage/ZhihuDailyPresenter.java" target="_blank" rel="external">ZhihuDailyPresenter.java</a></p>
<p>实现<code>ZhihuDailyPresenter</code>中的<code>loadPosts</code>方法，记得要在manifest清单文件中添加网络访问权限：</p>
<pre><code class="java">model.load(Api.ZHIHU_HISTORY + formatter.ZhihuDailyDateFormat(date), new OnStringListener() {
                @Override
                public void onSuccess(String result) {

                    try {
                        ZhihuDailyNews post = gson.fromJson(result, ZhihuDailyNews.class);

                        if (clearing) {
                            list.clear();
                        }

                        for (ZhihuDailyNews.Question item : post.getStories()) {
                            list.add(item);                          
                        }
                        view.showResults(list);

                    } catch (JsonSyntaxException e) {
                        view.showError();
                    }

                    view.stopLoading();
                }

                @Override
                public void onError(VolleyError error) {
                    view.stopLoading();
                    view.showError();
                }
            });
</code></pre>
<p>我们通过Gson，可以很简单将JSON格式数据转换为Java对象。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/homepage/ZhihuDailyFragment.java" target="_blank" rel="external">ZhihuDailyFragment</a></p>
<p>实现<code>ZhihuDailyFragment</code>的<code>showResults</code>方法。</p>
<pre><code class="java">@Override
public void showResults(ArrayList&lt;ZhihuDailyNews.Question&gt; list) {
    if (adapter == null) {
        adapter = new ZhihuDailyNewsAdapter(getContext(), list);
        adapter.setItemClickListener(new OnRecyclerViewOnClickListener() {
            @Override
            public void OnItemClick(View v, int position) {
                presenter.startReading(position);
            }
        });
        recyclerView.setAdapter(adapter);
    } else {
        adapter.notifyDataSetChanged();
    }
}
</code></pre>
<h4 id="Day-4，缓存内容"><a href="#Day-4，缓存内容" class="headerlink" title="Day 4，缓存内容"></a>Day 4，缓存内容</h4><p>完成上面的代码，我们还只是实现了在有网络状态下的正常运行，如果用户并没有那么畅通无阻的网络连接呢？这个时候缓存就派上用场了，只要用户加载过一次，以后就算没有网络连接，用户也能查看之前已经离线的内容。我们选择使用Android原生SQLite数据库来存储数据(当然你也可以选择<a href="https://realm.io/" target="_blank" rel="external">Realm</a>)。</p>
<p>首先当然是要建立数据库了(由于纸飞机已经进行多个版本的迭代，所以你创建数据库的SQL语句或其他内容和我的文件应该不完全相同)。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/db/DatabaseHelper.java" target="_blank" rel="external">DatabaseHelper.java</a></p>
<pre><code class="java">public class DatabaseHelper extends SQLiteOpenHelper {


    public DatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
        super(context, name, factory, version);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {

        db.execSQL(&quot;create table if not exists Zhihu(&quot;
                + &quot;id integer primary key autoincrement,&quot;
                + &quot;zhihu_id integer not null,&quot;
                + &quot;zhihu_news text,&quot;
                + &quot;zhihu_time real,&quot;
                + &quot;zhihu_content text)&quot;);

        db.execSQL(&quot;alter table Zhihu add column bookmark integer default 0&quot;);

    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

   }
}
</code></pre>
<p>相信大牛应该看出来了，这数据库设计的真心不怎么样😂，因为我数据库学的确实很一般。求大牛不喷。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td> id</td>
<td>integer</td>
<td>主键</td>
<td>自增长</td>
</tr>
<tr>
<td> zhihu_id</td>
<td>integer</td>
<td>知乎日报消息id</td>
<td>由知乎提供</td>
</tr>
<tr>
<td> zhihu_news</td>
<td>text</td>
<td>知乎日报消息内容</td>
<td>与Java实体类对应</td>
</tr>
<tr>
<td> zhihu_time</td>
<td>real</td>
<td>知乎日报消息发布的时间</td>
<td>由知乎提供</td>
</tr>
<tr>
<td> zhihu_content</td>
<td>text</td>
<td>知乎日报消息详细内容</td>
<td>与Java实体类对应</td>
</tr>
<tr>
<td> bookmark</td>
<td>integer</td>
<td>是否被收藏</td>
<td>由于SQLite并没有boolean类型，使用integer的不同值代替</td>
</tr>
</tbody>
</table>
<p>OK,当我们正确请求到数据后，就可以进行存储了。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/homepage/ZhihuDailyPresenter.java" target="_blank" rel="external">ZhihuDailyPresenter.java</a></p>
<pre><code class="java">if ( !queryIfIDExists(item.getId())) {
    db.beginTransaction();
    try {
        DateFormat format = new SimpleDateFormat(&quot;yyyyMMdd&quot;);
        Date date = format.parse(post.getDate());
        values.put(&quot;zhihu_id&quot;, item.getId());
        values.put(&quot;zhihu_news&quot;, gson.toJson(item));
        values.put(&quot;zhihu_content&quot;, &quot;&quot;);
        values.put(&quot;zhihu_time&quot;, date.getTime() / 1000);
        db.insert(&quot;Zhihu&quot;, null, values);
        values.clear();
        db.setTransactionSuccessful();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        db.endTransaction();
    }
}

// 查询数据库表中是否已经存在了此id
private boolean queryIfIDExists(int id){

    Cursor cursor = db.query(&quot;Zhihu&quot;,null,null,null,null,null,null);
    if (cursor.moveToFirst()){
        do {
            if (id == cursor.getInt(cursor.getColumnIndex(&quot;zhihu_id&quot;))){
                return true;
            }
        } while (cursor.moveToNext());
    }
    cursor.close();

    return false;
}
</code></pre>
<p>细心的童鞋可能发现了，诶，数据表中还有一个字段–zhihu_content，你没有存储呀。这是因为我们在请求知乎消息列表的时候，并没有返回消息的详细内容呀。不过详细内容我们还是需要缓存的，网络请求在UI线程上进行可能会引起ANR，那更好的解决办法就是在Service里面完成了。</p>
<p>我们先将一些必须的数据通过本地广播的形式，发送出去。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/homepage/ZhihuDailyPresenter.java" target="_blank" rel="external">ZhihuDailyPresenter.java</a></p>
<pre><code class="java">Intent intent = new Intent(&quot;com.marktony.zhihudaily.LOCAL_BROADCAST&quot;);
intent.putExtra(&quot;type&quot;, CacheService.TYPE_ZHIHU);
intent.putExtra(&quot;id&quot;, item.getId());
LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
</code></pre>
<p>然后在<code>CacheService</code>里接收广播，获取传送的数据，然后进行网络请求和数据存储。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/service/CacheService.java" target="_blank" rel="external">CacheService.java</a></p>
<pre><code class="java">public class CacheService extends Service {

    private DatabaseHelper dbHelper;
    private SQLiteDatabase db;

    private static final String TAG = CacheService.class.getSimpleName();

    public static final int TYPE_ZHIHU = 0x00;
    public static final int TYPE_GUOKR = 0x01;
    public static final int TYPE_DOUBAN = 0x02;

    @Override
    public void onCreate() {
        super.onCreate();
        dbHelper = new DatabaseHelper(this, &quot;History.db&quot;, null, 5);
        db = dbHelper.getWritableDatabase();

        IntentFilter filter = new IntentFilter();
        filter.addAction(&quot;com.marktony.zhihudaily.LOCAL_BROADCAST&quot;);
        LocalBroadcastManager manager = LocalBroadcastManager.getInstance(this);
        manager.registerReceiver(new LocalReceiver(), filter);

    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    public boolean onUnbind(Intent intent) {
        return super.onUnbind(intent);
    }

    /**
     * 网络请求id对应的知乎日报的内容主体
     * 当type为0时，存储body中的数据
     * 当type为1时，再次请求share url中的内容并储存
     * @param id 所要获取的知乎日报消息内容对应的id
     */
    private void startZhihuCache(final int id) {

        Cursor cursor = db.query(&quot;Zhihu&quot;, null, null, null, null, null, null);
        if (cursor.moveToFirst()) {
            do {
                if ((cursor.getInt(cursor.getColumnIndex(&quot;zhihu_id&quot;)) == id)
                        &amp;&amp; (cursor.getString(cursor.getColumnIndex(&quot;zhihu_content&quot;)).equals(&quot;&quot;))) {
                    StringRequest request = new StringRequest(Request.Method.GET, Api.ZHIHU_NEWS + id, new Response.Listener&lt;String&gt;() {
                        @Override
                        public void onResponse(String s) {
                            Gson gson = new Gson();
                            ZhihuDailyStory story = gson.fromJson(s, ZhihuDailyStory.class);
                            if (story.getType() == 1) {
                                StringRequest request = new StringRequest(Request.Method.GET, story.getShare_url(), new Response.Listener&lt;String&gt;() {
                                    @Override
                                    public void onResponse(String s) {
                                        ContentValues values = new ContentValues();
                                        values.put(&quot;zhihu_content&quot;, s);
                                        db.update(&quot;Zhihu&quot;, values, &quot;zhihu_id = ?&quot;, new String[] {String.valueOf(id)});
                                        values.clear();
                                    }
                                }, new Response.ErrorListener() {
                                    @Override
                                    public void onErrorResponse(VolleyError volleyError) {

                                    }
                                });
                                request.setTag(TAG);
                                VolleySingleton.getVolleySingleton(CacheService.this).addToRequestQueue(request);
                            } else {
                                ContentValues values = new ContentValues();
                                values.put(&quot;zhihu_content&quot;, s);
                                db.update(&quot;Zhihu&quot;, values, &quot;zhihu_id = ?&quot;, new String[] {String.valueOf(id)});
                                values.clear();
                            }

                        }
                    }, new Response.ErrorListener() {
                        @Override
                        public void onErrorResponse(VolleyError volleyError) {

                        }
                    });
                    request.setTag(TAG);
                    VolleySingleton.getVolleySingleton(CacheService.this).addToRequestQueue(request);
                }
            } while (cursor.moveToNext());
        }
        cursor.close();
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        VolleySingleton.getVolleySingleton(this).getRequestQueue().cancelAll(TAG);
    }

    class LocalReceiver extends BroadcastReceiver {

        @Override
        public void onReceive(Context context, Intent intent) {
            int id = intent.getIntExtra(&quot;id&quot;, 0);
            switch (intent.getIntExtra(&quot;type&quot;, -1)) {
                case TYPE_ZHIHU:
                    startZhihuCache(id);
                    break;
                case TYPE_GUOKR:
                    startGuokrCache(id);
                    break;
                case TYPE_DOUBAN:
                    startDoubanCache(id);
                    break;
                default:
                case -1:
                    break;
            }
        }
    }

}
</code></pre>
<p>我们先遍历一下数据库，如果数据库中指定id的消息详情内容已经不为空，那我们就直接跳过了，可以节省用户的流量以及电量。</p>
<p>到这里，数据的存储是完成了。可是怎么读取出来呢？哈，其实也简单，我们判断一下当前的网络状态，如果用户设备没有连接到网路，我们就直接去数据库中读取，然后解析就行了。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/homepage/ZhihuDailyPresenter.java" target="_blank" rel="external">ZhihuDailyPresenter.java</a></p>
<pre><code class="java">if (NetworkState.networkConnected(context)) {
    // balabala
} else {
    Cursor cursor = db.query(&quot;Zhihu&quot;, null, null, null, null, null, null);
    if (cursor.moveToFirst()) {
        do {
            ZhihuDailyNews.Question question = gson.fromJson(cursor.getString(cursor.getColumnIndex(&quot;zhihu_news&quot;)), ZhihuDailyNews.Question.class);
            list.add(question);
        } while (cursor.moveToNext());
    }
    cursor.close();
    view.stopLoading();
    view.showResults(list);
}
</code></pre>
<p>到这里，今天的工作差不多已经完成了，等等，是不是忘了什么？我们的Service并没有启动呀。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/homepage/MainActivity.java" target="_blank" rel="external">MainActivity.java</a></p>
<pre><code class="java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    initViews();

    // 启动服务
    startService(new Intent(this, CacheService.class));

}

@Override
protected void onDestroy() {
    ActivityManager manager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
    for (ActivityManager.RunningServiceInfo service : manager.getRunningServices(Integer.MAX_VALUE)) {
        if (CacheService.class.getName().equals(service.service.getClassName())) {
            stopService(new Intent(this, CacheService.class));
        }
    }
    super.onDestroy();
}
</code></pre>
<p>到这里，今天的内容就算结束了，内容是一周之中最多的一天，可能比前几天的总和还要多，可能需要你加班才能完全完成，之前Activity, Presenter, Fragment中各还有一部分内容没有完成，需要你自行补充完成。不过，看到自己的App正确的跑了起来，有木有很兴奋呢？休息休息，准备明天的工作吧。</p>
<h3 id="DAY-5"><a href="#DAY-5" class="headerlink" title="DAY 5"></a>DAY 5</h3><p>今天的内容是显示消息详情内容。因为我们的消息内容实际上有三种类型，这里就不再重复。怎么区分呢？我的方法是定义了一个枚举类型:</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/bean/BeanType.java" target="_blank" rel="external">BeanType.java</a></p>
<pre><code class="java">public enum BeanType {

    TYPE_ZHIHU,TYPE_GUOKR,TYPE_DOUBAN;

}
</code></pre>
<p>这样，我们就能根据不同的消息类型，获取和加载不同的消息详情内容了。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/homepage/ZhihuDailyPresenter.java" target="_blank" rel="external">ZhihuDailyPresenter.java</a></p>
<pre><code class="java">@Override
public void startReading(int position) {

    context.startActivity(new Intent(context, DetailActivity.class)
            .putExtra(&quot;type&quot;, BeanType.TYPE_ZHIHU)
            .putExtra(&quot;id&quot;, list.get(position).getId())
            .putExtra(&quot;title&quot;, list.get(position).getTitle())
            .putExtra(&quot;coverUrl&quot;, list.get(position).getImages().get(0)));

}
</code></pre>
<h4 id="Day-5-界面编写"><a href="#Day-5-界面编写" class="headerlink" title="Day 5,界面编写"></a>Day 5,界面编写</h4><p>从知乎给我们的详情内容为HTML格式来看，用WebView作为显示控件最合适不过了(实际上果壳和豆瓣的详情页内容要么是返回了HTML格式，要么是直接给出了详情页的网页地址，做简单处理即可，可以实现复用)。</p>
<p>先看布局文件代码：</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/res/layout/universal_read_layout.xml" target="_blank" rel="external">universal_read_layout.xml</a></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;
    android:id=&quot;@+id/coordinatorLayout&quot;&gt;

    &lt;android.support.design.widget.AppBarLayout
        android:id=&quot;@+id/app_bar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;@dimen/app_bar_height&quot;
        android:fitsSystemWindows=&quot;true&quot;
        android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;&gt;

        &lt;android.support.design.widget.CollapsingToolbarLayout
            android:id=&quot;@+id/toolbar_layout&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;
            android:fitsSystemWindows=&quot;true&quot;
            app:contentScrim=&quot;@color/colorPrimary&quot;
            app:layout_scrollFlags=&quot;scroll|enterAlwaysCollapsed|enterAlways&quot;&gt;

            &lt;ImageView
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;match_parent&quot;
                android:id=&quot;@+id/image_view&quot;
                android:fitsSystemWindows=&quot;true&quot;
                android:scaleType=&quot;centerCrop&quot;
                android:scrollbarStyle=&quot;insideInset&quot;
                android:scrollbarAlwaysDrawVerticalTrack=&quot;true&quot; /&gt;

            &lt;android.support.v7.widget.Toolbar
                android:id=&quot;@+id/toolbar&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;?attr/actionBarSize&quot;
                app:layout_collapseMode=&quot;pin&quot;
                app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot;
                app:background=&quot;@color/colorPrimary&quot;/&gt;

        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;

    &lt;/android.support.design.widget.AppBarLayout&gt;

    &lt;android.support.v4.widget.SwipeRefreshLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;
        android:id=&quot;@+id/refreshLayout&quot;&gt;

        &lt;android.support.v4.widget.NestedScrollView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;
            android:id=&quot;@+id/scrollView&quot;
            android:scrollbars=&quot;vertical&quot;
            android:scrollbarFadeDuration=&quot;1&quot;
            android:fadeScrollbars=&quot;true&quot;&gt;

            &lt;WebView
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;match_parent&quot;
                android:id=&quot;@+id/web_view&quot; /&gt;

        &lt;/android.support.v4.widget.NestedScrollView&gt;

    &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre><p>将<code>ImageView</code>嵌入Toolbar中，然后搭配<code>CollapsingToolbarLayout</code>可收缩的ToolbarLayout，实现收缩和展开效果。<code>SwipeRefreshLayout</code>仍然用于显示加载状态和刷新。然后就齐活了。</p>
<p>接着是Activity。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/detail/DetailActivity.java" target="_blank" rel="external">DetailActivity.java</a></p>
<pre><code class="java">public class DetailActivity extends AppCompatActivity {

    private DetailFragment fragment;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.frame);

        if (savedInstanceState != null) {
            fragment = (DetailFragment) getSupportFragmentManager().getFragment(savedInstanceState,&quot;detailFragment&quot;);
        } else {
            fragment = new DetailFragment();
            getSupportFragmentManager().beginTransaction()
                    .replace(R.id.container, fragment)
                    .commit();
        }

        Intent intent = getIntent();

        DetailPresenter presenter = new DetailPresenter(DetailActivity.this, fragment);

        presenter.setType((BeanType) intent.getSerializableExtra(&quot;type&quot;));
        presenter.setId(intent.getIntExtra(&quot;id&quot;, 0));
        presenter.setTitle(intent.getStringExtra(&quot;title&quot;));
        presenter.setCoverUrl(intent.getStringExtra(&quot;coverUrl&quot;));

    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        if (fragment.isAdded()) {
            getSupportFragmentManager().putFragment(outState, &quot;detailFragment&quot;, fragment);
        }
    }
}
</code></pre>
<p>内容与首页类似，相信你能理解，也是通过Activity + Fragment搭配的方式进行的。那么，View层也就是Fragment需要完成那些功能呢？我们可以直接在契约类中定义好。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/detail/DetailContract.java" target="_blank" rel="external">DetailContract.java</a></p>
<pre><code class="java">public class DetailContract {

    interface View extends BaseView&lt;Presenter&gt; {

        // 显示正在加载
        void showLoading();
        // 停止加载
        void stopLoading();
        // 显示加载错误
        void showLoadingError();
        // 显示分享时错误
        void showSharingError();
        // 正确获取数据后显示内容
        void showResult(String result);
        // 对于body字段的消息，直接接在url的内容
        void showResultWithoutBody(String url);
        // 设置顶部大图
        void showCover(String url);
        // 设置标题
        void setTitle(String title);
        // 设置是否显示图片
        void setImageMode(boolean showImage);
        // 用户选择在浏览器中打开时，如果没有安装浏览器，显示没有找到浏览器错误
        void showBrowserNotFoundError();
        // 显示已复制文字内容
        void showTextCopied();
        // 显示文字复制失败
        void showCopyTextError();
        // 显示已添加至收藏夹
        void showAddedToBookmarks();
        // 显示已从收藏夹中移除
        void showDeletedFromBookmarks();

    }

    interface Presenter extends BasePresenter{

        // 在浏览器中打开
        void openInBrowser();
        // 作为文字分享
        void shareAsText();
        // 打开文章中的链接
        void openUrl(WebView webView, String url);
        // 复制文字内容
        void copyText();
        // 复制文章链接
        void copyLink();
        // 添加至收藏夹或者从收藏夹中删除
        void addToOrDeleteFromBookmarks();
        // 查询是否已经被收藏了
        boolean queryIfIsBookmarked();
        // 请求数据
        void requestData();

    }

}
</code></pre>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/detail/DetailFragment.java" target="_blank" rel="external">DetailFragment.java</a></p>
<pre><code class="java">public class DetailFragment extends Fragment
        implements DetailContract.View {

    public DetailFragment() {}


    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
    }

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.universal_read_layout, container, false);

        initViews(view);

        setHasOptionsMenu(true);

        return view;
    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.menu_more, menu);
        super.onCreateOptionsMenu(menu, inflater);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        int id = item.getItemId();
        if (id == android.R.id.home) {
            getActivity().onBackPressed();
        } else if (id == R.id.action_more) {

        }
        return true;
    }

    @Override
    public void showLoading() {

    }

    @Override
    public void stopLoading() {

    }

    @Override
    public void showLoadingError() {

    }

    @Override
    public void showSharingError() {

    }

    @Override
    public void showResult(String result) {

    }

    @Override
    public void showResultWithoutBody(String url) {

    }

    @Override
    public void showCover(String url) {

    }

    @Override
    public void setTitle(String title) {

    }

    // WebView 提供了是否显示图片的方法
    @Override
    public void setImageMode(boolean showImage) {
        webView.getSettings().setBlockNetworkImage(showImage);
    }

    @Override
    public void showBrowserNotFoundError() {

    }

    @Override
    public void showTextCopied() {

    }

    @Override
    public void showCopyTextError() {

    }

    @Override
    public void showAddedToBookmarks() {

    }

    @Override
    public void showDeletedFromBookmarks() {

    }

    @Override
    public void setPresenter(DetailContract.Presenter presenter) {

    }

    @Override
    public void initViews(View view) {

    }

    // to change the title&#39;s font size of toolbar layout
    private void setCollapsingToolbarLayoutTitle(String title) {
        toolbarLayout.setTitle(title);
        toolbarLayout.setExpandedTitleTextAppearance(R.style.ExpandedAppBar);
        toolbarLayout.setCollapsedTitleTextAppearance(R.style.CollapsedAppBar);
        toolbarLayout.setExpandedTitleTextAppearance(R.style.ExpandedAppBarPlus1);
        toolbarLayout.setCollapsedTitleTextAppearance(R.style.CollapsedAppBarPlus1);
    }

}
</code></pre>
<h4 id="Day-5-实体类"><a href="#Day-5-实体类" class="headerlink" title="Day 5,实体类"></a>Day 5,实体类</h4><p>布局文件完成了，现在开始写实体类。方法和昨天写列表项实体类一样，可以手动编写，也可以用插件直接生成。直接放代码。</p>
<p>JSON格式数据:</p>
<pre><code class="json">{
  &quot;body&quot;: &quot;HTML格式内容&quot;,
  &quot;image_source&quot;: &quot;《那些年，我们一起追的女孩》&quot;,
  &quot;title&quot;: &quot;瞎扯 · 如何正确地吐槽&quot;,
  &quot;image&quot;: &quot;http://pic1.zhimg.com/13ee386166c53553ea6997d821609e0c.jpg&quot;,
  &quot;share_url&quot;: &quot;http://daily.zhihu.com/story/9195072&quot;,
  &quot;js&quot;: [],
  &quot;ga_prefix&quot;: &quot;020706&quot;,
  &quot;section&quot;: {
    &quot;thumbnail&quot;: &quot;http://pic2.zhimg.com/1dc9cf1556c7b0b1527c18476698c5cd.jpg&quot;,
    &quot;id&quot;: 2,
    &quot;name&quot;: &quot;瞎扯&quot;
  },
  &quot;images&quot;: [
    &quot;http://pic2.zhimg.com/1dc9cf1556c7b0b1527c18476698c5cd.jpg&quot;
  ],
  &quot;type&quot;: 0,
  &quot;id&quot;: 9195072,
  &quot;css&quot;: [
    &quot;http://news-at.zhihu.com/css/news_qa.auto.css?v=4b3e3&quot;
  ]
}
</code></pre>
<p>对应的实体类：<br><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/bean/ZhihuDailyStory.java" target="_blank" rel="external">ZhihuDailyStory.java</a></p>
<pre><code class="java">public class ZhihuDailyStory {

    private String body;
    private String image_source;
    private String title;
    private String image;
    private String share_url;
    private ArrayList&lt;String&gt; js;
    private String ga_prefix;
    private ArrayList&lt;String&gt; images;
    private int type;
    private int id;
    private ArrayList&lt;String&gt; css;

    public String getBody() {
        return body;
    }

    public void setBody(String body) {
        this.body = body;
    }

    public String getImage_source() {
        return image_source;
    }

    public void setImage_source(String image_source) {
        this.image_source = image_source;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getImage() {
        return image;
    }

    public void setImage(String image) {
        this.image = image;
    }

    public String getShare_url() {
        return share_url;
    }

    public void setShare_url(String share_url) {
        this.share_url = share_url;
    }

    public ArrayList&lt;String&gt; getJs() {
        return js;
    }

    public void setJs(ArrayList&lt;String&gt; js) {
        this.js = js;
    }

    public String getGa_prefix() {
        return ga_prefix;
    }

    public void setGa_prefix(String ga_prefix) {
        this.ga_prefix = ga_prefix;
    }

    public ArrayList&lt;String&gt; getImages() {
        return images;
    }

    public void setImages(ArrayList&lt;String&gt; images) {
        this.images = images;
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public ArrayList&lt;String&gt; getCss() {
        return css;
    }

    public void setCss(ArrayList&lt;String&gt; css) {
        this.css = css;
    }

}
</code></pre>
<h4 id="Day-5-显示数据"><a href="#Day-5-显示数据" class="headerlink" title="Day 5,显示数据"></a>Day 5,显示数据</h4><p>嘻嘻，首先当然是获取数据了☺️，需要考虑网络连接的情况，如果网络通畅，则直接从网络中获取，否则去数据库中获取。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/detail/DetailPresenter.java" target="_blank" rel="external">DetailPresenter.java</a></p>
<pre><code class="java">if (NetworkState.networkConnected(context)) {
    model.load(Api.ZHIHU_NEWS + id, new OnStringListener() {
        @Override
        public void onSuccess(String result) {
            {
                Gson gson = new Gson();
                try {
                    zhihuDailyStory = gson.fromJson(result, ZhihuDailyStory.class);
                    if (zhihuDailyStory.getBody() == null) {
                        view.showResultWithoutBody(zhihuDailyStory.getShare_url());
                    } else {
                        view.showResult(convertZhihuContent(zhihuDailyStory.getBody()));
                    }
                } catch (JsonSyntaxException e) {
                    view.showLoadingError();
                }
                view.stopLoading();
            }
        }

        @Override
        public void onError(VolleyError error) {
            view.stopLoading();
            view.showLoadingError();
        }
    });
} else {
    Cursor cursor = dbHelper.getReadableDatabase()
            .query(&quot;Zhihu&quot;, null, null, null, null, null, null);
    if (cursor.moveToFirst()) {
        do {
            if (cursor.getInt(cursor.getColumnIndex(&quot;zhihu_id&quot;)) == id) {
                String content = cursor.getString(cursor.getColumnIndex(&quot;zhihu_content&quot;));
                try {
                    zhihuDailyStory = gson.fromJson(content, ZhihuDailyStory.class);
                } catch (JsonSyntaxException e) {
                    view.showResult(content);
                }
                view.showResult(convertZhihuContent(zhihuDailyStory.getBody()));
            }
        } while (cursor.moveToNext());
    }
    cursor.close();
}

private String convertZhihuContent(String preResult) {

    preResult = preResult.replace(&quot;&lt;div class=\&quot;img-place-holder\&quot;&gt;&quot;, &quot;&quot;);
    preResult = preResult.replace(&quot;&lt;div class=\&quot;headline\&quot;&gt;&quot;, &quot;&quot;);

    // 在api中，css的地址是以一个数组的形式给出，这里需要设置
    // api中还有js的部分，这里不再解析js
    // 不再选择加载网络css，而是加载本地assets文件夹中的css
    String css = &quot;&lt;link rel=\&quot;stylesheet\&quot; href=\&quot;file:///android_asset/zhihu_daily.css\&quot; type=\&quot;text/css\&quot;&gt;&quot;;

    String theme = &quot;&lt;body className=\&quot;\&quot; onload=\&quot;onLoaded()\&quot;&gt;&quot;;

    return new StringBuilder()
            .append(&quot;&lt;!DOCTYPE html&gt;\n&quot;)
            .append(&quot;&lt;html lang=\&quot;en\&quot; xmlns=\&quot;http://www.w3.org/1999/xhtml\&quot;&gt;\n&quot;)
            .append(&quot;&lt;head&gt;\n&quot;)
            .append(&quot;\t&lt;meta charset=\&quot;utf-8\&quot; /&gt;&quot;)
            .append(css)
            .append(&quot;\n&lt;/head&gt;\n&quot;)
            .append(theme)
            .append(preResult)
            .append(&quot;&lt;/body&gt;&lt;/html&gt;&quot;).toString();
}
</code></pre>
<p>对获取的数据进行一下拼接，组成一个完整的HTML页面的内容。需要注意的是CSS文件，它负责整个HTML的样式，可以在<a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/assets/zhihu_daily.css" target="_blank" rel="external">这里</a>查看整个CSS文件的内容或下载CSS文件。</p>
<p>最后的显示就非常简单了：</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/detail/DetailFragment.java" target="_blank" rel="external">DetailFragment.java</a></p>
<pre><code class="java">@Override
public void showResult(String result) {
    webView.loadDataWithBaseURL(&quot;x-data://base&quot;,result,&quot;text/html&quot;,&quot;utf-8&quot;,null);
}
</code></pre>
<p>至此，最基本的显示详情内容的部分就已经完成了。实际上，我们还有很多的工作细微的工作没有完成，喝杯咖啡，休息一下，再回来继续吧。</p>
<h4 id="Day-5-设置与关于"><a href="#Day-5-设置与关于" class="headerlink" title="Day 5,设置与关于"></a>Day 5,设置与关于</h4><p>设置与关于也和首页及详情相同，采用的是Activity + Fragment搭配的形式。不过，这里的Fragment并不是我们前面所见到的<code>android.support.v4.app.Fragment</code>下的Fragment，而是<code>android.support.v7.preference.PreferenceFragmentCompat</code>。通过<br><code>PreferenceFragmentCompat</code>，我们可以很快的实现设置与关于页面。(由于二者的实现方法类似，我就以实现关于页面为例)</p>
<p>首先，我们需要在<code>res</code>目录下新建<code>xml</code>文件夹，新建<code>about_preference_fragment.xml</code>文件，作为设置和关于页面的布局文件。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/res/xml/about_preference_fragment.xml" target="_blank" rel="external">about_preference_fragment.xml</a></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.v7.preference.PreferenceScreen
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;android.support.v7.preference.PreferenceCategory android:title=&quot;@string/app_name&quot;&gt;

        &lt;android.support.v7.preference.Preference android:title=&quot;@string/version&quot; /&gt;

        &lt;android.support.v7.preference.Preference android:title=&quot;@string/rate&quot;
            android:key=&quot;rate&quot;
            android:summary=&quot;@string/rate_description&quot; /&gt;

    &lt;/android.support.v7.preference.PreferenceCategory&gt;

    &lt;android.support.v7.preference.PreferenceCategory android:title=&quot;@string/author&quot;&gt;

        &lt;android.support.v7.preference.Preference android:title=&quot;@string/author_name&quot;
            android:key=&quot;author&quot;
            android:summary=&quot;@string/author_description&quot;/&gt;

        &lt;android.support.v7.preference.Preference
            android:title=&quot;@string/follow_me_on_github&quot;
            android:key=&quot;follow_me_on_github&quot;
            android:summary=&quot;@string/github_url&quot;/&gt;

        &lt;android.support.v7.preference.Preference
            android:title=&quot;@string/follow_me_on_zhihu&quot;
            android:key=&quot;follow_me_on_zhihu&quot;
            android:summary=&quot;@string/zhihu_account&quot;/&gt;

    &lt;/android.support.v7.preference.PreferenceCategory&gt;

    &lt;android.support.v7.preference.PreferenceCategory android:title=&quot;@string/support&quot;&gt;

        &lt;android.support.v7.preference.Preference android:title=&quot;@string/feedback&quot;
            android:key=&quot;feedback&quot;
            android:summary=&quot;@string/feedback_description&quot;/&gt;

        &lt;android.support.v7.preference.Preference android:title=&quot;@string/coffee&quot;
            android:key=&quot;coffee&quot;
            android:summary=&quot;@string/coffee_description&quot;/&gt;

        &lt;android.support.v7.preference.Preference android:title=&quot;@string/open_source_license&quot;
            android:key=&quot;open_source_license&quot; /&gt;

    &lt;/android.support.v7.preference.PreferenceCategory&gt;

&lt;/android.support.v7.preference.PreferenceScreen&gt;
</code></pre><p>这样，布局文件就已经完成了。接下来是和首页等类似的，分别完成<code>Contract</code>,<code>Activity</code>,<code>Fragment</code>,<code>Presenter</code>。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/about/AboutContract.java" target="_blank" rel="external">AboutContract.java</a></p>
<pre><code class="java">public interface AboutContract {

    interface View extends BaseView&lt;Presenter&gt;{

        // 如果用户设备没有安装商店应用，提示此错误
        void showRateError();
        // 如果用户设备没有安装邮件应用，提示此错误
        void showFeedbackError();
        // 如果用户没有安装浏览器，提示此错误
        void showBrowserNotFoundError();

    }

    interface Presenter extends BasePresenter {
        // 在应用商店中评分
        void rate();
        // 展示开源许可页
        void openLicense();
        // 在GitHub上关注我
        void followOnGithub();
        // 在知乎上关注我
        void followOnZhihu();
        // 通过邮件反馈
        void feedback();
        // 捐赠
        void donate();
        // 显示小彩蛋
        void showEasterEgg();

    }

}
</code></pre>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/about/AboutPreferenceActivity.java" target="_blank" rel="external">AboutPreferenceActivity.java</a></p>
<pre><code class="java">public class AboutPreferenceActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_about);

        initViews();

        AboutPreferenceFragment fragment = new AboutPreferenceFragment();

        getSupportFragmentManager()
                .beginTransaction()
                .add(R.id.about_container,fragment)
                .commit();

        new AboutPresenter(AboutPreferenceActivity.this, fragment);

    }

    private void initViews() {
        setSupportActionBar((Toolbar) findViewById(R.id.toolbar));
        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == android.R.id.home){
            onBackPressed();
        }
        return super.onOptionsItemSelected(item);
    }

}
</code></pre>
<p>是不是有种似曾相识的感觉呢😉？</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/about/AboutPreferenceFragment.java" target="_blank" rel="external">AboutPreferenceFragment.java</a></p>
<pre><code class="java">public class AboutPreferenceFragment extends PreferenceFragmentCompat
        implements AboutContract.View {

    private Toolbar toolbar;
    private AboutContract.Presenter presenter;

    public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {

        addPreferencesFromResource(R.xml.about_preference_fragment);

        initViews(getView());

        findPreference(&quot;rate&quot;).setOnPreferenceClickListener(new android.support.v7.preference.Preference.OnPreferenceClickListener() {
            @Override
            public boolean onPreferenceClick(android.support.v7.preference.Preference preference) {
                presenter.rate();
                return false;
            }
        });

        findPreference(&quot;open_source_license&quot;).setOnPreferenceClickListener(new android.support.v7.preference.Preference.OnPreferenceClickListener() {
            @Override
            public boolean onPreferenceClick(android.support.v7.preference.Preference preference) {
                return false;
            }
        });

        findPreference(&quot;follow_me_on_github&quot;).setOnPreferenceClickListener(new android.support.v7.preference.Preference.OnPreferenceClickListener() {
            @Override
            public boolean onPreferenceClick(android.support.v7.preference.Preference preference) {
                return false;
            }
        });

        findPreference(&quot;follow_me_on_zhihu&quot;).setOnPreferenceClickListener(new android.support.v7.preference.Preference.OnPreferenceClickListener() {
            @Override
            public boolean onPreferenceClick(android.support.v7.preference.Preference preference) {
                return false;
            }
        });

        findPreference(&quot;feedback&quot;).setOnPreferenceClickListener(new android.support.v7.preference.Preference.OnPreferenceClickListener() {
            @Override
            public boolean onPreferenceClick(android.support.v7.preference.Preference preference) {
                return false;
            }
        });

        findPreference(&quot;coffee&quot;).setOnPreferenceClickListener(new android.support.v7.preference.Preference.OnPreferenceClickListener() {
            @Override
            public boolean onPreferenceClick(android.support.v7.preference.Preference preference) {
                return false;
            }
        });

        findPreference(&quot;author&quot;).setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
            @Override
            public boolean onPreferenceClick(Preference preference) {
                return false;
            }
        });

    }

    @Override
    public void onResume() {
        super.onResume();
        presenter.start();
    }

    @Override
    public void setPresenter(AboutContract.Presenter presenter) {
        if (presenter != null){
            this.presenter = presenter;
        }
    }

    @Override
    public void initViews(View view) {

    }

    @Override
    public void showRateError() {

    }

    @Override
    public void showFeedbackError() {

    }

    @Override
    public void showBrowserNotFoundError() {

    }

}
</code></pre>
<p>不知道你主要到没有，这里有一些代码和我们常见的有所不同。例如，<code>onCreatePreferences</code>方法，<code>addPreferencesFromResource</code>方法等。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/about/AboutPresenter.java" target="_blank" rel="external">AboutPresenter.java</a></p>
<pre><code class="java">public class AboutPresenter implements AboutContract.Presenter {

    public AboutPresenter(AppCompatActivity activity, AboutContract.View view) {

    }

    @Override
    public void start() {

    }


    @Override
    public void rate() {
        try {
            Uri uri = Uri.parse(&quot;market://details?id=&quot; + activity.getPackageName());
            Intent intent = new Intent(Intent.ACTION_VIEW,uri);
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            activity.startActivity(intent);
        } catch (android.content.ActivityNotFoundException ex){
            view.showRateError();
        }

    }

    @Override
    public void openLicense() {
        activity.startActivity(new Intent(activity,OpenSourceLicenseActivity.class));
    }

   @Override
    public void followOnGithub() {
        if (sp.getBoolean(&quot;in_app_browser&quot;,true)){
            CustomTabActivityHelper.openCustomTab(
                    activity,
                    customTabsIntent.build(),
                    Uri.parse(activity.getString(R.string.github_url)),
                    new CustomFallback() {
                        @Override
                        public void openUri(Activity activity, Uri uri) {
                            super.openUri(activity, uri);
                        }
                    });
        } else {
            try{
                activity.startActivity(new Intent(Intent.ACTION_VIEW).setData(Uri.parse( activity.getString(R.string.github_url))));
            } catch (android.content.ActivityNotFoundException ex){
                view.showBrowserNotFoundError();
            }
        }
    }

    @Override
    public void followOnZhihu() {

    }

    @Override
    public void feedback() {
        try{
            Uri uri = Uri.parse(activity.getString(R.string.sendto));
            Intent intent = new Intent(Intent.ACTION_SENDTO,uri);
            intent.putExtra(Intent.EXTRA_SUBJECT, activity.getString(R.string.mail_topic));
            intent.putExtra(Intent.EXTRA_TEXT,
                    activity.getString(R.string.device_model) + Build.MODEL + &quot;\n&quot;
                            + activity.getString(R.string.sdk_version) + Build.VERSION.RELEASE + &quot;\n&quot;
                            + activity.getString(R.string.version));
            activity.startActivity(intent);
        }catch (android.content.ActivityNotFoundException ex){
            view.showFeedbackError();
        }
    }

    @Override
    public void donate() {

    }

    @Override
    public void showEasterEgg() {

    }

}
</code></pre>
<p>具体的实现逻辑我没有给出，你可以在源代码中找到。需要注意的一些小细节，例如，在反馈操作中，我们是通过调用邮件App实现的。如下:</p>
<pre><code class="java">@Override
public void feedback() {
    try{
        Uri uri = Uri.parse(activity.getString(R.string.sendto));
        Intent intent = new Intent(Intent.ACTION_SENDTO,uri);
        intent.putExtra(Intent.EXTRA_SUBJECT, activity.getString(R.string.mail_topic));
        intent.putExtra(Intent.EXTRA_TEXT,
                activity.getString(R.string.device_model) + Build.MODEL + &quot;\n&quot;
                        + activity.getString(R.string.sdk_version) + Build.VERSION.RELEASE + &quot;\n&quot;
                        + activity.getString(R.string.version));
        activity.startActivity(intent);
    }catch (android.content.ActivityNotFoundException ex){
        view.showFeedbackError();
    }
}
</code></pre>
<p>为毛要做try…catch的操作呢？难道用户的设备上会连邮件App都没有安装吗？当然会。有的设备上甚至连浏览器都没有安装，所以，try…catch还是很有必要的。</p>
<p>需要提起的是，设置页面，我们需要对用户的偏好进行存储，然后在需要的地方获取这个值就好了，而PreferenceScreen本身就具有这样的功能，不再需要额外的SharedPreference去存储。在我的代码你可能会看到这样的情况，这是因为我并不是在项目的最初就引进了<code>PreferenceScreen</code>，当时就是直接用不同的控件搭配成的设置界面，用<code>SharedPreference</code>存储信息，后来引入了支持库之后，为了不破坏用户的体验(例如，某次版本升级直接导致之前的设置偏好全部失效)，坚持使用了这样一个‘多此一举’的方法。</p>
<p>至此，今天的工作就完成的差不多了，好好休息一下，工作最多的两天已经过去了。冬天过去了，春天还会远吗？在正式结束今天的工作之前，请先看一下 <strong>DAY 7</strong> 中 <strong>在Google Play上线</strong> 第一小节的内容，我们有一项任务需要完成–注册Google Play开发者账号，因为GP对开发者账号的审核48小时(实际体验不需要那么久，大概24小时左右，看人品罗)，所以，咱们先做好准备工作吧。</p>
<h3 id="DAY-6"><a href="#DAY-6" class="headerlink" title="DAY 6"></a>DAY 6</h3><p>终于来到了Day 6，还有一天就要完成此次教程了。加油！</p>
<h4 id="Day-6-文章收藏"><a href="#Day-6-文章收藏" class="headerlink" title="Day 6,文章收藏"></a>Day 6,文章收藏</h4><p>我们在之前设计数据库时，就在表中插入了一个<code>bookmark</code>字段，用于标示当前一行是否被收藏。我们先看看如何添加收藏和取消收藏。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/detail/DetailPresenter.java" target="_blank" rel="external">DetailPresenter.java</a></p>
<pre><code class="java">if (queryIfIsBookmarked()) {
    // delete
    // update Zhihu set bookmark = 0 where zhihu_id = id
    ContentValues values = new ContentValues();
    values.put(&quot;bookmark&quot;, 0);
    dbHelper.getWritableDatabase().update(tmpTable, values, tmpId + &quot; = ?&quot;, new String[]{String.valueOf(id)});
    values.clear();
} else {
    // add
    // update Zhihu set bookmark = 1 where zhihu_id = id
    ContentValues values = new ContentValues();
    values.put(&quot;bookmark&quot;, 1);
    dbHelper.getWritableDatabase().update(tmpTable, values, tmpId + &quot; = ?&quot;, new String[]{String.valueOf(id)});
    values.clear();
}
</code></pre>
<p>那么如果在收藏页面中展示出来呢？套路，仍然是之前的套路。还是熟悉的配方，还是原来的味道。</p>
<p>布局文件也就是简单的一个列表，代码和之前首页的代码相同，不再写出。</p>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/bookmarks/BookmarksContract.java" target="_blank" rel="external">BookmarksContract.java</a></p>
<pre><code class="java">public interface BookmarksContract {

    interface View extends BaseView&lt;Presenter&gt; {

        // 显示结果
        void showResults(ArrayList&lt;ZhihuDailyNews.Question&gt; zhihuList,
                         ArrayList&lt;GuokrHandpickNews.result&gt; guokrList,
                         ArrayList&lt;DoubanMomentNews.posts&gt; doubanList,
                         ArrayList&lt;Integer&gt; types);

        // 提示数据变化
        void notifyDataChanged();

        // 显示正在加载
        void showLoading();

        // 停止加载
        void stopLoading();

    }

    interface Presenter extends BasePresenter {

        // 请求结果
        void loadResults(boolean refresh);

        // 跳转到详情页面
        void startReading(BeanType type, int position);

        // 请求新数据
        void checkForFreshData();

        // 随便看看
        void feelLucky();

    }

}
</code></pre>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/bookmarks/BookmarksFragment.java" target="_blank" rel="external">BookmarksFragment.java</a></p>
<pre><code class="java">public class BookmarksFragment extends Fragment
        implements BookmarksContract.View {

    private RecyclerView recyclerView;
    private SwipeRefreshLayout refreshLayout;
    private BookmarksAdapter adapter;
    private BookmarksContract.Presenter presenter;

    public BookmarksFragment() {}

    public static BookmarksFragment newInstance() {
        return new BookmarksFragment();
    }

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
    }

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_list, container, false);

        initViews(view);

        setHasOptionsMenu(true);

        presenter.loadResults(false);

        refreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
            @Override
            public void onRefresh() {
                presenter.loadResults(true);
            }
        });

        return view;
    }

    @Override
    public void setPresenter(BookmarksContract.Presenter presenter) {
        if (presenter != null) {
            this.presenter = presenter;
        }
    }

    @Override
    public void initViews(View view) {

        recyclerView = (RecyclerView) view.findViewById(R.id.recyclerView);
        recyclerView.setLayoutManager(new LinearLayoutManager(getActivity()));

        refreshLayout = (SwipeRefreshLayout) view.findViewById(R.id.refreshLayout);
        refreshLayout.setColorSchemeResources(R.color.colorPrimary);

    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.menu_bookmarks, menu);
        super.onCreateOptionsMenu(menu, inflater);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        int id = item.getItemId();
        if (id == R.id.action_search) {
            startActivity(new Intent(getActivity(), SearchActivity.class));
        } else if (id == R.id.action_feel_lucky) {
            presenter.feelLucky();
        }
        return true;
    }

    @Override
    public void showResults(ArrayList&lt;ZhihuDailyNews.Question&gt; zhihuList,
                            ArrayList&lt;GuokrHandpickNews.result&gt; guokrList,
                            ArrayList&lt;DoubanMomentNews.posts&gt; doubanList,
                            ArrayList&lt;Integer&gt; types) {

        if (adapter == null) {

            adapter = new BookmarksAdapter(getActivity(), zhihuList, guokrList, doubanList, types);
            adapter.setItemListener(new OnRecyclerViewOnClickListener() {
                @Override
                public void OnItemClick(View v, int position) {
                    int type = recyclerView.findViewHolderForLayoutPosition(position).getItemViewType();
                    if (type == BookmarksAdapter.TYPE_ZHIHU_NORMAL) {
                        presenter.startReading(BeanType.TYPE_ZHIHU, position);
                    } else if (type == BookmarksAdapter.TYPE_GUOKR_NORMAL) {
                        presenter.startReading(BeanType.TYPE_GUOKR, position);
                    } else if (type == BookmarksAdapter.TYPE_DOUBAN_NORMAL) {
                        presenter.startReading(BeanType.TYPE_DOUBAN, position);
                    }
                }
            });
            recyclerView.setAdapter(adapter);
        } else {
            adapter.notifyDataSetChanged();
        }

    }

    @Override
    public void notifyDataChanged() {
        presenter.loadResults(true);
        adapter.notifyDataSetChanged();
    }

    @Override
    public void showLoading() {
        refreshLayout.setRefreshing(true);
    }

    @Override
    public void stopLoading() {
        refreshLayout.setRefreshing(false);
    }

}
</code></pre>
<p><a href="https://github.com/TonnyL/PaperPlane/blob/master/app/src/main/java/com/marktony/zhihudaily/bookmarks/BookmarksPresenter.java" target="_blank" rel="external">BookmarksPresenter.java</a></p>
<pre><code class="java">public class BookmarksPresenter implements BookmarksContract.Presenter {

    private BookmarksContract.View view;
    private Context context;
    private Gson gson;

    private ArrayList&lt;DoubanMomentNews.posts&gt; doubanList;
    private ArrayList&lt;GuokrHandpickNews.result&gt; guokrList;
    private ArrayList&lt;ZhihuDailyNews.Question&gt; zhihuList;

    private ArrayList&lt;Integer&gt; types;

    private DatabaseHelper dbHelper;
    private SQLiteDatabase db;

    public BookmarksPresenter(Context context, BookmarksContract.View view) {
        this.context = context;
        this.view = view;
        this.view.setPresenter(this);
        gson = new Gson();
        dbHelper = new DatabaseHelper(context, &quot;History.db&quot;, null, 5);
        db = dbHelper.getWritableDatabase();

        zhihuList = new ArrayList&lt;&gt;();
        guokrList = new ArrayList&lt;&gt;();
        doubanList = new ArrayList&lt;&gt;();

        types = new ArrayList&lt;&gt;();

    }

    @Override
    public void start() {

    }

    @Override
    public void loadResults(boolean refresh) {

        if (!refresh) {
            view.showLoading();
        } else {
            zhihuList.clear();
            guokrList.clear();
            doubanList.clear();
            types.clear();
        }

        checkForFreshData();

        view.showResults(zhihuList, guokrList, doubanList, types);

        view.stopLoading();

    }

    @Override
    public void startReading(BeanType type, int position) {
        Intent intent = new Intent(context, DetailActivity.class);
        switch (type) {
            case TYPE_ZHIHU:
                ZhihuDailyNews.Question q = zhihuList.get(position - 1);
                intent.putExtra(&quot;type&quot;, BeanType.TYPE_ZHIHU);
                intent.putExtra(&quot;id&quot;,q.getId());
                intent.putExtra(&quot;title&quot;, q.getTitle());
                intent.putExtra(&quot;coverUrl&quot;, q.getImages().get(0));
                break;

            case TYPE_GUOKR:
                GuokrHandpickNews.result r = guokrList.get(position - zhihuList.size() - 2);
                intent.putExtra(&quot;type&quot;, BeanType.TYPE_GUOKR);
                intent.putExtra(&quot;id&quot;, r.getId());
                intent.putExtra(&quot;title&quot;, r.getTitle());
                intent.putExtra(&quot;coverUrl&quot;, r.getHeadline_img());
                break;
            case TYPE_DOUBAN:
                DoubanMomentNews.posts p = doubanList.get(position - zhihuList.size() - guokrList.size() - 3);
                intent.putExtra(&quot;type&quot;, BeanType.TYPE_DOUBAN);
                intent.putExtra(&quot;id&quot;, p.getId());
                intent.putExtra(&quot;title&quot;, p.getTitle());
                if (p.getThumbs().size() == 0){
                    intent.putExtra(&quot;coverUrl&quot;, &quot;&quot;);
                } else {
                    intent.putExtra(&quot;image&quot;, p.getThumbs().get(0).getMedium().getUrl());
                }
                break;
            default:
                break;
        }
        context.startActivity(intent);
    }

    @Override
    public void checkForFreshData() {

        // every first one of the 3 lists is with header
        // add them in advance

        types.add(TYPE_ZHIHU_WITH_HEADER);
        Cursor cursor = db.rawQuery(&quot;select * from Zhihu where bookmark = ?&quot;, new String[]{&quot;1&quot;});
        if (cursor.moveToFirst()) {
            do {
                ZhihuDailyNews.Question question = gson.fromJson(cursor.getString(cursor.getColumnIndex(&quot;zhihu_news&quot;)), ZhihuDailyNews.Question.class);
                zhihuList.add(question);
                types.add(TYPE_ZHIHU_NORMAL);
            } while (cursor.moveToNext());
        }

        types.add(TYPE_GUOKR_WITH_HEADER);
        cursor = db.rawQuery(&quot;select * from Guokr where bookmark = ?&quot;, new String[]{&quot;1&quot;});
        if (cursor.moveToFirst()) {
            do {
                GuokrHandpickNews.result result = gson.fromJson(cursor.getString(cursor.getColumnIndex(&quot;guokr_news&quot;)), GuokrHandpickNews.result.class);
                guokrList.add(result);
                types.add(TYPE_GUOKR_NORMAL);
            } while (cursor.moveToNext());
        }

        types.add(TYPE_DOUBAN_WITH_HEADER);
        cursor = db.rawQuery(&quot;select * from Douban where bookmark = ?&quot;, new String[]{&quot;1&quot;});
        if (cursor.moveToFirst()) {
            do {
                DoubanMomentNews.posts post = gson.fromJson(cursor.getString(cursor.getColumnIndex(&quot;douban_news&quot;)), DoubanMomentNews.posts.class);
                doubanList.add(post);
                types.add(TYPE_DOUBAN_NORMAL);
            } while (cursor.moveToNext());
        }

        cursor.close();

    }

    @Override
    public void feelLucky() {
        Random random = new Random();
        int p = random.nextInt(types.size());
        while (true) {
            if (types.get(p) == BookmarksAdapter.TYPE_ZHIHU_NORMAL) {
                startReading(BeanType.TYPE_ZHIHU, p);
                break;
            } else if (types.get(p) == BookmarksAdapter.TYPE_GUOKR_NORMAL) {
                startReading(BeanType.TYPE_GUOKR, p);
                break;
            } else if (types.get(p) == BookmarksAdapter.TYPE_DOUBAN_NORMAL) {
                startReading(BeanType.TYPE_DOUBAN, p);
                break;
            } else {
                p = random.nextInt(types.size());
            }
        }
    }

}
</code></pre>
<p>🤔，用户可以从收藏列表页面查看内容详情，可能在这里，用户取消了收藏，而我们就需要及时地刷新界面数据，否则就会影响用户的体验。</p>
<h4 id="Day-6-夜间模式"><a href="#Day-6-夜间模式" class="headerlink" title="Day 6,夜间模式"></a>Day 6,夜间模式</h4><p>关于夜间模式的实现，请查看文章<a href="https://TonnyL.github.io/2016/12/31/%E7%AE%80%E6%B4%81%E4%BC%98%E9%9B%85%E5%9C%B0%E5%AE%9E%E7%8E%B0%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F/">简洁优雅地实现夜间模式</a>或者<a href="http://www.jianshu.com/p/dcfcfcbda7ac" target="_blank" rel="external">这里</a>。</p>
<h4 id="Day-6-版本适配"><a href="#Day-6-版本适配" class="headerlink" title="Day 6,版本适配"></a>Day 6,版本适配</h4><p>事实上，版本适配的范围非常的广泛。例如，多语言适配，高低Android版本的适配，还有对多屏幕的适配，特殊用户的适配等等。</p>
<ol>
<li><p>多语言适配</p>
<p> 在<code>res</code>目录下新建不同的<code>values</code>目录，例如，需要适配英语就新建<code>values-en</code>目录，简体中文<code>values-zh-rCN</code>，繁体中文(台湾)<code>values-zh-rTW</code>，繁体中文(香港)<code>values-zh-rHK</code>，等等。(这些代码不区分大小写；r 前缀用于区分区域码。 不能单独指定区域。)</p>
<pre><code> .
 ├── app
 ├──├── res
 ├──  ── ├── values
 ├──  ──  ── ├── strings.xml
 ├──  ── ├── values-en
 ├──  ──  ── ├── strings.xml
 ├──  ── ├── values-zh-rCN
 ├──  ──  ── ├── strings.xml
 ├──  ── ├── values-zh-rHK
 ├──  ──  ── ├── strings.xml
</code></pre><p> <img src="http://upload-images.jianshu.io/upload_images/2440049-ce4abc2ef966df77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Multi-language"></p>
<p> 更多内容请点击<a href="https://developer.android.com/training/basics/supporting-devices/languages.html" target="_blank" rel="external">这里</a>。</p>
</li>
<li><p>高低Android版本适配</p>
<p> 关于Android碎片化的讨论已经非常多了，这里我就不再鞭尸了。只简单的举两个例子。在Android 4.1 Jelly Bean系统的华为手机上，系统的DatePicker的样式是这样的。</p>
<p> <img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fcity9flprj30dc0nqmxv.jpg" alt="JellyBean"></p>
<p> 很明显，这和我们Material Design的设计语言很违和，使用开源库<code>materialdatetimepicker</code>就可以在这样的低版本的设备上实现MD版本的Date Picker Dialog。实现UI的统一对提升用户体验还是很有帮助的。</p>
<p> 对于高版本，例如Android 7.x Nougat，有很多的新特性，例如新的通知栏，Shortcuts等等，可以参考我的另外一篇文章<a href="http://www.jianshu.com/p/f56f2e709ad8" target="_blank" rel="external">老司机带你吃牛轧糖–适配Android 7.1 Nougat新特性</a>，虽然用上最新系统的用户量可能不大，但是当这些用户看到我们的应用适配了这些新特性时，应该也会感觉到眼前一亮吧，起到了锦上添花的作用。</p>
</li>
<li><p>支持多种屏幕</p>
<p> 和多语言适配类似，我们也可以通过提供不同资源文件的方式实现适配。例如，以下应用资源目录 为不同屏幕尺寸和不同可绘制对象提供不同的布局设计。使用 mipmap/ 文件夹放置 启动器图标。</p>
<pre><code> res/layout/my_layout.xml              // layout for normal screen size (&quot;default&quot;)
 res/layout-large/my_layout.xml        // layout for large screen size
 res/layout-xlarge/my_layout.xml       // layout for extra-large screen size
 res/layout-xlarge-land/my_layout.xml  // layout for extra-large in landscape orientation

 res/drawable-mdpi/graphic.png         // bitmap for medium-density
 res/drawable-hdpi/graphic.png         // bitmap for high-density
 res/drawable-xhdpi/graphic.png        // bitmap for extra-high-density
 res/drawable-xxhdpi/graphic.png       // bitmap for extra-extra-high-density

 res/mipmap-mdpi/my_icon.png         // launcher icon for medium-density
 res/mipmap-hdpi/my_icon.png         // launcher icon for high-density
 res/mipmap-xhdpi/my_icon.png        // launcher icon for extra-high-density
 res/mipmap-xxhdpi/my_icon.png       // launcher icon for extra-extra-high-density
 res/mipmap-xxxhdpi/my_icon.png      // launcher icon for extra-extra-extra-high-density
</code></pre><p> 更多内容请点击<a href="https://developer.android.com/guide/practices/screens_support.html" target="_blank" rel="external">这里</a>。</p>
</li>
<li><p>其他适配</p>
<p>例如，<a href="http://www.jianshu.com/p/f952d9c71d91" target="_blank" rel="external">提升体验-支持Chrome Custom Tabs</a>。</p>
</li>
</ol>
<p>哈，做完今天的工作，编码的工作就完成的差不多了。好好的睡一觉，准备明天的工作。</p>
<h3 id="DAY-7"><a href="#DAY-7" class="headerlink" title="DAY 7"></a>DAY 7</h3><h4 id="Day-7-在Google-Play上线"><a href="#Day-7-在Google-Play上线" class="headerlink" title="Day 7,在Google Play上线"></a>Day 7,在Google Play上线</h4><ol>
<li><p>注册Google Play开发者账号</p>
<p> 工具准备：</p>
<ul>
<li>科学上网，你懂的</li>
<li>Chrome浏览器或Firefox浏览器</li>
<li>$25，25刀的注册费用</li>
<li><p>支持国际支付功能(VISA, Master等)的信用卡，便于支付25刀的注册费</p>
<p>好了，我们现在开始正式的搞事情。</p>
</li>
</ul>
<ol>
<li><p>注册Google账号</p>
<p> 如果你已经有了Google账号，就直接跳过这一小步吧。</p>
<p> 我们先去 <a href="https://accounts.google.com/SignUp" target="_blank" rel="external">https://accounts.google.com/SignUp</a> 注册账号。按照自身的信息填写即可。<br> <img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fcixwzqtxcj31hv23eqi8.jpg" alt="创建您的 Google 帐号"></p>
</li>
<li><p>登录开发者后台</p>
<p> 登录 <a href="https://play.google.com/apps/publish/signup/" target="_blank" rel="external">https://play.google.com/apps/publish/signup/</a> 。<br> <img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fciycauuj7j31kw106drh.jpg" alt="Google Play Console"></p>
<p> 勾选同意并点击继续付款。需要注意的是，我们要先进到付款页面，然后再绑定Google Wallet。否则的话，就不能保证付款成功了。</p>
</li>
<li><p>付款</p>
<p> 点击添加新的付款方式，一路按提示输入即可(由于我之前已经注册过了，这里盗用一下被人的图，原作者请不要打我😂)。<br> <img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fciyt3vjxuj310i0nhgnd.jpg" alt="Payment"><br> <img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fciytuwh7wj310i0nhwg8.jpg" alt="Payment"></p>
<p> 如果绑定成功，Google可能会先从信用卡中扣除$1进行授权。</p>
</li>
<li><p>审核</p>
<p> Google最多需要48小时进行审核。我们可以通过<a href="https://wallet.google.com/" target="_blank" rel="external">Google Wallet</a>查看该订单的支付状态。如果显示<code>已完成</code>，就说明GP账号申请成功了。</p>
</li>
<li><p>没有信用卡怎么办？</p>
<p> 相信有很多像我一样的学生党，没有信用卡或者信用卡不支持国际支付功能，该怎么解决呢？这个时候，就是万能的某宝发挥作用的时候了。有一种信用卡叫做<code>虚拟信用卡</code>，我们可以通过向虚拟信用卡充值，然后用这样的卡去支付那25刀。具体的地址等咨询店小二即可。如果你觉得这样的方法太繁琐，或者我有钱任性，那么直接在马爸爸的网站上直接买一个开发者账号吧，不过一般情况下，费用肯定是高于25美刀的，而且安全性也值得检验(如果你打算买账号，那么务必在拿到账号之后第一时间修改密码和认证信息等等)。</p>
<p>通过上面的步骤，我们申请到的账号还只能发布免费的应用。如果对应用进行收费，你可以查看控制台中<code>财务报表</code>，获取更多商家账户的信息。</p>
<p>更多信息，请点击<a href="https://support.google.com/googleplay/android-developer/answer/6112435?hl=zh-Hans" target="_blank" rel="external">这里</a>。</p>
</li>
</ol>
</li>
<li><p>有了账号，我们就需要生成APK文件了。</p>
<p> 在保证项目正确运行的情况下(记得更换应用图标)，我们点击菜单项中的<code>Build</code> –&gt; <code>Generate Signed APK...</code>，对APK进行签名。</p>
<p> <img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fcizu57nbqj30k40iygq3.jpg" alt="Generate Signed APK..."></p>
<p> 选择生成APK的Module。</p>
<p> <img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fcizxsepj2j30uo0mqwh6.jpg" alt="app"></p>
<p> 这时候需要我们选择key，用于对APK签名。</p>
<p> <img src="https://ww1.sinaimg.cn/large/006tKfTcgy1fcizygdo80j30uo0mqgoz.jpg" alt="key"></p>
<p> Key的作用是为了保证每个应用程序开发商合法ID，防止部分开放商可能通过使用相同的Package Name来混淆替换已经安装的程序，我们需要对我们发布的APK文件进行唯一签名，保证我们每次发布的版本的一致性(如自动更新不会因为版本不一致而无法安装)。</p>
<p> 如果没有Key，我们就需要创建一个。选择<code>Create new...</code>创建。</p>
<p> <img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fcj095fzroj30ze0vqdl0.jpg" alt="Create new key"></p>
<p> 各种信息对应如下：</p>
<p> 名称 | 描述<br> — | —<br> Key store path | key的存储路径<br> Password | key的密码<br> Confirm | 确认密码<br> Alias | 别名<br> Validity(years) | 有效期限(年)<br> First and Last Name | 姓名<br> Organizational Unit | 组织单位<br> Organization | 组织<br> City of Location | 所在城市<br> State or Province | 省<br> Country Code(XX) | 国家代码</p>
<p> 填写完信息后，点击OK生成。这里生成的key一定要妥善保管，以后我们对应用进行版本更新时，需要用到。</p>
<p> 新建成功后，我们选择刚刚生成的key，输入密码，点击<code>Next</code> –&gt; <code>Finish</code>。</p>
<p> <img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fcj0nfxqiaj30uo0mqtcd.jpg" alt="Next"></p>
<p> <img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fcj0o691u1j30uo0mqadm.jpg" alt="Finish"></p>
</li>
<li><p>上传应用</p>
<p> 现在我们就可以把应用上传到Google Play了。</p>
<p> 3.1. 添加APK</p>
<ul>
<li><p>3.1.1. 转到 <a href="https://play.google.com/apps/publish/" target="_blank" rel="external">Google Play Developer Console</a>。</p>
</li>
<li><p>3.1.2. 依次选择<code>所有应用</code> –&gt; <code>+ 创建应用</code>。</p>
<p>  <img src="https://ww1.sinaimg.cn/large/006tKfTcgy1fcj10u1etcj31kw08y40b.jpg" alt="Google Play Console"></p>
</li>
<li><p>3.1.3 使用下拉菜单选择默认语言，并为您的应用添加标题。输入您想要在 Google Play 中显示的应用名称。</p>
<p>  <img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fcj1bo68lpj31kw106aj8.jpg" alt="Create new app"></p>
</li>
<li><p>3.1.4 选择上传 APK。</p>
<p>  <img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fcj1k3x3yuj31kw10648b.jpg" alt=""></p>
<p>3.2. 设置商品详情</p>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fcj1h9a33lj31kw106k1i.jpg" alt=""></p>
<p>我们需要为我们的应用设置<code>商品详情</code>，<code>图片资源</code>，<code>语言和翻译</code>，<code>分类</code>，<code>详细联系信息</code>，<code>隐私权政策</code>，等。对于程序员来说，最困难的应该就是各种图片了吧，在没有设计师的情况下，就让我们程序员发挥灵魂画师的功力吧，哈哈😆。</p>
<p>3.3. 后续步骤</p>
<p>我们还需要完成的步骤有：</p>
</li>
<li><p>填写应用的内容分级问卷</p>
</li>
<li>了解如何将应用发布到不同的国家/地区以及Android计划</li>
<li>使用标准或定时发布应用</li>
<li><p>通过实验优化商品详情</p>
<p>更多信息，请点击<a href="https://support.google.com/googleplay/android-developer/answer/113469?hl=zh-Hans" target="_blank" rel="external">这里</a>。</p>
<p>哈，到这里，应用上传就完成了，现在等待应用发布审核成功就好了。</p>
</li>
</ul>
</li>
</ol>
<h4 id="Day-7-在GitHub开源"><a href="#Day-7-在GitHub开源" class="headerlink" title="Day 7,在GitHub开源"></a>Day 7,在GitHub开源</h4><ol>
<li><p>注册GitHub</p>
<p> <a href="https://github.com" target="_blank" rel="external">GitHub</a>是一个 <del>同性交友社区</del> 面向开源及私有软件项目的托管平台，作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。</p>
<p> 我们先注册账号，地址为: <a href="https://github.com" target="_blank" rel="external">https://github.com</a> 。</p>
<p> <img src="https://ww4.sinaimg.cn/large/006y8lVagy1fcj2es7qjbj31kw106x6p.jpg" alt="GitHub"></p>
<p> 账号注册成功后，进入 <del>GayHub</del> GitHub 个人信息页，大概是这个样子的。</p>
<p> <img src="https://ww1.sinaimg.cn/large/006y8lVagy1fcj2kj9rahj31kw106gxt.jpg" alt="MyGitHub"></p>
<p> 第一步的工作就完成了。</p>
</li>
<li><p>安装Git</p>
<p> <a href="https://git-scm.com/" target="_blank" rel="external">Git</a>是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。官网的介绍是这样的：</p>
<blockquote>
<p>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p>
</blockquote>
<p> 下载Git，地址为 <a href="https://git-scm.com/downloads" target="_blank" rel="external">https://git-scm.com/downloads</a> ，下载对应版本即可。</p>
<ul>
<li>在macOS上，在 Mac 上安装 Git 有多种方式。<ul>
<li>最简单的方法是安装 Xcode Command Line Tools。 Mavericks （10.9） 或更高版本的系统中，在 Terminal 里尝试首次运行 git 命令即可。 如果没有安装过命令行开发者工具，将会提示你安装。</li>
<li>如果你想安装更新的版本，可以使用二进制安装程序。 官方维护的 OSX Git 安装程序可以在 Git 官方网站下载，网址为 <a href="http://git-scm.com/download/mac。" target="_blank" rel="external">http://git-scm.com/download/mac。</a></li>
</ul>
</li>
<li><p>在Windows上，在 Windows 上安装 Git 也有几种安装方法。</p>
<ul>
<li><p>官方版本可以在 Git 官方网站下载。 打开 <a href="http://git-scm.com/download/win，下载会自动开始。" target="_blank" rel="external">http://git-scm.com/download/win，下载会自动开始。</a> 要注意这是一个名为 Git for Windows的项目（也叫做 msysGit），和 Git 是分别独立的项目；更多信息请访问 <a href="http://msysgit.github.io/。" target="_blank" rel="external">http://msysgit.github.io/。</a></p>
</li>
<li><p>另一个简单的方法是安装 GitHub for Windows。 该安装程序包含图形化和命令行版本的 Git。 它也能支持 Powershell，提供了稳定的凭证缓存和健全的 CRLF 设置。 稍后我们会对这方面有更多了解，现在只要一句话就够了，这些都是你所需要的。 你可以在 GitHub for Windows 网站下载，网址为 <a href="http://windows.github.com。" target="_blank" rel="external">http://windows.github.com。</a></p>
</li>
</ul>
</li>
<li><p>在Linux上，我们可以通过下面的方法安装。</p>
<p>   如果你想在 Linux 上用二进制安装程序来安装 Git，可以使用发行版包含的基础软件包管理工具来安装。</p>
<ul>
<li><p>如果以 Fedora 上为例，你可以使用 yum:</p>
<pre><code>  $ sudo yum install git
</code></pre><ul>
<li><p>如果你在基于 Debian 的发行版上，请尝试用 apt-get：</p>
<pre><code>$ sudo apt-get install git
</code></pre></li>
</ul>
<p>要了解更多选择，Git 官方网站上有在各种 Unix 风格的系统上安装步骤，网址为 <a href="http://git-scm.com/download/linux。" target="_blank" rel="external">http://git-scm.com/download/linux。</a></p>
</li>
</ul>
<p>更多信息，请点击<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" target="_blank" rel="external">这里</a>。</p>
<p>OK，我们可以测试一下Git是否安装成功。在命令行中输入命令<code>git --version</code>查看git 的版本信息：</p>
<p><img src="https://ww4.sinaimg.cn/large/006y8lVagy1fcj3gn7ux4j312q0qk77y.jpg" alt="Git Version"></p>
</li>
</ul>
</li>
<li><p>在Android Studio中配置Git和GitHub</p>
<ol>
<li><p>打开Android Stuido，进入<code>Android Studio</code> –&gt; <code>Preferences</code> –&gt; <code>Version Control</code> –&gt; <code>Git</code>，(Windows为<code>File</code> –&gt; <code>Settings</code> –&gt; <code>Version Control</code> –&gt; <code>Git</code>)，在<code>Path to Git executable</code>中定位到你的Git安装目录，然后点击Test，如果成功你将会看到下面的提示信息。</p>
<p> <img src="https://ww3.sinaimg.cn/large/006y8lVagy1fcj46ixzqmj31kw131ah9.jpg" alt="Init Git"></p>
<p> <img src="https://ww1.sinaimg.cn/large/006tNc79gy1fcj497m0pqj30oo0a4t9s.jpg" alt="Git test success"></p>
</li>
<li><p>然后在左侧设置项中选择GitHub，然后输入你刚刚注册好的GitHub账号信息，点击test，如果成功你将会看到下面的提示信息。</p>
<p> <img src="https://ww4.sinaimg.cn/large/006tNc79gy1fcj4gvunlbj31kw13144p.jpg" alt="Init GitHub"></p>
<p> <img src="https://ww1.sinaimg.cn/large/006tNc79gy1fcj4j85oz5j30oo0a474y.jpg" alt="GitHub test success"></p>
</li>
</ol>
</li>
<li><p>托管代码</p>
<ol>
<li><p>为当前工程创建一个实用且漂亮的<code>README.MD</code>文件吧。</p>
<p> 在项目根目录下新建一个<code>README.MD</code>文件，<code>MD</code>表示这是一份<code>Markdown</code>文件。</p>
<p> <img src="https://ww2.sinaimg.cn/large/006tNc79gy1fcj55v5oqlj30lw0ls413.jpg" alt="Add a readme file"></p>
<p> <code>README</code>文件作为说明文件，作用是让浏览者能够快速地了解项目。<br> 因此，我们在写作README时，应该包括以下几点：</p>
<ul>
<li>为什么会有这个项目，介绍项目开发的背景</li>
<li>项目的用途是什么，介绍项目所解决的问题</li>
<li>怎样使用该项目</li>
<li>项目的开发历程，版本变化(可选)</li>
<li>未来的开发计划(可选)</li>
<li>Q&amp;A(可选)</li>
<li>项目所使用的许可条款文件</li>
</ul>
<p>(我的建议是提供一份英文版的README.MD文档，让我们的项目不仅仅帮助同胞，也帮助歪果仁吧。)</p>
</li>
<li><p>将当前工程导入版本控制，创建Git仓库(可选)</p>
<p> <img src="https://ww1.sinaimg.cn/large/006tNc79gy1fcj4ql3vs3j30yi0okwmo.jpg" alt="Create Git Repository"></p>
</li>
<li><p>分享到GitHub上</p>
<p> <img src="https://ww3.sinaimg.cn/large/006tNc79gy1fcj5jifdx3j30y20q0n5l.jpg" alt="Share Project on GitHub"></p>
<p> <img src="https://ww2.sinaimg.cn/large/006tNc79gy1fcj5o47zsqj30tm0jcq60.jpg" alt="Share Project on GitHub"></p>
<p> 然后我们就可以在GitHub的网站上看到我们的项目了。下面是我的<a href="https://github.com/TonnyL/PaperPlane" target="_blank" rel="external">纸飞机</a>的项目主页。</p>
<p> <img src="https://ww2.sinaimg.cn/large/006tNc79gy1fcj5vq0sqaj31kw106qfk.jpg" alt="GitHub Repository"></p>
</li>
</ol>
</li>
</ol>
<h4 id="Day-7-Q-amp-A"><a href="#Day-7-Q-amp-A" class="headerlink" title="Day 7,Q&amp;A"></a>Day 7,Q&amp;A</h4><p>至此，项目完成，教程也接近尾声。泡杯咖啡，我们来聊聊代码之外的事情。</p>
<ul>
<li>Q: 为什么会有这篇文章？</li>
<li><p>A: 一方面是受到各种大牛的影响，迫切地想要为开源贡献自己的力量；另一方面，<a href="https://github.com/TonnyL/PaperPlane" target="_blank" rel="external">纸飞机</a>项目的维护时间已经接近一年，这篇文章也算是一个小小的总结；然后是希望通过我的文章，能够让后面的童鞋们少踩一些坑。</p>
</li>
<li><p>Q: 一周时间并没有完成项目，怎么办？</p>
</li>
<li><p>A: 项目的代码量还是很大的，而项目现在的代码也是我用MVP架构重构之后的。就我自己而言，理解MVP架构我就花了一段时间，而且，MVP较MVC，代码量本身也是增加的。没有完成的话，就多花点时间吧。(文章的标题似乎有点标题党的嫌疑呢)</p>
</li>
<li><p>Q: 版权问题？</p>
</li>
<li><p>A: 恩，上线未经版权所有方如知乎等的许可，我们的确是侵权了。所以，请务必知晓可能承担的后果。(貌似是挖了个坑呢😂)</p>
</li>
<li><p>Q: 为什么是Google Play，而不是几60应用商店，某度应用商店呢？</p>
</li>
<li><p>A: 瞧不上。(我不是针对在座的某一个应用商店，我是说在座的各个应用商店，除了Google Play，都是那啥)</p>
</li>
<li><p>Q: 我有问题需要探讨，怎么联系？</p>
</li>
<li><p>A:</p>
<ul>
<li>marktonymengyi#gmail.com</li>
<li><a href="https://www.zhihu.com/people/kirin-momo" target="_blank" rel="external">知乎</a></li>
<li><a href="http://weibo.com/5313690193/profile?topnav=1&amp;wvr=6" target="_blank" rel="external">微博</a></li>
<li><a href="https://github.com/TonnyL" target="_blank" rel="external">GitHub</a></li>
<li>我的个人博客地址:<a href="https://TonnyL.github.io/">https://TonnyL.github.io/</a></li>
</ul>
</li>
<li><p>Q: 最后有什么想说的？</p>
</li>
<li>A: 如果文章对你有帮助的话，请给文章点一个赞，或者给项目一个Star，土豪请随意打赏，集齐30块钱我想要买本关于Git的书😂。(如果有大牛有实习机会的话，请推荐一下我呀)(文笔不好，还请多包涵)</li>
</ul>
<p>感谢您的阅读~~~</p>
<p>本文由<a href="http://www.jianshu.com/u/49606f4d970f" target="_blank" rel="external">TonnyL</a>原创，转载请注明作者及出处。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用RenderScript实现高斯模糊(毛玻璃/磨砂)效果]]></title>
      <url>http://tonnyl.github.io/2017/01/12/%E4%BD%BF%E7%94%A8RenderScript%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83-%E7%A3%A8%E7%A0%82-%E6%95%88%E6%9E%9C/</url>
      <content type="html"><![CDATA[<p>搞事情，实现Instagram对话框背景模糊效果<br><a id="more"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>逛ins的时候，偶然发现，instagram的对话框设计的很有意思，如下图：</p>
<img src="/2017/01/12/使用RenderScript实现高斯模糊-毛玻璃-磨砂-效果/ins.jpeg" alt="instagram" title="instagram">
<p>它的dialog的背景竟然是毛玻璃效果的，在我看来真漂亮，恩，对话框和迪丽热巴都漂亮😂。看到这么好的效果，当然就要开始搞事情了，自己动手实现差不多的效果。最终的实现效果如下图：</p>
<img src="/2017/01/12/使用RenderScript实现高斯模糊-毛玻璃-磨砂-效果/demo.png" alt="效果" title="效果">
<img src="/2017/01/12/使用RenderScript实现高斯模糊-毛玻璃-磨砂-效果/demo1.jpeg" alt="手动调节" title="手动调节">
<p>分别实现了对话框背景的虚化和手动调节虚化程度。</p>
<h3 id="实现方法对比"><a href="#实现方法对比" class="headerlink" title="实现方法对比"></a>实现方法对比</h3><p>最开始想要实现毛玻璃效果时，我是一脸懵逼的，不知道如何下手。幸亏，有万能的Google。搜索之后发现常见的实现方法有4种，分别是：</p>
<ul>
<li>RenderScript</li>
<li>Java算法</li>
<li>NDK算法</li>
<li>openGL</li>
</ul>
<p>处理一整张图片这么大计算量的工作，openGL的性能最好，而用java实现肯定是最差的了。而RenderScript和NDK的性能相当，但是你懂得，NDK和openGL我无可奈何，综合考虑，RenderScript应该是最适合的。</p>
<p>但并不是说RenderScript就是完全没有问题的：</p>
<ol>
<li>模糊半径(radius)越大，性能要求越高，模糊半径不能超过25，所以并不能得到模糊度非常高的图片。</li>
<li>ScriptIntrinsicBlur在API 17时才被引入，如果需要在Android 4.2以下的设备上实现，就需要引入RenderScript Support Library，当然，安装包体积会相应的增大。</li>
</ol>
<h3 id="RenderScript实现"><a href="#RenderScript实现" class="headerlink" title="RenderScript实现"></a>RenderScript实现</h3><p>首先在<code>app</code>目录下<code>build.gradle</code>文件中添加如下代码：</p>
<pre><code>defaultConfig {
        applicationId &quot;io.github.marktony.gaussianblur&quot;
        minSdkVersion 19
        targetSdkVersion 25
        versionCode 1
        versionName &quot;1.0&quot;
        renderscriptTargetApi 19
        renderscriptSupportModeEnabled true
    }
</code></pre><p>RenderScriptIntrinsics提供了一些可以帮助我们快速实现各种图片处理的操作类，例如，<code>ScriptIntrinsicBlur</code>，可以简单高效实现    高斯模糊效果。</p>
<pre><code class="java">package io.github.marktony.gaussianblur;

import android.content.Context;
import android.graphics.Bitmap;
import android.support.annotation.IntRange;
import android.support.annotation.NonNull;
import android.support.v8.renderscript.Allocation;
import android.support.v8.renderscript.Element;
import android.support.v8.renderscript.RenderScript;
import android.support.v8.renderscript.ScriptIntrinsicBlur;

public class RenderScriptGaussianBlur {

    private RenderScript renderScript;

    public RenderScriptGaussianBlur(@NonNull Context context) {
        this.renderScript = RenderScript.create(context);
    }

    public Bitmap gaussianBlur(@IntRange(from = 1, to = 25) int radius, Bitmap original) {
        Allocation input = Allocation.createFromBitmap(renderScript, original);
        Allocation output = Allocation.createTyped(renderScript, input.getType());
        ScriptIntrinsicBlur scriptIntrinsicBlur = ScriptIntrinsicBlur.create(renderScript, Element.U8_4(renderScript));
        scriptIntrinsicBlur.setRadius(radius);
        scriptIntrinsicBlur.setInput(input);
        scriptIntrinsicBlur.forEach(output);
        output.copyTo(original);
        return original;
    }

}
</code></pre>
<p>然后就可以直接使用RenderScriptGaussianBlur，愉快地根据SeekBar的值，实现不同程度的模糊了。</p>
<pre><code class="java">package io.github.marktony.gaussianblur;

import android.content.DialogInterface;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.SeekBar;
import android.widget.TextView;

public class MainActivity extends AppCompatActivity {

    private ImageView imageView;
    private ImageView container;
    private LinearLayout layout;
    private TextView textViewProgress;
    private RenderScriptGaussianBlur blur;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        imageView = (ImageView) findViewById(R.id.imageView);
        container = (ImageView) findViewById(R.id.container);

        container.setVisibility(View.GONE);

        layout = (LinearLayout) findViewById(R.id.layout);

        layout.setVisibility(View.VISIBLE);

        SeekBar seekBar = (SeekBar) findViewById(R.id.seekBar);
        textViewProgress = (TextView) findViewById(R.id.textViewProgress);
        TextView textViewDialog = (TextView) findViewById(R.id.textViewDialog);
        blur = new RenderScriptGaussianBlur(MainActivity.this);

        seekBar.setMax(25);
        seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                textViewProgress.setText(String.valueOf(progress));
            }

            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {

            }

            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {
                int radius = seekBar.getProgress();
                if (radius &lt; 1) {
                    radius = 1;
                }
                Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.image);
                imageView.setImageBitmap(blur.gaussianBlur(radius, bitmap));
            }
        });

        textViewDialog.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {

                container.setVisibility(View.VISIBLE);

                layout.setDrawingCacheEnabled(true);
                layout.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_LOW);

                Bitmap bitmap = layout.getDrawingCache();

                container.setImageBitmap(blur.gaussianBlur(25, bitmap));

                layout.setVisibility(View.INVISIBLE);

                AlertDialog dialog = new AlertDialog.Builder(MainActivity.this).create();
                dialog.setTitle(&quot;Title&quot;);
                dialog.setMessage(&quot;Message&quot;);
                dialog.setButton(DialogInterface.BUTTON_POSITIVE, &quot;OK&quot;, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        dialog.dismiss();
                    }
                });
                dialog.setButton(DialogInterface.BUTTON_NEGATIVE, &quot;Cancel&quot;, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {

                    }
                });
                dialog.setOnCancelListener(new DialogInterface.OnCancelListener() {
                    @Override
                    public void onCancel(DialogInterface dialog) {

                    }
                });

                dialog.setOnCancelListener(new DialogInterface.OnCancelListener() {
                    @Override
                    public void onCancel(DialogInterface dialog) {
                        container.setVisibility(View.GONE);
                        layout.setVisibility(View.VISIBLE);
                    }
                });

                dialog.show();
            }
        });

    }
}
</code></pre>
<p>在代码里做了一些view的可见性的操作，比较简单，相信你能看懂的。和instagram中dialog的实现有一点不同的是，我没有截取整个页面的bitmap，只是截取了actionbar下的内容，如果一定要实现一样的效果，调整一下页面的布局就可以了。这里不多说了。</p>
<p>是不是很简单呢？</p>
<h3 id="轮子"><a href="#轮子" class="headerlink" title="轮子"></a>轮子</h3><p>除了RenderScript外，还有一些优秀的轮子：</p>
<ul>
<li><a href="https://github.com/500px/500px-android-blur" target="_blank" rel="external">500px-android-blur</a></li>
<li><a href="https://github.com/wasabeef/Blurry" target="_blank" rel="external">Blurry</a></li>
<li><a href="https://github.com/kikoso/android-stackblur" target="_blank" rel="external">android-stackblur</a></li>
<li><a href="https://github.com/paveldudka/blurring/blob/master/app/src/main/java/com/paveldudka/util/FastBlur.java" target="_blank" rel="external">FastBlur</a>:Java算法实现</li>
</ul>
<p><a href="https://github.com/patrickfav/BlurTestAndroid" target="_blank" rel="external">BlurTestAndroid</a>对不同类库的实现方式、采取的算法和所耗费的时间做了统计和比较，你也可以下载它的demo app，自行测试。</p>
<img src="/2017/01/12/使用RenderScript实现高斯模糊-毛玻璃-磨砂-效果/BlurTestAndroid.png" alt="BlurTestAndroid" title="BlurTestAndroid">
<p>示例代码在这里：<a href="https://github.com/TonnyL/GaussianBlur" target="_blank" rel="external">GaussianBlur</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的2016]]></title>
      <url>http://tonnyl.github.io/2017/01/10/%E6%88%91%E7%9A%842016/</url>
      <content type="html"><![CDATA[<p>开源，博客，数码，电影与电视剧。<br><a id="more"></a><br>时间走着走着，我读完了大三第一个学期，距离公元2016年也已经过去了10天，是时候对过去的一年做一个总结了。本来还想着1号的时候写这篇文章的，结果，正式应了那句话：</p>
<blockquote>
<p>在让自己失望这件事情上，我从没让自己失望过。</p>
</blockquote>
<p>一拖就拖到了10号才开始动笔，不对，动键盘，正式的对过去一年进行一个尽量完整的总结（以下所有的统计日期均为截止至2017年1月10日）。</p>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>说到项目就不得不说<a href="https://github.com/TonnyL" target="_blank" rel="external">GitHub</a>, 虽然在15年的时候注册了账号，但是基本上没有提交有价值的东西，真正开始用心的维护还是在16年。</p>
<img src="/2017/01/10/我的2016/github_contribution.png" alt="GitHub Contributions" title="GitHub Contributions">
<p>一共有422次contribution。</p>
<p>star比较多的项目:</p>
<img src="/2017/01/10/我的2016/github_pop_repos.png" alt="GitHub pop repos" title="GitHub pop repos">
<p>所有的项目一共收获535个star(从无到有)，被fork140次(从无到有)，follower96(从无到有)。</p>
<p>其中比较在我看来比较优秀的有：</p>
<ul>
<li><a href="https://github.com/TonnyL/PaperPlane" target="_blank" rel="external">纸飞机(知乎小报 PaperPlane)</a>,采用MVP架构，集合了知乎日报、果壳精选和豆瓣一刻的综合性阅读客户端，在<a href="https://play.google.com/store/apps/details?id=com.marktony.zhihudaily" target="_blank" rel="external">Google Play</a>上下载量为13354次，综合评分4.62（满分5）；<a href="http://app.mi.com/detail/312703?ref=search" target="_blank" rel="external">小米应用商店</a>下载量为12602次；<a href="http://app.flyme.cn/apps/public/detail?package_name=com.marktony.zhihudaily" target="_blank" rel="external">魅族应用商店</a>下载量为5208，综合评分9.6（满分为10）；<a href="http://www.coolapk.com/apk/com.marktony.zhihudaily" target="_blank" rel="external">酷市场</a>下载量为4.3万，综合评分4.5（满分为5）。</li>
</ul>
<img src="/2017/01/10/我的2016/paper_plane.png" alt="Paper Plane" title="Paper Plane">
<ul>
<li><a href="https://github.com/TonnyL/zhuanlan" target="_blank" rel="external">知乎专栏APP及API分析</a>，由于版权问题，APP已经停止维护，API分析部分可以查看<a href="https://github.com/TonnyL/zhuanlan/wiki" target="_blank" rel="external">wiki</a>或者<a href="https://TonnyL.github.io/2016/05/14/%E7%9F%A5%E4%B9%8E%E4%B8%93%E6%A0%8FAPI%E5%88%86%E6%9E%90/">我的博客</a></li>
<li><a href="https://github.com/TonnyL/FanfouHandpick" target="_blank" rel="external">饭否精选</a>,使用Kotlin开发的饭否精选客户端。这个项目主要是练手，尝鲜使用Kotlin，现阶段在项目中使用Kotlin的可能性还是蛮小的。</li>
<li><a href="https://github.com/TonnyL/Translator" target="_blank" rel="external">简单翻译</a></li>
<li><a href="https://github.com/TonnyL/Reader" target="_blank" rel="external">Reader</a>：内容包含了糗事百科，煎蛋，和内涵段子</li>
</ul>
<p>所有项目均由我自己完成设计，编码，测试，上线及迭代维护工作。</p>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><ul>
<li><a href="https://TonnyL.github.io">Tonny’s Blog</a>，使用GitHub Pages和Hexo搭建的博客，所有文章都首发于此，也是在16年中才搭建完成，之前一直使用的是<a href="https://github.com/A-limon/pacman" target="_blank" rel="external">Pacman</a>主题，年底前换了<a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="external">Material</a>主题，感觉美观了很多(谁让我是Google的粉丝呢)。一共完成了21篇文章。</li>
</ul>
<img src="/2017/01/10/我的2016/Tonny%27sBlog.png" alt="Tonny's Blog" title="Tonny's Blog">
<ul>
<li><p><a href="http://www.jianshu.com/u/49606f4d970f" target="_blank" rel="external">简书-TonnyL</a>:半年时间，一共写了10篇文章，17898个字，收获了195个喜欢，64个粉丝。</p>
</li>
<li><p><a href="https://gold.xitu.io/user/582c81cb128fe10069509b49" target="_blank" rel="external">稀土掘金-Tonny</a>:使用时间一个月，分享6篇文章，收获734个喜欢。</p>
</li>
</ul>
<h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><ul>
<li>电脑：啊哈哈哈哈，终于在今年十月份的时候，把原来的华硕A550卖了，买了现在的MBP，原来的华硕的真的太厚了，而且重，带着走太不方便了。第一次拿到MBP的时候，真的不由自主的感叹，原来生产力工具是可以这么薄的。当然，换电脑的代价就是吃了一个学期的土（手动微笑脸）。</li>
<li>键盘：阿米洛VA87M茶轴，大概5月份的时候，卖掉了之前RK68，没有方向键的键盘，用着太别扭。</li>
<li>手机：一加3。还在分期中。</li>
</ul>
<p>（求土豪不喷，我穷逼一个。）</p>
<h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>由于我不喜欢看电子书，所以书基本上都是看的纸质的书（买不起Kindle）。大概看了：</p>
<ul>
<li>第一行代码Android，入门必备，年末的时候又入手了第二版的，巩固基础还是很有必要的。</li>
<li>Android开发艺术探索，提升，还在研读。</li>
<li>Thinking in Java，巩固基础与提升都靠他，Java界的金坷垃。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>看了一些电影和电视剧。</p>
<ul>
<li>北京遇上西雅图之不二情书，虽然还是单身狗一个，还是和同学一起去看了这部电影，汤唯好帅！</li>
</ul>
<img src="/2017/01/10/我的2016/buerqingshu.jpg" alt="不二情书" title="不二情书">
<ul>
<li>驴得水，笑着笑着就哭的电影。</li>
</ul>
<img src="/2017/01/10/我的2016/lvdeshui.jpg" alt="驴得水" title="驴得水">
<ul>
<li>The Big Bang Theory S10,Shelton都和Amy在一起了，我还是没女朋友。</li>
</ul>
<img src="/2017/01/10/我的2016/tbbt.jpg" alt="生活大爆炸" title="生活大爆炸">
<ul>
<li>Westworld S1，HBO出品，必属精品。烧脑的电视剧，而且Deloris好漂亮啊。不过我觉得有点坑爹的，我喜欢的Halsey怎么说没就没了呢？不过好消息是，Halsey会在S2回归，这才稍微安慰了一下我受伤的心灵。</li>
</ul>
<img src="/2017/01/10/我的2016/westworld.jpg" alt="西部世界" title="西部世界">
<ul>
<li>请回答1988，暑假的时候才看完，我的评价是，神剧。真的神，感觉他们不是生活在双门洞，而是生活在我身边。代入感太强，还有各种神细节，各种不做作的煽情，感动地流泪。看完了副作用也挺明显的，那就是现在我逢人就安利这部剧（微笑脸）。</li>
</ul>
<img src="/2017/01/10/我的2016/qinghuida1988.jpg" alt="请回答1988" title="请回答1988">
<ul>
<li>辩护人，这不是16年出品的电影，但是真的对我的启发太大了。精品。</li>
</ul>
<img src="/2017/01/10/我的2016/bianhuren.jpg" alt="辩护人" title="辩护人">
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>革命尚未成功，同志仍需努力。</p>
</blockquote>
<h3 id="小目标"><a href="#小目标" class="headerlink" title="小目标"></a>小目标</h3><p>2017年，先给自己定一个小目标，比如，减肥5kg（微笑脸）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Lambda在Android中的使用]]></title>
      <url>http://tonnyl.github.io/2017/01/06/Lambda%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>极简主义。<br><a id="more"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android支持完整的Java7特性，而升级到Android Nougat(API Level 24)之后，支持了Java8语言的一部分功能：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" target="_blank" rel="external">默认和静态接口方法</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="external">Lambda表达式</a>(在 API 级别 23 及更低版本中也可用)</li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html" target="_blank" rel="external">重复注解</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="external">方法引用</a>(在 API 级别 23 及更低版本中也可用)</li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/annotations/type_annotations.html" target="_blank" rel="external">类型注解</a>(在 API 级别 23 及更低版本中也可用)</li>
</ul>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>使用这一部分支持的功能需要一个名为<a href="https://source.android.com/source/jack.html" target="_blank" rel="external">Jack</a>的新编译。而Jack要求Android Studio 2.1或更高，所以，没有升级到2.1或以上的童鞋，需要先升级才能支持使用Jack哟。</p>
<blockquote>
<p><a href="https://developer.android.com/tools/building/building-studio.html#instant-run" target="_blank" rel="external">Instant Run</a>目前不能应用于Jack</p>
</blockquote>
<p>在<code>app</code>目录下<code>build.gradle</code>文件下添加：</p>
<pre><code>android {
  ...
  defaultConfig {
    ...
    jackOptions {
      enabled true
    }
    // 在更老的版本中，使用
    // useJack true
    // 可以达到同样的效果
  }
  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
  }
}
</code></pre><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda的语法格式如下:</p>
<pre><code class="java">(arg1, arg2...) -&gt; { body }

(type1 arg1, type2 arg2...) -&gt; { body }
</code></pre>
<p>在未使用Lambda表达式之前，我们设置监听器的代码是这样的:</p>
<pre><code class="java">fab.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        // blah, blah
    }
});
</code></pre>
<p>而使用Lambda表达式，代码是这样的:</p>
<pre><code class="java">fab.setOnClickListener(v -&gt; {
    // blah, blah            
});
</code></pre>
<p>是不是更简洁了呢？</p>
<p>我们查看一下<code>OnClickListener</code>的源码，发现这个接口中只有一个待实现的方法。</p>
<pre><code class="java">/**
 * Interface definition for a callback to be invoked when a view is clicked.
 */
public interface OnClickListener {
    /**
     * Called when a view has been clicked.
     *
     * @param v The view that was clicked.
     */
    void onClick(View v);
}
</code></pre>
<p>像这种只有一个待实现方法的接口，都可以使用Lambda表达式进行简化。当然，我们也可以自定义接口，然后用Lambda表达式进行实现。</p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>有时会遇到这样的情况，Lambda表达式什么都没有做，仅仅是调用了已经存在的方法。这种情况下，代码就能进一步精简了。</p>
<pre><code>fab.setOnClickListener( view2 -&gt; showSnackBar(view2));

private void showSnackBar(View view) {
        Snackbar.make(view, &quot;blah, blah&quot;, Snackbar.LENGTH_SHORT).show();
}
</code></pre><p>使用方法引用之后：</p>
<pre><code>fab.setOnClickListener(this::showSnackBar);
</code></pre><h3 id="上下文推断"><a href="#上下文推断" class="headerlink" title="上下文推断"></a>上下文推断</h3><p>下面来实现一些例子来了解Lambda的上下文推断。</p>
<pre><code class="java">public interface TestOp {
   String operate (String s, int i);
}

// 使用Lambda表达式进行实现
// 通过上下文，lambda表达式可以推断出s为String类型，而i为int类型
// 返回值为String
TestOp myOp = (s,i) -&gt; s + i;
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Lambda表达式使用还是很方便的，能够减少编写和维护的代码数量。但是，这种极简主义的写法也并不是所有人都能接受的。对于我而言，技多不压身，学习一下，提高姿势还是挺有必要的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[提升体验-Chrome Custom Tabs]]></title>
      <url>http://tonnyl.github.io/2017/01/05/%E6%8F%90%E5%8D%87%E4%BD%93%E9%AA%8C-Chrome-Custom-Tabs/</url>
      <content type="html"><![CDATA[<p>使用Chrome Custom Tabs加载网页可以有效的提升用户的体验<br><a id="more"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>文章比较长，先放项目地址:<a href="https://github.com/TonnyL/PaperPlane" target="_blank" rel="external">PaperPlane</a></p>
<p>俗话说，没图说个那啥，先看实际效果。<br><img src="/2017/01/05/提升体验-Chrome-Custom-Tabs/telegram.gif" alt="telegram" title="telegram"><br><img src="/2017/01/05/提升体验-Chrome-Custom-Tabs/paper_plane.gif" alt="paper plane" title="paper plane"></p>
<h3 id="什么是Custom-Tabs"><a href="#什么是Custom-Tabs" class="headerlink" title="什么是Custom Tabs?"></a>什么是Custom Tabs?</h3><p>所有的APP开发者都面临这样一个选择，当用户点击一个URL时，是应该用浏览器打开还是应该用应用内置的WebView打开呢？</p>
<p>两个选项都面临着一些问题。通过浏览器打开是一个非常重的上下文切换，并且是无法定制的。而WebView不能和浏览器共享数据并且需要需要手动去处理更多的场景。</p>
<p>Chrome Custom Tabs让APP在进行网页浏览时更多的控制权限，在不采用WebView的情况下，这既能保证Native APP和网页之间流畅的切换，又允许APP定制Chrome的外观和操作。可定义的内容如下：</p>
<ul>
<li>toolbar的颜色</li>
<li>进场和退场动画</li>
<li>给Chrome的toolbar、overflow menu和bottom toolbar添加自定义操作</li>
</ul>
<p>并且，Chrome Custom Tabs允许开发者对Chrome进行预启动和网页内容的预加载，以此提升加载的速度。<br><img src="/2017/01/05/提升体验-Chrome-Custom-Tabs/performance.gif" alt="preformance" title="preformance"></p>
<h3 id="Chrome-Custom-Tabs-VS-WebView-我应该什么时候用？"><a href="#Chrome-Custom-Tabs-VS-WebView-我应该什么时候用？" class="headerlink" title="Chrome Custom Tabs VS WebView, 我应该什么时候用？"></a>Chrome Custom Tabs VS WebView, 我应该什么时候用？</h3><p>如果页面的内容是由我们自己控制的，可以和Android组件进行交互，那么,WebView是一个好的选择，如果我们的应用需要打开外部的网站，那么推荐使用Chrome Custom Tabs，原因如下：</p>
<ul>
<li>导入非常简单。不需要编写额外的代码来管理请求，授予权限或者存储cookie</li>
<li>定制UI：<ul>
<li>Toolbar 颜色</li>
<li>动作按钮 (Action Button)</li>
<li>定制菜单项</li>
<li>定制进场退场动画</li>
<li>Bottom Toolbar</li>
</ul>
</li>
<li>导航感知：浏览器通知回调接口通知应用网页的导航情况</li>
<li>安全性：浏览器使用了Google’s Safe Browsing，用于保护用户和设备免受危险网站的侵害</li>
<li>性能优化：<ul>
<li>浏览器会在后台进行预热，避免了应用占用大量资源的情况</li>
<li>提前向浏览器发送可能的URL，提高了页面加载速度</li>
</ul>
</li>
<li>生命周期管理：在用户与Custom Tabs进行交互时，浏览器会将应用标示为前台应用，避免了应用被系统所回收</li>
<li>共享cookie数据和权限，这样，用户在已经授权过的网站，就不需要重新登录或者授权权限了</li>
<li>如果用户开启了数据节省功能，在这里仍然可以从中受益</li>
<li>同步的自动补全功能</li>
<li>仅仅需要点击一下左上角按钮就可以直接返回原应用</li>
<li>想要在Lollipop之前的设备上最新引入的浏览器(Auto updating WebView),而不是旧版本的WebView</li>
</ul>
<h3 id="什么时候可用？"><a href="#什么时候可用？" class="headerlink" title="什么时候可用？"></a>什么时候可用？</h3><p>从Chrome 45版本开始，所有的Chrome用户都可以使用这项功能，目前仅支持Android系统。</p>
<h3 id="开发指南"><a href="#开发指南" class="headerlink" title="开发指南"></a>开发指南</h3><p>完整的示例可以查看<a href="https://github.com/GoogleChrome/custom-tabs-client" target="_blank" rel="external">https://github.com/GoogleChrome/custom-tabs-client</a>。包含了定制UI、连接后台服务、处理应用和Custom Tab Activity生命周期的可复用的类。</p>
<p>第一步当然是将<a href="http://developer.android.com/tools/support-library/features.html#custom-tabs" target="_blank" rel="external"> Custom Tabs Support Library </a>添加到工程中来。打开<code>build.gradle</code>文件，添加support library的依赖。</p>
<pre><code>dependencies {
    ...
    compile &#39;com.android.support:customtabs:23.3.0&#39;
}
</code></pre><p>一旦Support Library添加项目成功了，我们就有两种可能的定制操作了：</p>
<ul>
<li>定制UI和与Chrome Custom Tabs的交互</li>
<li>使页面加载更快速，保持应用激活</li>
</ul>
<p>UI的定制是通过使用<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsIntent.html" target="_blank" rel="external"> CustomTabsIntent </a>和<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsIntent.Builder.html" target="_blank" rel="external"> CustomTabsIntent.Builder</a>类完成的；而速度的提升则是通过使用<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html" target="_blank" rel="external"> CustomTabsClient </a>链接Custom Tabs服务，预热Chrome和让Chrome知晓将要打开的URL实现的。</p>
<h4 id="打开一个Chrome-Custom-Tab"><a href="#打开一个Chrome-Custom-Tab" class="headerlink" title="打开一个Chrome Custom Tab"></a>打开一个Chrome Custom Tab</h4><pre><code class="java">// 使用CustomTabsIntent.Builder配置CustomTabsIntent
// 准备完成后，调用CustomTabsIntent.Builder.build()方法创建一个CustomTabsIntent
// 并通过CustomTabsIntent.launchUrl()方法加载希望加载的url

String url = ¨https://github.com/TonnyL¨;
CustomTabsIntent.Builder builder = new CustomTabsIntent.Builder();
CustomTabsIntent customTabsIntent = builder.build();
customTabsIntent.launchUrl(this, Uri.parse(url));
</code></pre>
<h4 id="配置地址栏的颜色"><a href="#配置地址栏的颜色" class="headerlink" title="配置地址栏的颜色"></a>配置地址栏的颜色</h4><p>Chrome Custom Tabs一个很重要的功能就是我们能够改变地址栏的颜色，使之和我们应用的颜色协调。</p>
<pre><code class="java">// 改变toolbar的背景色。colorInt就是想要指定的int值

builder.setToolbarColor(colorInt);
</code></pre>
<h4 id="配置定制化的action-button"><a href="#配置定制化的action-button" class="headerlink" title="配置定制化的action button"></a>配置定制化的action button</h4><p>作为应用的开发者，我们对呈现在用户眼前的Chrome Custom Tab内的Action Button拥有完全的控制权。</p>
<p>在大部分的情况下，用户会执行最基础的操作像分享，或者是其他公共的Activity。</p>
<p>Action Button被表示为一个action button的图标和用户点击action button之后Chrome将要执行的pendingIntent。图标的高度一般为24dp，宽度一般为24-48dp。</p>
<img src="/2017/01/05/提升体验-Chrome-Custom-Tabs/tumblr_action.png" alt="actions" title="actions">
<pre><code class="java">// 向toolbar添加一个Action Button
// ‘icon’是一张位图(Bitmap)，作为action button的图片资源使用

// &#39;description&#39;是一个字符串，作为按钮的无障碍描述所使用

// &#39;pendingIntent&#39; 是一个PendingIntent，当action button或者菜单项被点击时调用。
// 在url作为data被添加之后，Chrome 会调用PendingIntent#send()方法。
// 客户端应用会通过调用Intent#getDataString()获取到URL

// &#39;tint&#39;是一个布尔值，定义了Action Button是否应该被着色

builder.setActionButton(icon, description, pendingIntent, tint);
</code></pre>
<h4 id="配置定制化菜单"><a href="#配置定制化菜单" class="headerlink" title="配置定制化菜单"></a>配置定制化菜单</h4><p>Chrome浏览器拥有非常全面的action菜单，用户在浏览器内操作非常顺畅。然而，对于我们自己的应用，可能就不适合了。</p>
<p>Chrome Custom Tabs顶部有三个横向排列的图标，分别是“前进”、”页面信息”和”刷新“。在菜单的底部分别是”查找页面”和“在浏览器中打开”。</p>
<p>作为开发者，我们最多可以在顶部横向图标和底部菜单之间添加5个自定义菜单选项。</p>
<p>菜单项通过调用<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsIntent.Builder.html#addMenuItem(java.lang.String, android.app.PendingIntent" target="_blank" rel="external">CustomTabsIntent.Builder#addMenuItem</a>)添加，title和用户点击菜单选项后Chrome调用的pendingIntent需要作为参数被传入。</p>
<img src="/2017/01/05/提升体验-Chrome-Custom-Tabs/twitter_menu.png" alt="menu" title="menu">
<pre><code class="java">builder.addMenuItem(menuItemTitle, menuItemPendingIntent);
</code></pre>
<h4 id="配置进场和退场动画"><a href="#配置进场和退场动画" class="headerlink" title="配置进场和退场动画"></a>配置进场和退场动画</h4><p>许多的Android都会在Activity之间切换时使用自定义的视图进入和退出动画。Chrome Custom Tabs也一样，我们可以改变进入和退出动画，以此保持Chrome Custom Tabs和应用其他内容的协调性和一致性。</p>
<pre><code class="java">builder.setStartAnimations(this, R.anim.slide_in_right, R.anim.slide_out_left);
builder.setExitAnimations(this, R.anim.slide_in_left, R.anim.slide_out_right);
</code></pre>
<h4 id="预热Chrome，提高页面加载速度"><a href="#预热Chrome，提高页面加载速度" class="headerlink" title="预热Chrome，提高页面加载速度"></a>预热Chrome，提高页面加载速度</h4><p>默认情况下，当<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsIntent.html#launchUrl(android.app.Activity, android.net.Uri" target="_blank" rel="external"> CustomTabsIntent#launchUrl </a>)被调用时会激活Chrome，加载URL。这会花费我们宝贵的时间并且影响流畅度。</p>
<p>Chrome团队了解用户对于流畅体验的渴望，所以他们在Chrome中提供了一个Service使我们的APP能够连接并且预热浏览器和原生组件。他们也把这种能力分享给了我们普通开发者，开发者能够告知Chrome用户访问页面的可能性。然后，Chrome就能完成如下的操作：</p>
<ul>
<li>主域名的DNS预解析</li>
<li>最有可能加载的资源的DNS预解析</li>
<li>包括HTTPS/TLS验证在内的预连接</li>
</ul>
<p>预热Chrome的步骤如下：</p>
<ul>
<li>使用<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html#bindCustomTabsService(android.content.Context, java.lang.String, android.support.customtabs.CustomTabsServiceConnection" target="_blank" rel="external">CustomTabsClient#bindCustomTabsService</a>)连接service</li>
<li>一旦service连接成功，后台调用<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html#warmup(long" target="_blank" rel="external"> CustomTabsClient#warmup</a>)启动Chrome</li>
<li>调用<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html#newSession(android.support.customtabs.CustomTabsCallback" target="_blank" rel="external"> CustomTabsClient#newSession </a>)创建一个新的session.这个session被用作所有的API请求</li>
<li>我们可以在创建session时选择性的添加一个<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsCallback.html" target="_blank" rel="external"> CustomTabsCallback</a>作为参数，这样我们就能知道页面是否被加载完成</li>
<li>通过<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsSession.html#mayLaunchUrl(android.net.Uri, android.os.Bundle, java.util.List&lt;android.os.Bundle" target="_blank" rel="external"> CustomTabsSession#mayLaunchUrl</a>)告知Chrome用户最有可能加载的页面</li>
<li>调用<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsIntent.Builder.html" target="_blank" rel="external"> CustomTabsIntent.Builder </a>构造方法，并传入已经创建好的<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsSession.html" target="_blank" rel="external">CustomTabsSession</a>作为参数传入</li>
</ul>
<h4 id="连接Chrome服务"><a href="#连接Chrome服务" class="headerlink" title="连接Chrome服务"></a>连接Chrome服务</h4><p><a href="("> CustomTabsClient#bindCustomTabsService </a><a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html#bindCustomTabsService(android.content.Context" target="_blank" rel="external">http://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html#bindCustomTabsService(android.content.Context</a>, java.lang.String, android.support.customtabs.CustomTabsServiceConnectio)) 方法简化了连接Custom Tabs服务的过程。</p>
<p>创建一个继承自<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsServiceConnection.html" target="_blank" rel="external">CustomTabsServiceConnection</a>的类并使用<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsServiceConnection.html#onCustomTabsServiceConnected(android.content.ComponentName, android.support.customtabs.CustomTabsClient" target="_blank" rel="external">onCustomTabsServiceConnected </a>)方法获取<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html" target="_blank" rel="external"> CustomTabsClient</a>的实例。在下一步中会用到此实例：</p>
<pre><code class="java">// 官方示例
// 客户端需要连接的Chrome的包名，取决于channel的名称
// Stable(发行版) = com.android.chrome
// Beta(测试版) = com.chrome.beta
// Dev(开发版) = com.chrome.dev
public static final String CUSTOM_TAB_PACKAGE_NAME = &quot;com.android.chrome&quot;;  // Change when in stable

CustomTabsServiceConnection connection = new CustomTabsServiceConnection() {
    @Override
    public void onCustomTabsServiceConnected(ComponentName name, CustomTabsClient client) {
        mCustomTabsClient = client;
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {

    }
};
boolean ok = CustomTabsClient.bindCustomTabsService(this, mPackageNameToBind, connection);
</code></pre>
<pre><code class="java">// 我的示例
package com.marktony.zhihudaily.customtabs;

import android.support.customtabs.CustomTabsServiceConnection;
import android.content.ComponentName;
import android.support.customtabs.CustomTabsClient;

import java.lang.ref.WeakReference;

/**
 * Created by Lizhaotailang on 2016/9/4.
 * Implementation for the CustomTabsServiceConnection that avoids leaking the
 * ServiceConnectionCallback
 */

public class ServiceConnection extends CustomTabsServiceConnection {

    // A weak reference to the ServiceConnectionCallback to avoid leaking it.
    private WeakReference&lt;ServiceConnectionCallback&gt; mConnectionCallback;

    public ServiceConnection(ServiceConnectionCallback connectionCallback) {
        mConnectionCallback = new WeakReference&lt;&gt;(connectionCallback);
    }

    @Override
    public void onCustomTabsServiceConnected(ComponentName name, CustomTabsClient client) {
        ServiceConnectionCallback connectionCallback = mConnectionCallback.get();
        if (connectionCallback != null) connectionCallback.onServiceConnected(client);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
        ServiceConnectionCallback connectionCallback = mConnectionCallback.get();
        if (connectionCallback != null) connectionCallback.onServiceDisconnected();
    }

}
</code></pre>
<h4 id="预热浏览器"><a href="#预热浏览器" class="headerlink" title="预热浏览器"></a>预热浏览器</h4><p><a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html#warmup(long" target="_blank" rel="external">boolean warmup(long flags)</a>)</p>
<p>预热浏览器进程并加重原生库文件。预热是异步进行的，返回值表示请求是否被接收。多个成功的请求都会返回true。</p>
<p><code>true</code>代表着成功。</p>
<h4 id="创建新的tab-sessioin"><a href="#创建新的tab-sessioin" class="headerlink" title="创建新的tab sessioin"></a>创建新的tab sessioin</h4><p><a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html#newSession(android.support.customtabs.CustomTabsCallback" target="_blank" rel="external">boolean newSession(CustomTabsCallback callback)</a>)</p>
<p>session用于在连续请求中链接mayLaunchUrl方法。CustomTabsIntent和tab互相联系。这里所提供的回调和已经创建成功的session相关。通过这个回调，任何关于已经成功创建的session的更新都会被接收到。返回session是否被成功创建。多个具有相同CustomTabsCallback或者null值的请求都会返回false。</p>
<h4 id="告知Chrome用户可能打开的链接"><a href="#告知Chrome用户可能打开的链接" class="headerlink" title="告知Chrome用户可能打开的链接"></a>告知Chrome用户可能打开的链接</h4><p><a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsSession.html#mayLaunchUrl(android.net.Uri, android.os.Bundle, java.util.List&lt;android.os.Bundle" target="_blank" rel="external">boolean mayLaunchUrl(Uri url, Bundle extras, List otherLikelyBundles)</a>)</p>
<p>CustomTabsSession方法告知浏览器未来可能导航到的url。<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html#warmup(long" target="_blank" rel="external">warmup()</a>)方法应该先被调用。最有可能的url应该最先被指出。也可以选择性的提供可能加载的url的列表。列表中的数据被认为被加载的可能性小于最初的那一个，而且必须按照优先级降序排列。这些额外的url可能被忽略掉。所有之前对于这个方法的调用都会被去优先化。返回操作是否成功完成。</p>
<h4 id="Custom-Tabs连接回调"><a href="#Custom-Tabs连接回调" class="headerlink" title="Custom Tabs连接回调"></a>Custom Tabs连接回调</h4><p><a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsCallback.html#onNavigationEvent(int, android.os.Bundle" target="_blank" rel="external">void onNavigationEvent(int navigationEvent, Bundle extras)</a>)</p>
<p>在custom tab中，导航事件发生时被调用。‘navigationEvent int’是关于页面内的6个状态值之一。6个状态值定义如下：</p>
<pre><code class="java">/**
* 页面开始加载时被发送
*/
public static final int NAVIGATION_STARTED = 1;

/**
* 页面完成加载时被发送
*/
public static final int NAVIGATION_FINISHED = 2;

/**
* 由于错误tab不能完成加载时被发送
*/
public static final int NAVIGATION_FAILED = 3;

/**
* 在加载完成之前，加载因为用户动作例如点击了另外一个链接或者刷新页面
* 加载被中止时被发送
*/
public static final int NAVIGATION_ABORTED = 4;

/**
* tab状态变为可见时发送
*/
public static final int TAB_SHOWN = 5;

/**
* tab状态变为不可见时发送
*/
public static final int TAB_HIDDEN = 6;
</code></pre>
<h4 id="如果用户没有安装最新版本的Chrome，会发生什么呢？"><a href="#如果用户没有安装最新版本的Chrome，会发生什么呢？" class="headerlink" title="如果用户没有安装最新版本的Chrome，会发生什么呢？"></a>如果用户没有安装最新版本的Chrome，会发生什么呢？</h4><p>Custom Tabs通过带有key Extras的 ACTION_VIEW Intent来定制UI。这就意味着将要打开的页面会通过系统浏览器或者用户默认浏览器打开。</p>
<p>如果用户已经安装了Chrome并且是默认浏览器，它会自动的获取EXTRAS的值并提供一个定制化的UI。其他的浏览器使用Intent extras提供相同的定制UI也是有可能的。</p>
<h4 id="怎样检测Chrome是否支持Chrome-Custom-Tabs"><a href="#怎样检测Chrome是否支持Chrome-Custom-Tabs" class="headerlink" title="怎样检测Chrome是否支持Chrome Custom Tabs?"></a>怎样检测Chrome是否支持Chrome Custom Tabs?</h4><p>所有支持Chrome Custom Tabs的Chrome浏览器都暴露了一个service。为了检测是否支持Chrome Custom Tabs，可以尝试着绑定service，如果成功的话，那么Customs Tabs可以成功的使用。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>启用Chrome Custom Tabs后,我们看到了各种不同质量界别的实现效果。这里介绍一组实现优秀集成的最佳实践。</p>
<h4 id="连接Custome-Tabs-Service并发起预热"><a href="#连接Custome-Tabs-Service并发起预热" class="headerlink" title="连接Custome Tabs Service并发起预热"></a>连接Custome Tabs Service并发起预热</h4><p>连接到Custom Tabs Service并预加载Chrome之后，通过Custom Tabs打开链接 <strong>最多可以节省700ms</strong> 。</p>
<p>在我们打算启用Custom Tabs的Activity的 <a href="http://developer.android.com/reference/android/app/Activity.html#onStart(" target="_blank" rel="external">onStart()</a>) 方法中连接 Custom Tabs service。连接成功后，调用<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html#warmup%28long%29" target="_blank" rel="external">warmup()</a>方法。</p>
<p>Custom Tabs作为一个非常低优先级的进程，这也就意味着 <strong>它不会对我们的应用不会有任何的负面的影响</strong>，但是当加载链接时，会获得非常好的启动性能。</p>
<h4 id="内容预渲染"><a href="#内容预渲染" class="headerlink" title="内容预渲染"></a>内容预渲染</h4><p>预渲染让内容打开非常迅速。所以，如果用户 <strong>至少有50%的可能性</strong> 打开某个链接，调用<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsSession.html#mayLaunchUrl%28android.net.Uri,%20android.os.Bundle,%20java.util.List%3Candroid.os.Bundle%3E%29" target="_blank" rel="external">mayLaunchUrl()</a><br>方法。</p>
<p>调用<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsSession.html#mayLaunchUrl%28android.net.Uri,%20android.os.Bundle,%20java.util.List%3Candroid.os.Bundle%3E%29" target="_blank" rel="external">mayLaunchUrl()</a><br>方法方法能使Custom Tabs预获取主页面所支持的内容并预渲染。这会最大程度的加快页面的加载速度。但是会不可避免的有 <strong>一点流量和电量的消耗</strong>。</p>
<p>Custom Tabs非常的智能，能够感知用户是否在使用收费的网络或者设备电量不足，预渲染对设备的整体性能有负面的影响，在这样的场景下，Custom Tabs就不会进行预获取或者预渲染。所以，不用担心应用的性能问题。</p>
<h4 id="当Custom-Tabs没有安装时，提供备选方案"><a href="#当Custom-Tabs没有安装时，提供备选方案" class="headerlink" title="当Custom Tabs没有安装时，提供备选方案"></a>当Custom Tabs没有安装时，提供备选方案</h4><p>尽管Custom Tabs对于大多数用户都是适用的，仍然有一些场景不适用，例如设备上没有安装支持Custom Tabs的浏览器或者是设备上的浏览器版本不支持Custom Tabs。</p>
<p><strong>确保提供了备选方案以提供好的应用体验</strong>。打开默认浏览器或者引入WebView都是不错的选择。</p>
<h4 id="将我们的应用作为referrer-引荐来源"><a href="#将我们的应用作为referrer-引荐来源" class="headerlink" title="将我们的应用作为referrer(引荐来源)"></a>将我们的应用作为referrer(引荐来源)</h4><p>通常，对于网站而言，追用访问的来源非常地重要。当加载了Custom Tabs时，通过设置referrer，让他们知晓我们正在给他们提高访问量。</p>
<pre><code class="java">intent.putExtra(Intent.EXTRA_REFERRER,
        Uri.parse(Intent.URI_ANDROID_APP_SCHEME + &quot;//&quot; + context.getPackageName()));
</code></pre>
<h4 id="添加定制动画"><a href="#添加定制动画" class="headerlink" title="添加定制动画"></a>添加定制动画</h4><p>定制的动画能够使我们的应用切换到网页内容时更加地顺畅。 确保进场动画和出厂动画是反向的，这样能够帮助用户理解跳转的关系。</p>
<pre><code class="java">   //设置定制的进入/退出动画
    CustomTabsIntent.Builder intentBuilder = new CustomTabsIntent.Builder();
    intentBuilder.setStartAnimations(this, R.anim.slide_in_right, R.anim.slide_out_left);
    intentBuilder.setExitAnimations(this, android.R.anim.slide_in_left,
        android.R.anim.slide_out_right);

    //打开Custom Tab        
    intentBuilder.build().launchUrl(context, Uri.parse(&quot;https://github.com/TonnyL&quot;));
</code></pre>
<h4 id="为Action-Button选择一个icon"><a href="#为Action-Button选择一个icon" class="headerlink" title="为Action Button选择一个icon"></a>为Action Button选择一个icon</h4><p>添加一个Action Button能够使用户更加理解APP的功能。但是，如果没有好的icon代表Action Button将要执行的操作，有必要创建一个带操作文字描述的位图。</p>
<p>牢记位图的最大尺寸为高度24dp，宽度48dp。</p>
<pre><code class="java">    String shareLabel = getString(R.string.label_action_share);
    Bitmap icon = BitmapFactory.decodeResource(getResources(),
            android.R.drawable.ic_menu_share);

    // 为我们的BroadCastReceiver创建一个PendingIntent
    Intent actionIntent = new Intent(
            this.getApplicationContext(), ShareBroadcastReceiver.class);
    PendingIntent pendingIntent =
            PendingIntent.getBroadcast(getApplicationContext(), 0, actionIntent, 0);            

     // 设置pendingIntent作为按钮被点击后将要执行的操作    
    intentBuilder.setActionButton(icon, shareLabel, pendingIntent);
</code></pre>
<h4 id="为其他浏览器做准备"><a href="#为其他浏览器做准备" class="headerlink" title="为其他浏览器做准备"></a>为其他浏览器做准备</h4><p>牢记用户安装的浏览器中，支持Custom Tabs的数量可能不止一个。如果有不止一个浏览器支持Custom Tabs，并且没有任何一个浏览器被设置为偏好浏览器，需要询问用户如何打开链接</p>
<pre><code class="java">    /**
     * 返回支持Custom Tabs的应用的包名
     */
    public static ArrayList getCustomTabsPackages(Context context) {
        PackageManager pm = context.getPackageManager();
        // Get default VIEW intent handler.
        Intent activityIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;http://www.example.com&quot;));

        // 获取所有能够处理VIEW intents的应用
        List resolvedActivityList = pm.queryIntentActivities(activityIntent, 0);
        ArrayList packagesSupportingCustomTabs = new ArrayList&lt;&gt;();
        for (ResolveInfo info : resolvedActivityList) {
            Intent serviceIntent = new Intent();
            serviceIntent.setAction(ACTION_CUSTOM_TABS_CONNECTION);
            serviceIntent.setPackage(info.activityInfo.packageName);
            // Check if this package also resolves the Custom Tabs service.
            if (pm.resolveService(serviceIntent, 0) != null) {
                packagesSupportingCustomTabs.add(info);
            }
        }
        return packagesSupportingCustomTabs;
    }
</code></pre>
<h4 id="允许用户不使用Custom-Tabs"><a href="#允许用户不使用Custom-Tabs" class="headerlink" title="允许用户不使用Custom Tabs"></a>允许用户不使用Custom Tabs</h4><p>为应用添加一个设置选项，允许用户通过默认浏览器而不是Custom Tab打开链接。如果我们的应用在添加Custom Tabs之前，都是通过默认浏览器打开链接显得尤为重要。</p>
<h4 id="尽量让Native应用处理URL"><a href="#尽量让Native应用处理URL" class="headerlink" title="尽量让Native应用处理URL"></a>尽量让Native应用处理URL</h4><p>Native应用可以处理一些url。如果用户安装了Twitter APP，在点击tweet内的链接时，她更加希望Twitter应用能够处理这些链接。</p>
<p>在应用内打开链接之前，检查手机里有没有其他APP能够处理这些url。</p>
<h4 id="定制Toolbar的颜色"><a href="#定制Toolbar的颜色" class="headerlink" title="定制Toolbar的颜色"></a>定制Toolbar的颜色</h4><p>如果想要让用户感觉网页内容是我们应用的一部分，将toolbar的颜色设置为primaryColor。</p>
<p>如果想要让用户清楚的了解到已经离开了我们的应用，那就完全不要定义toolbar的颜色。</p>
<pre><code class="java">    // 设置自定义的toolbar的颜色
    CustomTabsIntent.Builder intentBuilder = new CustomTabsIntent.Builder();
    intentBuilder.setToolbarColor(Color.BLUE);
</code></pre>
<h4 id="增加分享按钮"><a href="#增加分享按钮" class="headerlink" title="增加分享按钮"></a>增加分享按钮</h4><p>确保在overflow菜单中添加了一个分享的操作，在大多数的情况下，用户希望能够分享当前所见网页内容的链接，Custom Tabs默认没有添加分享的按钮。</p>
<pre><code class="java">    // 在BroadCastReceiver中分享来自CustomTabs的内容
    public void onReceive(Context context, Intent intent) {
        String url = intent.getDataString();

        if (url != null) {
            Intent shareIntent = new Intent(Intent.ACTION_SEND);
            shareIntent.setType(&quot;text/plain&quot;);
            shareIntent.putExtra(Intent.EXTRA_TEXT, url);

            Intent chooserIntent = Intent.createChooser(shareIntent, &quot;Share url&quot;);
            chooserIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

            context.startActivity(chooserIntent);
        }
    }
</code></pre>
<h4 id="定制关闭按钮"><a href="#定制关闭按钮" class="headerlink" title="定制关闭按钮"></a>定制关闭按钮</h4><p>自定义关闭按钮使CustomTabs看起来像应用的一部分。</p>
<p>如果希望CustomTabs在用户看来像一个Dialog, 使用’x’(叉叉)按钮。如果希望Custom Tab是用户的一部分，使用返回箭头。</p>
<pre><code class="java">    //设置自定义的关闭按钮
    CustomTabsIntent.Builder intentBuilder = new CustomTabsIntent.Builder();
    intentBuilder.setCloseButtonIcon(BitmapFactory.decodeResource(
        getResources(), R.drawable.ic_arrow_back));
</code></pre>
<h4 id="处理内部链接"><a href="#处理内部链接" class="headerlink" title="处理内部链接"></a>处理内部链接</h4><p>当监听到链接是由<a href="http://developer.android.com/reference/android/widget/TextView.html#attr_android:autoLink" target="_blank" rel="external">android:autoLink</a>生成的或者在WebView中复写了click方法，确保我们的应用处理了这些内容的链接，让CustomTabs处理外部链接。</p>
<pre><code class="java">WebView webView = (WebView)findViewById(R.id.webview);
webView.setWebViewClient(new WebViewClient() {
    @Override
    public boolean shouldOverrideUrlLoading(WebView view, String url) {
        return true;
    }

    @Override
    public void onLoadResource(WebView view, String url) {
        if (url.startsWith(&quot;http://www.example.com&quot;)) {
            //Handle Internal Link...
        } else {
            //Open Link in a Custom Tab
            Uri uri = Uri.parse(url);
            CustomTabsIntent.Builder intentBuilder =
                    new CustomTabsIntent.Builder(mCustomTabActivityHelper.getSession());
           //Open the Custom Tab        
            intentBuilder.build().launchUrl(context, url));                            
        }
    }
});
</code></pre>
<h4 id="处理连击"><a href="#处理连击" class="headerlink" title="处理连击"></a>处理连击</h4><p>如果希望在用户点击链接和打开CustomTabs之间做一些准备工作，确保所花费的时间不超过100ms。否则用户会认为APP没有响应，可能是试着点击链接多次。</p>
<p>如果不能避免延迟，确保我们的应用对可能的情况做好准备，当用户点击相同的链接多次时，不要多次打开CustomTab。</p>
<h3 id="低版本API"><a href="#低版本API" class="headerlink" title="低版本API"></a>低版本API</h3><p>尽管整合Custom Tabs的推荐方式是使用Custom Tabs Support Library，低API版本的系统也是可以使用的。</p>
<p>完整的Support Library的导入方法可以参见<a href="https://github.com/GoogleChrome/custom-tabs-client/tree/master/customtabs" target="_blank" rel="external">GitHub</a>,并可以做为一个起点。连接service的<a href="http://developer.android.com/guide/components/aidl.html" target="_blank" rel="external">AIDL文件</a>也被包含在其中，Chromium仓库中也包含了这些文件，而这些文件在Android Studio中是不能直接被使用的。</p>
<h4 id="在低版本API中使用Custom-Tabs的基本方法"><a href="#在低版本API中使用Custom-Tabs的基本方法" class="headerlink" title="在低版本API中使用Custom Tabs的基本方法"></a>在低版本API中使用Custom Tabs的基本方法</h4><pre><code class="java">
String url = ¨https://github.com/TonnyL¨;
Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));

private static final String EXTRA_CUSTOM_TABS_SESSION = &quot;android.support.customtabs.extra.SESSION&quot;;
Bundle extras = new Bundle;
extras.putBinder(EXTRA_CUSTOM_TABS_SESSION,
   sessionICustomTabsCallback.asBinder() /* 不需要session时设置为null */);
intent.putExtras(extras);
</code></pre>
<h4 id="定制UI"><a href="#定制UI" class="headerlink" title="定制UI"></a>定制UI</h4><p>UI定制是通过向ACTION_VIEW Intent添加Extras实现的。用于定制UI的完整的extras keys的列表可以在<a href="http://developer.android.com/reference/android/support/customtabs/CustomTabsIntent.html" target="_blank" rel="external"> CustomTabsIntent docs </a>找到。下面是添加自定义的toolbar的颜色的示例：</p>
<pre><code class="java">private static final String EXTRA_CUSTOM_TABS_TOOLBAR_COLOR = &quot;android.support.customtabs.extra.TOOLBAR_COLOR&quot;;
intent.putExtra(EXTRA_CUSTOM_TABS_TOOLBAR_COLOR, colorInt);
</code></pre>
<h4 id="连接Custom-Tabs-Service"><a href="#连接Custom-Tabs-Service" class="headerlink" title="连接Custom Tabs Service"></a>连接Custom Tabs Service</h4><p>Custom Tabs service和其他Android Service的使用方法相同。接口通过AIDL创建并且代理service类也会自动创建。</p>
<pre><code>// 客户端需要连接的Chrome的包名，取决于channel的名称
// Stable(发行版) = com.android.chrome
// Beta(测试版) = com.chrome.beta
// Dev(开发版) = com.chrome.dev
public static final String CUSTOM_TAB_PACKAGE_NAME = &quot;com.chrome.dev&quot;;  // Change when in stable

public static final String ACTION_CUSTOM_TABS_CONNECTION =
       &quot;android.support.customtabs.action.CustomTabsService&quot;;
Intent serviceIntent = new Intent(ACTION_CUSTOM_TABS_CONNECTION);

serviceIntent.setPackage(CUSTOM_TAB_PACKAGE_NAME);
context.bindService(serviceIntent, mServiceConnection,
                    Context.BIND_AUTO_CREATE | Context.BIND_WAIVE_PRIORITY);
</code></pre><h3 id="一些有用的网址"><a href="#一些有用的网址" class="headerlink" title="一些有用的网址"></a>一些有用的网址</h3><ul>
<li><a href="https://github.com/GoogleChrome/custom-tabs-client" target="_blank" rel="external">Github Demo</a></li>
<li><a href="http://stackoverflow.com/questions/tagged/chrome-custom-tabs" target="_blank" rel="external">Chrome Custom Tabs on StackOverflow</a></li>
<li>我的项目地址:<a href="https://github.com/TonnyL/PaperPlane" target="_blank" rel="external">PaperPlane</a></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果我们的应用是面向国外用户的，那理所当然的，应该加入Chrome Custom Tabs的支持，这在很大程度上能够提升用户的体验。如果我们的应用只是面向国内用户，我的建议还是应该加上这项功能，毕竟，还是有部分用户安装了Chrome浏览器，当用户浏览到Custom Tab页面，应该也会像我一样，感觉到眼前一亮吧。</p>
<p>文章比较长，感谢阅读。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[简洁优雅地实现夜间模式]]></title>
      <url>http://tonnyl.github.io/2016/12/31/%E7%AE%80%E6%B4%81%E4%BC%98%E9%9B%85%E5%9C%B0%E5%AE%9E%E7%8E%B0%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>使用官方Support Library实现日间与夜间模式<br><a id="more"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android 6.0 Marshmallow 预览版中曾经短暂出现过相关的夜间模式的功能，只是在正式版中被移除了，在Android 7.0 Nougat上，用户们再次经历了「得而复失」的遗憾，在开发者预览版中，夜间模式和暗色模式先是开启，然后有再次被移除。而在正式版中，夜间模式也没有出现。但其实相关的代码一直存在于系统中，只是默认没有被开启。如何开启这项功能，可以参考少数派的这一篇文章，<a href="http://sspai.com/35273" target="_blank" rel="external">帮你找回 Android 7.0 夜间模式的 2 款应用</a>。</p>
<p>不过，今天要介绍的主要内容并不是关于系统的夜间模式，而是如何给我们开发的APP添加夜间模式的功能。毫不夸张的说，夜间模式现在已经是阅读类App的标配了。事实上，日间模式与夜间模式就是给APP定义并应用两套不同颜色的主题。用户可以自动或者手动的开启。我们先看两个我认为实现地很优雅的例子：知乎和Twitter。</p>
<img src="/2016/12/31/简洁优雅地实现夜间模式/zhihu_twitter_nightmode.gif" alt="zhihu_twitter_nightmode" title="zhihu_twitter_nightmode">
<p>这两个APP在切换的工程中，并没有出现闪现黑屏的情况，切换也比较顺滑。我们的目标就是利用Support Library实现同样的效果。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><pre><code>compile &#39;com.android.support:appcompat-v7:25.1.0&#39;
</code></pre><p>由于Support Library在23.2.0的版本中才添加了Theme.AppCompat.DayNight主题，所以依赖的版本必须是高于23.2.0的，并且，这个特性支持的最低SDK版本为14，所以，需要兼容Android 4.0的设备，是不能使用这个特性的，在API Level 14以下的设备会默认使用亮色主题。不过现在4.0以下的设备应该比较少了吧，毕竟微信的minSdkVersion都设置为14了。</p>
<h3 id="准备资源"><a href="#准备资源" class="headerlink" title="准备资源"></a>准备资源</h3><ol>
<li><p>让我们自己的主题继承并应用DayNight主题。</p>
<pre><code class="xml"> &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight.DarkActionBar&quot;&gt;

         &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
         &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;
         &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
         &lt;!--customize your theme here--&gt;

 &lt;/style&gt;
</code></pre>
</li>
<li><p>新建夜间模式资源文件夹:在<code>res</code>目录下新建<code>values-night</code>文件夹，然后在此目录下新建<code>colors.xml</code>文件在夜间模式下的应用的资源。当然也可以根据需要新建<code>drawable-night</code>,<code>layout-night</code>等后缀为<code>-night</code>的夜间资源文件夹。<br>我的<code>values</code>和<code>values-night</code>目录下的<code>colors.xml</code>的内容如下:</p>
<pre><code class="xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
 &lt;!--values-colors.xml--&gt;
 &lt;resources&gt;
     &lt;color name=&quot;colorPrimary&quot;&gt;#009688&lt;/color&gt;
     &lt;color name=&quot;colorPrimaryDark&quot;&gt;#00796B&lt;/color&gt;
     &lt;color name=&quot;colorAccent&quot;&gt;#009688&lt;/color&gt;
     &lt;color name=&quot;textColorPrimary&quot;&gt;#616161&lt;/color&gt;
     &lt;color name=&quot;viewBackground&quot;&gt;@android:color/white&lt;/color&gt;
 &lt;/resources&gt;
</code></pre>
<pre><code class="xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
 &lt;!--values-night-colors.xml&gt;
 &lt;resources&gt;
     &lt;color name=&quot;colorPrimary&quot;&gt;#35464e&lt;/color&gt;
     &lt;color name=&quot;colorPrimaryDark&quot;&gt;#212a2f&lt;/color&gt;
     &lt;color name=&quot;colorAccent&quot;&gt;#212a2f&lt;/color&gt;
     &lt;color name=&quot;textColorPrimary&quot;&gt;#616161&lt;/color&gt;
     &lt;color name=&quot;viewBackground&quot;&gt;#212a2f&lt;/color&gt;
 &lt;/resources&gt;
</code></pre>
</li>
<li><p>使Activity继承自AppCompatActivity。</p>
<pre><code class="java"> public class MainActivity extends AppCompatActivity {

     // code here
     @Override
     protected void onCreate(Bundle savedInstanceState) {

     }

 }
</code></pre>
</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="静态应用"><a href="#静态应用" class="headerlink" title="静态应用"></a>静态应用</h4><p>在Application的继承类下设置初始主题。</p>
<pre><code class="java">public class App extends Application {

    @Override
    public void onCreate() {
        super.onCreate();

        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES);
        // other code here

}
</code></pre>
<p>这里<code>AppCompatDelegate.setDefaultNightMode()</code>方法可以接受的参数值有4个：</p>
<ul>
<li>MODE_NIGHT_NO. Always use the day (light) theme(一直应用日间(light)主题).</li>
<li>MODE_NIGHT_YES. Always use the night (dark) theme(一直使用夜间(dark)主题).</li>
<li>MODE_NIGHT_AUTO. Changes between day/night based on the time of day(根据当前时间在day/night主题间切换).</li>
<li>MODE_NIGHT_FOLLOW_SYSTEM(默认选项). This setting follows the system’s setting, which is essentially MODE_NIGHT_NO(跟随系统，通常为MODE_NIGHT_NO).</li>
</ul>
<p>我们可以在任何时候调用这个方法，因为这个方法是静态的。但是这个值并不是一直存在的，每次在开启进程时需要重新设置。在上面的代码中，我是在<code>onCreate()</code>方法中设置的，网上也有大神建议在Activity或者Application的<strong>static</strong>代码块中设置。如下所示：</p>
<pre><code class="java">public class App extends Application {

    static {
        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES);
    }

    @Override
    public void onCreate() {
        super.onCreate();

        // other code here

}
</code></pre>
<h4 id="动态应用"><a href="#动态应用" class="headerlink" title="动态应用"></a>动态应用</h4><p>虽然上面的静态应用的设置非常简单，但是这种方式的应用场景还是太少了。我们更多的还是需要动态的根据需要动态的切换。</p>
<ol>
<li><p>检测当前主题模式</p>
<pre><code class="java"> int mode = getResources().getConfiguration().uiMode &amp; Configuration.UI_MODE_NIGHT_MASK;
</code></pre>
</li>
<li><p>设置主题</p>
<pre><code class="java"> if(mode == Configuration.UI_MODE_NIGHT_YES) {
     AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO);
 } else if(mode == Configuration.UI_MODE_NIGHT_NO) {
     AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES);
 } else {
     // blah blah
 }

 recreate();
</code></pre>
<p> 在调用<code>recreate()</code>方法之前，还可以创建一些动画进行过渡。而且，众所周知，调用<code>recreate()</code>需要对一些数据进行保存，例如fragment，CheckBox,RadioBox等。如下所示:</p>
<pre><code class="java"> public class MainFragment extends Fragment {

     @Override
     public void onCreate(@Nullable Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);

          if (savedInstanceState != null) {
              FragmentManager manager = getChildFragmentManager();
             doubanMomentFragment = (DoubanMomentFragment) manager.getFragment(savedInstanceState, &quot;douban&quot;);
          } else {
              doubanMomentFragment = DoubanMomentFragment.newInstance();
          }
     }

     @Override
     public void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
         FragmentManager manager = getChildFragmentManager();
         manager.putFragment(outState, &quot;douban&quot;, doubanMomentFragment);
 }
</code></pre>
<p> 我们也可以把主题的值存储到SharedPreference中，已便于应用在下一次启动时自动应用主题。</p>
</li>
</ol>
<h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ul>
<li><p>Q:系统默认的颜色不合我的口味怎么办？</p>
<p>A:使用主题属性,例如:<code>textColor:?android:attr/textColorPrimary</code>,<code>color:?attr/colorControlNormal</code>等。</p>
</li>
<li><p>Q:为什么我的WebView颜色没有变化？</p>
<p>A:因为WebView不能使用主题属性。WebView的颜色实际上取决于网页内容颜色。网页的默认背景色是白色，所以尽管设置了主题为<code>AppCompatDelegate.MODE_NIGHT_YES</code>，网页仍然是白色，所以看起来就很不搭了。所以，网页的内容和背景色等资源也需要适配了。</p>
</li>
<li><p>Q:为什么不直接设置为<code>MODE_NIGHT_AUTO</code>呢？</p>
<p>A:因为使用<code>MODE_NIGHT_AUTO</code>需要请求坐标权限，获取系统的位置。你肯定会说了，这尼玛不是坑爹吗？如果程序已经授予了坐标权限(location permission)(如果你的target SDK为23或者更高，需要考虑运行时权限)，AppCompat会试着去获取上次保存的坐标，根据坐标来计算日出与日落的时间。如果程序没有位置权限或者LocationManager没有存储上次坐标的信息呢？系统或默认设置为早上6点钟为日出，下午10点为日落。用户调整系统时间，当前的主题也会随之改变。如果我们不希望用户在设定主题后，主题还会随着时间改变,<code>MODE_NIGHT_AUTO</code>就不适用了。</p>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>本项目代码<a href="https://github.com/TonnyL/PaperPlane" target="_blank" rel="external">PaperPlane</a> .<br>运行效果</p>
<img src="/2016/12/31/简洁优雅地实现夜间模式/paper_plane.gif" alt="Paper Plane" title="Paper Plane">
<p>在Android 6.0及以下的设备上，本项目运行时会有切换的过渡动画效果，但是不支持Android 7.0及以上的设备。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[适配Android 7.1 Nougat新特性]]></title>
      <url>http://tonnyl.github.io/2016/12/29/%E9%80%82%E9%85%8DAndroid-7-1-Nougat%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>老司机带你吃牛轧糖<br><a id="more"></a></p>
<h3 id="What’s-new-in-Android-7-1-Nougat"><a href="#What’s-new-in-Android-7-1-Nougat" class="headerlink" title="What’s new in Android 7.1 Nougat?"></a>What’s new in Android 7.1 Nougat?</h3><p>Android 7.1 Nougat 已经推出有一段时间，相信大多数人和我一样，并没有用上最新的系统，但是，总有一群走在时代的前列线上的Geek们，勇于尝鲜，艰苦奋斗，为刷新版本号贡献自己的力量。好吧，实际上就是我还没有用上7.1，有些眼馋了。那么，和开发者息息相关的有哪些新特性呢？</p>
<img src="/2016/12/29/适配Android-7-1-Nougat新特性/android_nougat.png" alt="Android 7.1 Nougat" title="Android 7.1 Nougat">
<p>本次主要介绍3个新特性:<strong>App Shortcuts</strong>, <strong>Round Icon Resource</strong> 和 <strong>Image Keyboard Support</strong>。所有的新特性可以访问谷歌开发者中文博客的文章<a href="http://developers.googleblog.cn/2016/12/android-711-nougat_20.html" target="_blank" rel="external">欢迎使用Android 7.1.1 Nougat</a>。</p>
<h3 id="App-Shortcuts"><a href="#App-Shortcuts" class="headerlink" title="App Shortcuts"></a>App Shortcuts</h3><p>作为一个密切关注Android发展的伪Geek，在7.1正式版未发布之前，通过网上的一些爆料文章，我就了解到了这一新功能。实际上，这个功能刚开始出现时，我还以为Google Pixel要上压感屏了呢，事实证明，的确是我想多了。</p>
<p>App Shortcuts允许用户直接在启动器中显示一些操作，让用户立即执行应用的深层次的功能。触发这一功能的操作就是「长按」。这一功能类似于iOS中的「3D Touch」。</p>
<p>下面通过一张GIF，直观的感受一下App Shortcuts是怎样的。（由于我的一加3并没有升级到最新的7.1，还只是7.0，所以我安装了Nova Launcher来体验。）</p>
<img src="/2016/12/29/适配Android-7-1-Nougat新特性/app_shortcuts.gif" alt="App Shortcuts" title="App Shortcuts">
<p>长按图标，收到震动后松手，如果能够看到图标上弹出了支持的跳转操作，说明成功的呼出了Shortcuts功能，如果不支持这一功能，在Nova Launcher上弹出的就是卸载或者移除操作，在Pixel Launcher上不会出现弹出菜单，显示的是常见的长按操作。长按弹出的操作，可以将这个操作已快捷方式图标的形式直接放置在主屏上。如果长按主图标不松手，就可以调整位置了。</p>
<p>目前，一个应用最多可以支持 <strong>5</strong> 个Shortcut,可以通过<a href="https://developer.android.com/reference/android/content/pm/ShortcutManager.html#getMaxShortcutCountPerActivity(" target="_blank" rel="external">getMaxShortcutCountPerActivity</a>)查看Launcher最多支持Shortcut的数量。每一个Shortcut都对应着一个或者多个intent，当用户选择某一个Shortcut时，应该做出特定的动作。下面是一些将一些特定的动作作为Shortcuts的例子：</p>
<ul>
<li><p>在地图APP中，指引用户至最常用的位置</p>
</li>
<li><p>在聊天APP中，发送信息至某个好友</p>
</li>
<li><p>在多媒体APP中，播放下一个电视节目</p>
</li>
<li><p>在游戏APP中，加载至上次保存的地方</p>
</li>
</ul>
<p>App Shortcut可以分为两种不同的类型： Static Shortcuts（静态快捷方式） 和 Dynamic Shortcuts（动态快捷方式）。</p>
<ul>
<li>Static Shortcuts：在打包到apk的资源文件中定义，所以，直到下一次更新版本时才能改变静态快捷方式的详细说明。</li>
<li>Dynamic Shortcuts：通过ShortcutManager API在运行时发布，在运行时，应用可以发布，升级和移除快捷方式。</li>
</ul>
<h4 id="Using-Static-Shortcuts"><a href="#Using-Static-Shortcuts" class="headerlink" title="Using Static Shortcuts"></a>Using Static Shortcuts</h4><p>创建Static Shortcuts分为以下几步：</p>
<p>1.在工程的manifest文件 (AndroidManifest.xml)下，找到 intent filter设置为 <strong>android.intent.action.MAIN</strong> 和 <strong>android.intent.category.LAUNCHER</strong> 的Activity。</p>
<p>2.在次Activity下添加<meta-data>标签，引用定义shortcuts的资源文件。</meta-data></p>
<pre><code class="xml">&lt;activity
        android:name=&quot;.homepage.MainActivity&quot;
        android:configChanges=&quot;orientation|keyboardHidden|screenSize|screenLayout&quot;
        android:label=&quot;@string/app_name&quot;
        android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;

        &lt;meta-data
            android:name=&quot;android.app.shortcuts&quot;
            android:resource=&quot;@xml/shortcuts&quot; /&gt;
    &lt;/activity&gt;
</code></pre>
<p>3.创建新的资源文件<code>res/xml/shortcuts.xml</code></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shortcuts xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;shortcut
        android:enabled=&quot;true&quot;
        android:icon=&quot;@drawable/ic_search_circle&quot;
        android:shortcutId=&quot;search_bookmarks&quot;
        android:shortcutShortLabel=&quot;@string/search_bookmarks&quot;
        android:shortcutLongLabel=&quot;@string/search_bookmarks&quot;&gt;

        &lt;intent
            android:action=&quot;android.intent.action.VIEW&quot;
            android:targetPackage=&quot;com.marktony.zhihudaily&quot;
            android:targetClass=&quot;com.marktony.zhihudaily.search.SearchActivity&quot; /&gt;

        &lt;!--如果你的一个shortcut关联着多个intent，你可以在这里继续添
            加。最后一个intent决定着用户在加载这个shortcut时会看到什么--&gt;

        &lt;categories android:name=&quot;android.shortcut.conversation&quot; /&gt;

    &lt;/shortcut&gt;

    &lt;!--在这里添加更多的shortcut--&gt;

&lt;/shortcuts&gt;
</code></pre>
<p><strong>shortcut</strong>下标签的含义：</p>
<ul>
<li><p>enabled:见名知意，shortcut是否可用。如果你决定让这个static shortcut不在可用的话，可直接将其设置为 <strong>false</strong> ，或者直接从 <strong>shortcuts</strong> 标签中移除。</p>
</li>
<li><p>icon:显示在左边的图标，可用使用<em>Vector drawable</em>。</p>
</li>
<li><p>shortcutDisabledMessage:当禁用此shortcut后，它仍然会出现在用户长按应用图标后的快捷方式列表里，也可以被拖动并固定到桌面上，但是它会呈现灰色并且用户点击时会弹出Toast这个标签所定义的内容。</p>
</li>
<li><p>shortcutLongLabel:当启动器有足够多的空间时，会显示这个标签所定义的内容。</p>
</li>
<li><p>shortcutShortLabel:shortcut的简要说明，是必需字段。当shortcut被添加到桌面上时，显示的也是这个字段。</p>
</li>
<li><p>intent:shortcut关联的一个或者多个intent，当用户点击shortcut时被打开。</p>
</li>
<li><p>shortcutId:shortcut的唯一标示id，若存在具有相同shortcutId的shortcut，则只显示一个。</p>
</li>
</ul>
<p>到这里，最简单的shortcut就添加成功了。运行包含上面的文件的项目，点击shortcut就可以直接进入 <strong>SearchActivity</strong>，当按下back键时，直接就退出了应用。如果希望不退出应用，而是进入 <strong>MainActivity</strong> 时，应该怎么办呢？不用着急，在shortcut继续添加intent就可以了。</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shortcuts xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;shortcut
        android:enabled=&quot;true&quot;
        android:icon=&quot;@drawable/ic_search_circle&quot;
        android:shortcutId=&quot;search_bookmarks&quot;
        android:shortcutShortLabel=&quot;@string/search_bookmarks&quot;
        android:shortcutLongLabel=&quot;@string/search_bookmarks&quot;&gt;

        &lt;intent
                android:action=&quot;android.intent.action.MAIN&quot;
                android:targetClass=&quot;com.marktony.zhihudaily.homepage.MainActivity&quot;
            android:targetPackage=&quot;com.marktony.zhihudaily&quot; /&gt;

        &lt;intent
            android:action=&quot;android.intent.action.VIEW&quot;
            android:targetPackage=&quot;com.marktony.zhihudaily&quot;
            android:targetClass=&quot;com.marktony.zhihudaily.search.SearchActivity&quot; /&gt;

        &lt;categories android:name=&quot;android.shortcut.conversation&quot; /&gt;

    &lt;/shortcut&gt;

      &lt;!--在这里添加更多的shortcut--&gt;

 &lt;/shortcuts&gt;
</code></pre>
<h4 id="Using-Dynamic-Shortcuts"><a href="#Using-Dynamic-Shortcuts" class="headerlink" title="Using Dynamic Shortcuts"></a>Using Dynamic Shortcuts</h4><p>动态快捷方式应该和应用内的特定的、上下文敏感的action链接。这些action应该可以在用户的几次使用之间、甚至是在应用运行过程中被改变。好的候选action包括打电话给特定的人、导航至特定的地方、或者展示当前游戏的分数。</p>
<p><a href="https://developer.android.com/reference/android/content/pm/ShortcutManager.html" target="_blank" rel="external">ShortcutManager</a> API允许我们在动态快捷方式上完成下面的操作：</p>
<ul>
<li><p>发布:使用setDynamicShortcuts()重新定义整个动态快捷方式列表，或者是使用addDynamicShortcuts()向已存在的动态快捷方式列表中添加快捷方式。</p>
</li>
<li><p>更新:使用updateShortcuts()方法。</p>
</li>
<li><p>移除:使用removeDynamicShortcuts()方法移除特定动态快捷方式或者使用removeAllDynamicShortcuts()移除所有动态快捷方式。</p>
</li>
</ul>
<p>下面是在MainActivity的onCreate()中创建动态快捷方式的例子：</p>
<pre><code class="java">@Override
protected void onCreate(Bundle savedInstanceState) {

    ...

    ShortcutManager shortcutManager = getSystemService(ShortcutManager.class);

    ShortcutInfo webShortcut = new ShortcutInfo.Builder(this, &quot;shortcut_web&quot;)
            .setShortLabel(&quot;github&quot;)
            .setLongLabel(&quot;Open Tonny&#39;s github web site&quot;)
            .setIcon(Icon.createWithResource(this, R.drawable.ic_dynamic_shortcut))
            .setIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://TonnyL.github.io&quot;)))
            .build();

    shortcutManager.setDynamicShortcuts(Collections.singletonList(webShortcut));
}
</code></pre>
<p>也可以为动态快捷方式创建返回栈。</p>
<pre><code class="java">@Override
protected void onCreate(Bundle savedInstanceState) {

    ...

    ShortcutInfo dynamicShortcut = new ShortcutInfo.Builder(this, &quot;shortcut_dynamic&quot;)
            .setShortLabel(&quot;Dynamic&quot;)
            .setLongLabel(&quot;Open dynamic shortcut&quot;)
            .setIcon(Icon.createWithResource(this, R.drawable.ic_dynamic_shortcut_2))
            .setIntents(
                    new Intent[]{
                            new Intent(Intent.ACTION_MAIN, Uri.EMPTY, this, MainActivity.class).setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK),
                            new Intent(DynamicShortcutActivity.ACTION)
                    })
            .build();

    shortcutManager.setDynamicShortcuts(Arrays.asList(webShortcut, dynamicShortcut));
}
</code></pre>
<p>创建一个新的空的Activity，名字叫做DynamicShortcutActivity，在manifest文件中注册。</p>
<pre><code class="xml">&lt;activity  
      android:name=&quot;.DynamicShortcutActivity&quot;
      android:label=&quot;Dynamic shortcut activity&quot;&gt;
      &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.marktony.zhihudaily.OPEN_DYNAMIC_SHORTCUT&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
      &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<p>通过清除array中的排序过的intents，当我们通过创建好的shortcut进入DynamicShortcutActivity之后，按下back键，MainActivity就会被加载。</p>
<p>需要注意的是，在动态创建快捷方式之前，最好是检查一下是否超过了所允许的最大值。否则会抛出相应的异常。</p>
<h4 id="Extra-Bits"><a href="#Extra-Bits" class="headerlink" title="Extra Bits"></a>Extra Bits</h4><ul>
<li><p>当static shortcut 和 dynamic shortcut一起展示时，其出现的顺序是怎样定制呢？</p>
<p>  在 <strong>ShortcutInfo.Builder</strong> 中有一个专门的方法 <strong>setRank(int)</strong> ,通过设置不同的等级，我们就可以控制动态快捷方式的出现顺序，等级越高，出现在快捷方式列表中的位置就越高。</p>
</li>
<li><p>我们还可以设置动态快捷方式的shortLabel的字体颜色。</p>
<pre><code class="java">  ForegroundColorSpan colorSpan = new ForegroundColorSpan(getResources().getColor(android.R.color.holo_red_dark, getTheme()));
  String label = &quot;github&quot;;
  SpannableStringBuilder colouredLabel = new SpannableStringBuilder(label);
  colouredLabel.setSpan(colorSpan, 0, label.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);

  ShortcutInfo webShortcut = new ShortcutInfo.Builder(MainActivity.this, &quot;shortcut_web&quot;)
          .setShortLabel(colouredLabel)
          .setRank(1)
          .build();
</code></pre>
</li>
</ul>
<h4 id="App-Shortcuts-Best-Practices"><a href="#App-Shortcuts-Best-Practices" class="headerlink" title="App Shortcuts Best Practices"></a>App Shortcuts Best Practices</h4><p>当设计和创建应用的shortcuts时，应该遵守下面的指导建议：</p>
<ul>
<li><p>遵循设计规范:为了保持我们的应用和系统应用的快捷方式在视觉上一致性，应该遵守<a href="https://developer.android.com/shareables/design/app-shortcuts-design-guidelines.pdf" target="_blank" rel="external">App Shortcuts Design Guidelines</a>。</p>
</li>
<li><p>发布4个不同的快捷方式:尽管现在的API支持静态和动态总共5个快捷方式，但是为了提高shortcut的视觉效果，建议只添加4个不同的快捷方式。</p>
</li>
<li><p>限制快捷方式描述的文本长度:在Launcher中，显示快捷方式时，空间长度受到了限制。如果可能的话，应该将「short description」的文字长度控制在10个字母以内，将「long discription」的长度限制在25个字母以内。</p>
</li>
<li><p>保存shortcut和action的历史记录:创建的每一个shortcut，应该考虑到用户能够通过不同的方式完成相同的任务。在这种情况下，记得调用 <strong>reportShortcutUsed()</strong> 方法，这样，launcher就可以提高shortcut对应的actions的反应速度。</p>
</li>
<li><p>只有在shortcuts的意义存在时更新：当改变动态快捷方式时，只有在shortcut仍然保持着它的含义时，调用 <strong>updateShortcuts()</strong> 方法改变它的信息。否则，应该使用<strong>addDynamicShortcuts()</strong> 或者 <strong>setDynamicShortcuts()</strong> 创建一个具有新含义的ID的快捷方式。</p>
<p>  举个例子，如果我们已经创建了导航到一个超市的快捷方式，如果超市的名称改变了但是位置并没有变化时，只更新信息是合适的。但是如果用户开始在一个不同位置的超市购物时，最好是创建一个全新的快捷方式(而不仅仅是更新信息了)。</p>
</li>
<li><p>在备份和恢复时，动态shortcuts不应该被保存:正是因为这个原因，推荐我们在需要APP启动和重新发布动态快捷方式时，检查 <strong>getDynamicShortcuts()</strong> 的对象的数量。可以参考<a href="https://developer.android.com/guide/topics/ui/shortcuts.html#backup-and-restore" target="_blank" rel="external">Backup and Restore</a>部分的代码片段。</p>
</li>
</ul>
<h3 id="Round-Icon-Resources"><a href="#Round-Icon-Resources" class="headerlink" title="Round Icon Resources"></a>Round Icon Resources</h3><p>在Android 7.1上，Google推出了一个部分用户可能不太喜欢的特性–圆形图标。圆形图标长什么样，可以看看下面的图。</p>
<img src="/2016/12/29/适配Android-7-1-Nougat新特性/round_icon.png" alt="round icon" title="round icon">
<blockquote>
<p>同时，圆形图标规范也作为一部分内容加入到了更新说明和开发文档中。<br>应用程序现在可以定义圆形启动器图标以用于特定的移动设备之上。当启动器请求应用程序图标时，程序框架应返回 android：icon 或 android：roundIcon，视设备具体要求而定。因此，应用程序在开发时应该确保同时定义 android：icon和 android：roundIcon 两个变量。您可以使用 Image Asset Studio 来设计圆形图标。</p>
<p>您应该确保在支持新的圆形图标的设备上测试您的应用程序，以确保应用程序图标的外观无虞和实际效果。测试您的资源的一种方法是在 Google Pixel 设备上安装您的应用。您还可以通过运行 Android 模拟器并使用 Google API 模拟器系统（目标 API 等级为 25）测试您的图标。</p>
</blockquote>
<p>我们可以通过 <strong>Android Studio</strong> 自带的 <strong>Image Asset Studio</strong>设计图标。在项目的 <strong>res</strong> 目录下点击鼠标右键，选择 <strong>new</strong> –&gt; <strong>Image Asset</strong> 即可设计图标。</p>
<img src="/2016/12/29/适配Android-7-1-Nougat新特性/ImageAssetStudio.png" alt="Image Asset Studio" title="Image Asset Studio">
<p>更多关于设计应用图标的信息，可以参考<a href="https://material.google.com/style/icons.html#icons-product-icons" target="_blank" rel="external">Material Design guidelines</a>。</p>
<h3 id="Image-Keyboard-Support"><a href="#Image-Keyboard-Support" class="headerlink" title="Image Keyboard Support"></a>Image Keyboard Support</h3><p>在较早版本的Android系统中，软键盘(例如我们所熟知的Input Method Editors，或者说IME)，只能够给应用发送unicode编码的emoji，对于rich content，应用只能通过使用自建的私有的API实现发送图片的功能。而在Android 7.1中，SDK包含了一个全新的Commit Content API，输入法应用不仅可以调用此 API 实现发送图片和其他rich content，一些通讯应用（比如 Google Messenger）也可以通过此 API 来更好地处理这些来自输入法的图片、网页信息和 GIF 内容。</p>
<img src="/2016/12/29/适配Android-7-1-Nougat新特性/image-keyboard-sample.png" alt="image keyboard" title="image keyboard">
<h4 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works"></a>How it works</h4><ol>
<li><p>当用户点击EditText时，    editor会发送一个它所能接受的 <strong>EditorInfo.contentMimeTypes</strong> MIME 内容类型的列表。</p>
</li>
<li><p>IME读取这个在软键盘中支持类型和展示内容的列表。</p>
</li>
<li><p>当用户选择一张图片后，IME调用 <strong>commitContent()</strong> 并向editor发送一个InputContentInfo。 <strong>commitContent()</strong> 方法是一个类似于 <strong>commitText()</strong> 的方法，但是是rich content的。 <strong>InputContentInfo</strong> 包含着一个表示content provider中内容的URI。然后我们的应用就可以请求相应的权限并读取URI中的内容。</p>
</li>
</ol>
<img src="/2016/12/29/适配Android-7-1-Nougat新特性/image-keyboard-diagram.png" alt="image keyboard diagram" title="image keyboard diagram">
<h4 id="Adding-Image-Support-to-Apps"><a href="#Adding-Image-Support-to-Apps" class="headerlink" title="Adding Image Support to Apps"></a>Adding Image Support to Apps</h4><p>为了接收来自IME的rich content，应用必须告诉IME它所能接收的内容类型并之指定当接收到内容后的回调方法。下面是一个怎样创建一个能够接收PNG图片的 <strong>EditText</strong> 的演示代码。</p>
<pre><code class="java">EditText editText = new EditText(this) {
    @Override
    public InputConnection onCreateInputConnection(EditorInfo editorInfo) {
        final InputConnection ic = super.onCreateInputConnection(editorInfo);
        EditorInfoCompat.setContentMimeTypes(editorInfo,
                new String [] {&quot;image/png&quot;});

        final InputConnectionCompat.OnCommitContentListener callback =
            new InputConnectionCompat.OnCommitContentListener() {
                @Override
                public boolean onCommitContent(InputContentInfoCompat inputContentInfo,
                        int flags, Bundle opts) {
                    // read and display inputContentInfo asynchronously
                    if (BuildCompat.isAtLeastNMR1() &amp;&amp; (flags &amp;
                        InputConnectionCompat.INPUT_CONTENT_GRANT_READ_URI_PERMISSION) != 0) {
                        try {
                            inputContentInfo.requestPermission();
                        }
                        catch (Exception e) {
                            return false; // return false if failed
                        }
                    }

                    // read and display inputContentInfo asynchronously.
                    // call inputContentInfo.releasePermission() as needed.

                    return true;  // return true if succeeded
                }
            };
        return InputConnectionCompat.createWrapper(ic, editorInfo, callback);
    }
};
</code></pre>
<p>代码还是蛮多的，解释一下。</p>
<ul>
<li><p>例子使用了support library，并且引用的是 <strong>android.support.v13.view.inputmethod</strong> 而不是 <strong>android.view.inputmethod</strong> 。</p>
</li>
<li><p>例子创建了一个 <strong>EditText</strong> 并复写了它改变 <strong>InputConnection</strong> 的 <strong>onCreateInputConnection(EditorInfo)</strong> 方法. <strong>InputConnection</strong> 是IME和正在接收输入的沟通管道。</p>
</li>
<li><p>调用 <strong>super.onCreateInputConnection()</strong> 保留了内建的行为(包括发送和接收文本)，并提供给我们一个 <strong>InputConnection</strong> 的引用。</p>
</li>
<li><p><strong>setContentMimeTypes()</strong> 向 <strong>EditorInfo</strong> 添加了一个所支持的MIME类型的列表。 需要保证在 <strong>setContentMimeTypes()</strong> 之前调用 <strong>super.onCreateInputConnection()</strong> 。</p>
</li>
<li><p>回调在IME提交内容是被执行。 <strong>onCommitContent()</strong> 方法有一个对包含了内容URI的 <strong>InputContentInfoCompat</strong> 的引用。</p>
<ul>
<li>当我们的应用运行在API Level 25或者更高并且IME设置了 <strong>INPUT_CONTENT_GRANT_READ_URI_PERMISSION</strong> flag时，我们应该请求并且释放权限。否则，我们应该在此之前就拥有content URI的访问权限，一是因为权限是由IME授权的，二是content provider不对访问进行约束。更多的信息可以访问<a href="https://developer.android.com/guide/topics/text/image-keyboard.html#adding_image_support_to_imes" target="_blank" rel="external">Adding Image Support to IMEs</a></li>
</ul>
</li>
<li><p><strong>createWrapper()</strong> 包装了inputConnection和已修改的editorInfo，新的InputConnection的回调并且返回。</p>
</li>
</ul>
<p>下面是一些实践小技巧。</p>
<ul>
<li><p>不支持rich content的Editor不应该调用 <strong>setContentTypes()</strong> 并把 <strong>EditorInfo.contentMimeTypes</strong> 设置为null。</p>
</li>
<li><p>Editor应该忽略掉在 <strong>InputConnectionInfo</strong> 中指定的MIME类型和所接收类型不通的内容。</p>
</li>
<li><p>rich content不影响也不被文本指针的位置所影响。editor在进行内容处理是可以直接忽略掉光标的位置。</p>
</li>
<li><p>在editor的 <strong>OnCommitContentListener.onCommitContent()</strong> 方法中，我们可以异步的返回true，甚至是在加载内容之前。</p>
</li>
<li><p>不同于文本内容在被提交之前可以在IME中被编辑，rich content会被立即提交。需要注意特性，如果想要提供编辑或者删除内容的能力，我们需要自己提供处理逻辑。</p>
</li>
</ul>
<p>为了测试APP，需要确保你的设备或者虚拟机的键盘能够发送rich content。你可以在Android 7.1或者更高的系统中使用Google Keyboard，或者是安装<a href="https://developer.android.com/samples/CommitContentSampleIME/index.html" target="_blank" rel="external">CommitContent IME sample</a>.</p>
<p>你可以在<a href="https://developer.android.com/samples/CommitContentSampleApp/index.html" target="_blank" rel="external">CommitContent App sample</a>获取到完整的示例代码。</p>
<h4 id="Adding-Image-Support-to-IMEs"><a href="#Adding-Image-Support-to-IMEs" class="headerlink" title="Adding Image Support to IMEs"></a>Adding Image Support to IMEs</h4><p>想要IME支持发送rich content，需要引入下面所展示的Commit Content API。</p>
<ul>
<li><p>复写 <strong>onStartInput()</strong> 或者 <strong>onStartInputView()</strong> ，并读取来自目标editor的支持内容类型列表。</p>
<pre><code class="java">  @Override
  public void onStartInputView(EditorInfo info, boolean restarting) {
      String[] mimeTypes = EditorInfoCompat.getContentMimeTypes(editorInfo);

      boolean gifSupported = false;
      for (String mimeType : mimeTypes) {
          if (ClipDescription.compareMimeTypes(mimeType, &quot;image/gif&quot;)) {
              gifSupported = true;
          }
      }

      if (gifSupported) {
          // the target editor supports GIFs. enable corresponding content
      } else {
          // the target editor does not support GIFs. disable corresponding content
      }
  }
</code></pre>
</li>
<li><p>当用户选择了一张图片时，将内容提交给APP。当IME有正在编辑的文本时，应该避免调用 <strong>commitContent()</strong> ，因为这样可能导致editor失去焦点。下面的代码片段展示了怎样提交一张GIF图片。</p>
<pre><code class="java">  /**
   * Commits a GIF image
   *
   * @param contentUri Content URI of the GIF image to be sent
   * @param imageDescription Description of the GIF image to be sent
   */
  public static void commitGifImage(Uri contentUri, String imageDescription) {
      InputContentInfoCompat inputContentInfo = new InputContentInfoCompat(
              contentUri,
              new ClipDescription(imageDescription, new String[]{&quot;image/gif&quot;}));
      InputConnection inputConnection = getCurrentInputConnection();
      EditorInfo editorInfo = getCurrentInputEditorInfo();
      Int flags = 0;
      If (android.os.Build.VERSION.SDK_INT &gt;= 25) {
          flags |= InputConnectionCompat.INPUT_CONTENT_GRANT_READ_URI_PERMISSION;
      }
      InputConnectionCompat.commitContent(
              inputConnection, editorInfo, inputContentInfo, flags, opts);
  }
</code></pre>
</li>
<li><p>作为一个IME开发者，有很大可能你需要引入你自己的content provider来响应content URI请求。如果你的IME支持来自像 <strong>MediaStore</strong> 这样已经存在的content provider倒是可以例外。关于创建content provider的更多信息，可以参见 <a href="https://developer.android.com/samples/CommitContentSampleIME/index.html" target="_blank" rel="external">CommitContent IME sample</a>, [Content Provider] (<a href="https://developer.android.com/guide%20/topics/providers/content-providers.html)文档" target="_blank" rel="external">https://developer.android.com/guide%20/topics/providers/content-providers.html)文档</a>, <a href="https://developer.android.com/training/secure-file-sharing/setup-sharing.html" target="_blank" rel="external">File Provider</a>文档。</p>
</li>
<li><p>如果正在创建自己的content provider，建议不要export(将 android:export 设置为false)。通过设置 <strong>android:grandUriPermission</strong> 为true允许在provider内部进行权限授予替代。然后，你的IME在内容提交时可以授予访问content URI的权限。有两种实现的方法：</p>
<ul>
<li><p>在Android 7.1(API Level 25)或更高的系统中，当调用 <strong>commitContent</strong> 方法时，将flag参数设置为 <strong>INPUT_CONTENT_GRANT_READ_URI_PERMISSION</strong> 。然后，APP收到的 <strong>InputContentInfo</strong> 对象可以通过调用 <strong>requestPermission()</strong> 方法和 <strong>releasePermission()</strong> 请求和释放临时访问权限。</p>
</li>
<li><p>在Android 7.0(API Level 24)或者更低的系统中， <strong>INPUT_CONTENT_GRANT_READ_URI_PERMISSION</strong> 直接被忽略，所以我们需要手动的授予内容访问权限。方法就是 <strong>grantUriPermission()</strong> ,但是我们也可以引入满足自己要求的机制。</p>
</li>
</ul>
</li>
</ul>
<p>权限授予的例子，我们可以在<a href="https://developer.android.com/samples/CommitContentSampleIME/index.html" target="_blank" rel="external">CommitContent IME sample</a>中的doCommitContent()方法。</p>
<p>为了测试IME，确保我们的设备或者模拟器拥有接收rich content的的应用。我们可以在Android 7.1或者更高的系统中使用Google Messenger应用或者安装<a href="https://developer.android.com/samples/CommitContentSampleApp/index.html" target="_blank" rel="external">CommitContent App Sample</a>。</p>
<p>获取完整的示例代码，可以访问<a href="https://developer.android.com/samples/CommitContentSampleIME/index.html" target="_blank" rel="external">CommitContent IME Sample</a>。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Google在刷新版本号的路上简直是在策马奔腾了，嘚儿驾。我们也能够看到Google的努力，Android也在变的越来越好，加油吧，小机器人。</p>
<p>本次Shortcuts部分的代码可以在我的GitHub仓库<a href="https://github.com/TonnyL/ZhiHuDaily" target="_blank" rel="external">ZhiHuDaily</a>中看到。欢迎star哟。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JAVA深克隆与浅克隆]]></title>
      <url>http://tonnyl.github.io/2016/11/05/JAVA%E6%B7%B1%E5%85%8B%E9%9A%86%E4%B8%8E%E6%B5%85%E5%85%8B%E9%9A%86/</url>
      <content type="html"><![CDATA[<p>使用克隆可以快速构造一个和已有对象相同的副本</p>
<a id="more"></a>
<p>所有的Java类都继承自java.lang.Object,而Object类提供了一个clone方法，可以将一个Java对象复制一份。需要注意的是能够实现克隆的Java类必须实现一个标示接口Cloneable，表示这个Java类支持复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。</p>
<h3 id="什么是浅克隆和深克隆"><a href="#什么是浅克隆和深克隆" class="headerlink" title="什么是浅克隆和深克隆"></a>什么是浅克隆和深克隆</h3><p>通常情况下，一个类包含一些成员对象，在克隆对象时，根据其成员对象是否也克隆，克隆分为两种形式：深克隆和浅克隆。</p>
<h4 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h4><p>在浅克隆中，被复制对象的所有普通成员变量都具有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅克隆仅仅复制所考虑的对象，而不复制它所引用的成员对象，也就是其中的成员对象并不复制。在浅克隆中，当对象被复制时它所包含的成员对象却没有被复制。</p>
<img src="/2016/11/05/JAVA深克隆与浅克隆/shadow_copy.png" alt="浅克隆" title="浅克隆">
<p>图中obj1为原型对象，obj2为复制后的对象，containedObj1和containedObj2为成员对象。</p>
<h4 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h4><p>在深克隆中被复制对象的所有普通成员变量也都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过来的新对象，而不再是原有的那些被引用的对象。换言之，深克隆把要复制的对象所引用的对象都复制了一遍。在深克隆中，除了对象本身被复制外，对象包含的引用也被复制，也就是其中的成员对象也被复制。</p>
<img src="/2016/11/05/JAVA深克隆与浅克隆/deep_copy.png" alt="深克隆" title="深克隆">
<h3 id="Java中clone-方法解析"><a href="#Java中clone-方法解析" class="headerlink" title="Java中clone()方法解析"></a>Java中clone()方法解析</h3><p>Java语言提供的clone()方法将对象复制了一份并返回给调用者。一般而言,clone()方法满足：</p>
<ol>
<li>对任何的对象x，都有x.clone() != x，即克隆对象与原对象不是同一个对象。</li>
<li>对任何对对象x，都有x.clone().getClass() == x.getClass()，即克隆对象与原对象的类型一样。</li>
<li>如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</li>
</ol>
<p>为了获取对象的一份拷贝，我们可以利用Object类的clone()方法，具体步骤如下：</p>
<ol>
<li>在派生类中覆盖基类的clone()方法，并声明为public。</li>
<li>在派生类的clone()方法中，调用super.clone()。</li>
<li>在派生类中实现Cloneable接口。</li>
</ol>
<p>在Java中，通过覆盖Object类的clone()方法可以实现浅克隆，如果需要实现深克隆，可以通过序列化等方式实现。</p>
<p>序列化(Serialization)就是将对象写到流的过程，写到流中的对象是原对象的一个拷贝，而原对象仍然存在与内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，从而实现克隆。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。</p>
<p>Java提供的Cloneable接口和Serializable接口其代码都非常简单，它们是空接口，这种空接口也称为标示接口，标示接口中没有任何方法定义，其作用就是告诉JRE这些接口的实现类是否具有某个功能，如是否支持克隆，是否支持序列化等。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面通过两个实例分别实现浅克隆和深克隆。</p>
<h4 id="邮件浅克隆"><a href="#邮件浅克隆" class="headerlink" title="邮件浅克隆"></a>邮件浅克隆</h4><p>1.实例说明</p>
<p>由于邮件对象包含的内容较多(如发送者、接收者、标题、内容、主题、日期、附件等)，某系统现需要提供一个邮件复制功能，对于已经创建好的邮件对象，可以通过复制的方式创建一个新的邮件对象，如果要修改某部分内容，无须修改原始的邮件对象，只需要修改复制得到的邮件对象即可。在本实例中使用浅克隆实现邮件复制，复制邮件(E_mail)的同时不复制附件(Attachment)。</p>
<p>2.实例类图</p>
<img src="/2016/11/05/JAVA深克隆与浅克隆/shadow_clone_class_diagram.png" alt="浅克隆类图" title="浅克隆类图">
<p>3.实例代码及解释</p>
<p>(1) 抽象原型类Object</p>
<pre><code class="Java">package java.lang
    ...
    protected native Object clone() throws CloneNotSupportedExceptioni;
    ...
</code></pre>
<p>Object作为抽象原型类，在Java中，所有的类都是Object的子类，在Object中提供克隆方法clone()，用于创建一个原型对象，其clone()方法具体实现由JVM完成，用户使用时无须关心。</p>
<p>(2) 具体原型类Email(邮件类)</p>
<pre><code class="Java">public class Email implements Cloneable {

    private Attachment attachment = null;

    public Email() {
        this.attachment = new Attachment();
    }

    public Object clone() {
        Email clone = null;
        try {
            clone = (Email) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return  clone;
    }

    public Attachment getAttachment() {
        return this.attachment;
    }

    public void display() {
        System.out.println(&quot;查看邮件&quot;);
    }

}
</code></pre>
<p>Email类是具体原型类，也是Object类的子类，在Java中，只有实现了Cloneable接口的类才能使用clone()方法来进行复制，因此Email类实现了Cloneable接口。在Email类中覆盖了Object的clone()方法，功过直接或间接调用Object的clone()方法返回一个克隆的原型对象。在Email类中定义了一个成员对象attachment，类型为Attachment。</p>
<p>4.辅助代码</p>
<p>(1) 附件类Attachment</p>
<pre><code class="Java">public class Attachment {

    public void download() {
        System.out.println(&quot;下载附件&quot;);
    }

}
</code></pre>
<p>为了更好的说明深克隆和浅克隆的区别，在本实例中引入了附件类Attachment,邮件类Email与附件类是组合关联关系，在邮件类中定义一个附件类对象作为其成员对象。</p>
<p>(2) 客户端测试类Client</p>
<pre><code class="Java">public class Client {

    public static void main(String[] args) {
        Email email, copyEmail;
        email = new Email();
        copyEmail = (Email) email.clone();

        System.out.println(&quot;email == copyEmail?&quot;);
        System.out.println(email == copyEmail);

        System.out.println(&quot;email.getAttachment == copyEmail.getAttachment?&quot;);
        System.out.println(email.getAttachment() == copyEmail.getAttachment());

    }

}
</code></pre>
<p>在Client客户端测试类中，比较原型对象和复制对象是否一致，并比较其成员对象attachment的引用是否一致。</p>
<p>5.结果分析</p>
<p>编译并运行客户端测试类，输出结果如下：</p>
<pre><code>email == copyEmail?
false
email.getAttachment == copyEmail.getAttachment?
true
</code></pre><h4 id="邮件深克隆"><a href="#邮件深克隆" class="headerlink" title="邮件深克隆"></a>邮件深克隆</h4><p>1.实例说明</p>
<p>使用深克隆实现邮件复制，即复制邮件的同时复制附件。</p>
<p>2.实例类图</p>
<img src="/2016/11/05/JAVA深克隆与浅克隆/deep_clone_class_diagram.png" alt="深克隆类图" title="深克隆类图">
<p>3.实例代码与解释</p>
<pre><code class="Java">import java.io.*;

public class Email implements Serializable {

    private Attachment attachment = null;

    public Email() {
        this.attachment = new Attachment();
    }

    public Object deepClone() throws IOException, ClassNotFoundException, OptionalDataException {

        // 将对象写入流中
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(this);

        // 将对象从流中读出
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);

        return ois.readObject();

    }

    public Attachment getAttachment() {
        return this.attachment;
    }

    public void display() {
        System.out.println(&quot;查看邮件&quot;);
    }

}
</code></pre>
<p>Email作为具体原型类，由于实现的是深克隆，无须使用Object的clone()方法，因此无须实现Cloneable接口；通过序列化的方式实现深克隆，由于要将Email类型的对象写入流中，因此Email类需要实现Serializiable接口。</p>
<p>4.辅助代码</p>
<p>(1)附件类</p>
<pre><code class="Java">import java.io.Serializable;

public class Attachment implements Serializable {

    public void download() {
        System.out.println(&quot;下载附件&quot;);
    }

}
</code></pre>
<p>作为Email类的对象成员，在深克隆中，Attachment类型的对象也将被写入流中，因此Attachment类也需要实现Serializiable接口。</p>
<p>(2)客户端测试类Client</p>
<pre><code class="Java">public class Client {

    public static void main(String[] args) {
        Email email, copyEmail = null;
        email = new Email();

        try {
            copyEmail = (Email) email.deepClone();
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println(&quot;email == copyEmail?&quot;);
        System.out.println(email == copyEmail);

        System.out.println(&quot;email.getAttachment == copyEmail.getAttachment?&quot;);
        System.out.println(email.getAttachment() == copyEmail.getAttachment());

    }

}
</code></pre>
<p>5.结果及分析</p>
<p>编译运行客户端测试类，结果如下：</p>
<pre><code>email == copyEmail?
false
email.getAttachment == copyEmail.getAttachment?
false
</code></pre><p>通过结果可以看出，表达式(email == copyEmail)结果为false，即通过复制得到的对象与原型对象的引用不一致，表达式(email.getAttachment() == copyEmail.getAttachment())结果为false，原型对象与克隆对象成员对象的引用不相同，说明其成员对象也复制了一份。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[macOS安装gcc教程]]></title>
      <url>http://tonnyl.github.io/2016/10/31/macOS%E5%AE%89%E8%A3%85gcc%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>简单几步就可以在mac上成功安装gcc<br><a id="more"></a></p>
<p>网上的教程大多是通过安装Xcode实现安装gcc的，这种方式的花费有点太得不偿失，Xcode占据的空间是在太大，这对于128g用户简直就是噩梦。</p>
<p>还有就是通过homebrew安装，前提是你电脑上要安装了homebrew。</p>
<p>这里介绍一种简单的方法。</p>
<p>1.到<a href="https://sourceforge.net/projects/hpc/files/hpc/gcc/" target="_blank" rel="external">这里</a>下载所需要的的gcc压缩包。<br><img src="/2016/10/31/macOS安装gcc教程/website.png" alt="下载地址" title="下载地址"></p>
<p>2.下载完成后，通过terminal进入下载目录，即gcc-4.8-bin.tar.gz所在的目录。输入命令：</p>
<pre><code>gunzip gcc-4.8-bin.tar.gz
</code></pre><p>解压gcc-4.8-bin.tar.gz压缩包，注意只需要解压一次，在同一目录下得到gcc-4.8-bin.tar文件。</p>
<p>3.继续在terminal中输入命令：</p>
<pre><code>sudo tar -xvf gcc-4.8-bin.tar
</code></pre><p>输入密码后，自动在当前目录下生成了usr目录。cd /user/local/bin就可以看到所有的gcc相关的命令了。当然你也可以将整个目录移动到你需要的目录。<br><img src="/2016/10/31/macOS安装gcc教程/directory.png" alt="解压后的目录" title="解压后的目录"></p>
<p>4.添加gcc路径。关掉当前terminal，重新新建一个terminal。输入如下命令：<code>touch ～/.bash_profile</code>新建一个bash_profile文件，使用vi或者其他编辑器写入如下代码：<code>export PATH=&quot;/Users/lizhaotailang/Gcc/usr/local/bin:$PATH&quot;</code>,当然这是我的路径，具体的路径根据你的实际情况而定。写入完成后关闭文件。为了使文件生效，还需要在terminal输入<code>source ～／.bash_profile</code>。</p>
<p>5.查看是否生效。在terminal中输入：<code>echo $PATH</code>,如果能够在输出中看到刚刚添加的路径就说明添加成功了。或者直接输入gcc命令，如果能够看到gcc的clang错误而不是找不到文件的话，就说明配置成功了。<br><img src="/2016/10/31/macOS安装gcc教程/terminal.png" alt="路径配置" title="路径配置"></p>
<p>6.然后就可以愉快的使用gcc了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Studio新建Library并上传到JCenter]]></title>
      <url>http://tonnyl.github.io/2016/10/21/Android-Studio%E6%96%B0%E5%BB%BALibrary%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%88%B0JCenter/</url>
      <content type="html"><![CDATA[<p>简单实用的教程，教你如何一步一步从新建Library到上传至JCenter<br><a id="more"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在开发app的过程中，我们经常会遇到需要使用第三方库的情况，例如常用的<a href="https://github.com/square/okhttp" target="_blank" rel="external">Okhttp</a>，只需要添加一行代码到app下到gradle文件中就可以实现。</p>
<pre><code>compile &#39;com.squareup.okhttp3:okhttp:3.4.1&#39;
</code></pre><p>这种方式使用的就是squareup上传到JCenter的Library。那么这种方式是如何实现的呢？</p>
<h3 id="Maven与JCenter"><a href="#Maven与JCenter" class="headerlink" title="Maven与JCenter"></a>Maven与JCenter</h3><p>JCenter是由<a href="https://bintray.com/" target="_blank" rel="external">bintray.com</a>维护的Maven库。在项目的根目录下的build.gradle文件中定义如下，就可以使用JCenter了。</p>
<pre><code>allprojects {
    repositories {
        jcenter()
    }
}
</code></pre><p>Maven Central<br>Maven是由<a href="https://sonatype.org/" target="_blank" rel="external">sonatype.org</a>维护的Maven仓库。<br>在使用一些开源库的时候可能会要求你在根目录下的build.gradle文件中添加如下代码：</p>
<pre><code>allprojects {
    repositories {
        mavenCentral()
    }
}
</code></pre><p>这样就能使用mavenCentral了。</p>
<p>这两者是什么关系呢？</p>
<p>啊哈哈哈哈，没有关系（知道真相的我表情是这样的：你tm在逗我.jpg）。都是Maven仓库，只是存放的地方不一样罢了。在较老版本的Android Studio中，默认使用的是 Maven Central，不过由于它对开发者不那么的友好，后来就默认使用JCenter了。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="1-注册bintray帐号"><a href="#1-注册bintray帐号" class="headerlink" title="1. 注册bintray帐号"></a>1. 注册bintray帐号</h4><p>这是当然了，要在人家的平台上发布Library当然首先得有一个帐号了。你可以创建一个全新的，也可以直接使用GitHub登录。</p>
<p>传送门—&gt;<a href="https://bintray.com/" target="_blank" rel="external">bintray官方网站</a></p>
<p>注册成功后就能看到酱的页面了。</p>
<img src="/2016/10/21/Android-Studio新建Library并上传到JCenter/bintray_personal_centre.png" alt="bintray个人中心" title="bintray个人中心">
<h4 id="2-创建新的仓库"><a href="#2-创建新的仓库" class="headerlink" title="2. 创建新的仓库"></a>2. 创建新的仓库</h4><p>点击Add New Repository, 创建一个新的仓库，type选择Maven。</p>
<img src="/2016/10/21/Android-Studio新建Library并上传到JCenter/bintray_create_new_repository.png" alt="创建新的仓库" title="创建新的仓库">
<h4 id="3-创建package"><a href="#3-创建package" class="headerlink" title="3. 创建package"></a>3. 创建package</h4><p>仓库创建成功之后就可以添加包了。进入仓库详情页，点击右下角，Add New Package。</p>
<img src="/2016/10/21/Android-Studio新建Library并上传到JCenter/bintray_add_new_package.png" alt="创建package" title="创建package">
<img src="/2016/10/21/Android-Studio新建Library并上传到JCenter/bintray_add_new_package1.png" alt="创建package" title="创建package">
<p>到这里，准备工作就完成了，现在要开始写代码了。</p>
<h3 id="创建Library"><a href="#创建Library" class="headerlink" title="创建Library"></a>创建Library</h3><ol>
<li><p>新建一个Android Project，这里和我们平时创建工程是一样的。</p>
</li>
<li><p>在项目根文件夹点击鼠标右键，new -&gt; module -&gt; Android Library。</p>
</li>
</ol>
<img src="/2016/10/21/Android-Studio新建Library并上传到JCenter/AndroidStudio_create_new_module.png" alt="创建Library" title="创建Library">
<p>创建成功后，项目结构如下所示。</p>
<img src="/2016/10/21/Android-Studio新建Library并上传到JCenter/AndroidStudio_project_structure.png" alt="项目结构" title="项目结构">
<ol>
<li>现在就可以在库目录(我这里是CircleProgressBar)下编写代码了。</li>
</ol>
<h3 id="打包文件"><a href="#打包文件" class="headerlink" title="打包文件"></a>打包文件</h3><p>之前看的教程都是通过配置炒鸡复杂(好吧，可能是我太菜了，配置了很久都没有成功…)的build.gradle的方法来实现的。这里介绍一种炒鸡炒鸡简单的方法。</p>
<p>1.找到Library下的build.gradle文件，添加如下代码：</p>
<pre><code>ext {
    PUBLISH_GROUP_ID = &#39;io.github.marktony&#39;
    PUBLISH_ARTIFACT_ID = &#39;circle-progress-bar&#39;
    PUBLISH_VERSION = &#39;1.1&#39;
}
</code></pre><p>文件末尾添加</p>
<pre><code>apply from: &#39;https://raw.githubusercontent.com/blundell/release-android-library/master/android-release-aar.gradle&#39;
</code></pre><img src="/2016/10/21/Android-Studio新建Library并上传到JCenter/AndroidStudio_set_gradle.png" alt="配置gradle文件" title="配置gradle文件">
<table>
<thead>
<tr>
<th>配置项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PUBLISH_GROUP_ID</td>
<td>开发者名称</td>
</tr>
<tr>
<td>PUBLISH_ARTIFACT_ID</td>
<td>项目名称</td>
</tr>
<tr>
<td>PUBLISH_VERSION</td>
<td>版本</td>
</tr>
</tbody>
</table>
<p>对比compile地址，可以很方便的理解：</p>
<pre><code>compile &#39;io.github.marktony:circle-progress-bar:1.1&#39;
</code></pre><p>2.打包<br>在Android Studio的terminal中执行：</p>
<p>Windows:</p>
<pre><code>gradlew clean build generateRelease
</code></pre><p>MacOS:</p>
<pre><code>./gradlew clean build generateRelease
</code></pre><p>经过一系列的下载＋各种编译之后(第一次编译的话，建议你吃个饭或者结个婚生个娃什么的再回来(笑，大概30分钟左右)，时间比较长，要下载文件超级多，不知道是不是只有我一个人是这样。以后再编译就炒鸡快了。)就会提示你BUILD SUCCESS,还有zip包的存放路径，找到这个zip，后面会用到。</p>
<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>回到之前bintray的网站，进入package的详情，就会看到下面的界面。</p>
<img src="/2016/10/21/Android-Studio新建Library并上传到JCenter/bintray_package_detail.png" alt="package详情" title="package详情">
<p>点击version，新建一个版本。完成后点击刚刚新建的版本，点击Upload Files，上传之前生成的zip文件，注意要选中exploding the archive选项。</p>
<p>点击Save Changes，就会有提示你是否发布，点击发布就好了。</p>
<p>如何发布到JCenter呢？</p>
<p>回到package，看到右下角Add to JCenter，点击就可以申请发布到JCenter了。</p>
<img src="/2016/10/21/Android-Studio新建Library并上传到JCenter/bintray_add_to_jcenter.png" alt="添加到JCenter" title="添加到JCenter">
<p>后面就是等待审核，一般等待几个小时就会审核通过了。</p>
<p>如果你想要让别人知道你的compile地址，可以在General栏目下分别看到Maven和Gradle的地址了。</p>
<img src="/2016/10/21/Android-Studio新建Library并上传到JCenter/bintray_compile_addr_maven.png" alt="Maven地址" title="Maven地址">
<img src="/2016/10/21/Android-Studio新建Library并上传到JCenter/bintray_compile_addr_gradle.png" alt="Gradle" title="Gradle">
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在我看来，通过上述方法实现上传Library到JCenter的方法相较于配置复杂gradle文件的方式要简便许多，但同时使用这种方式也就意味这每次有了新的版本都要手动上传，不能通过terminal直接上传。</p>
<p>如果你对我对CirlceProgressBar项目感兴趣或者对配置文件有不解对地方，可以参考源代码</p>
<p><a href="https://github.com/marktony/CircleProgressBar" target="_blank" rel="external">https://github.com/marktony/CircleProgressBar</a></p>
<p>项目比较简单，里面也有详细的介绍，如果你觉得有用的话就给个star吧，当然页欢迎你看一看我对其他项目哦。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[重构！将Google MVP应用于已有项目]]></title>
      <url>http://tonnyl.github.io/2016/09/27/%E9%87%8D%E6%9E%84%EF%BC%81%E5%B0%86Google-MVP%E5%BA%94%E7%94%A8%E4%BA%8E%E5%B7%B2%E6%9C%89%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<p>将Google官方的Android MVP架构引入到已有的项目中。<br><a id="more"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在本次项目重构之前，我的项目采用的是什么架构呢？</p>
<p>额，没有架构…或者说，不那么标准的MVC，一个页面就是一个Activity或者Fragment，各种数据，网络请求，响应都写在Activity或者Fragment–这两个不怎么标准的Controller中，代码混乱，而且长长长长长长，写代码的时候一时爽，到了维护阶段，那酸爽，不敢相信。采用新的架构迫在眉睫。</p>
<p>事实上，已经有很多的App项目采用了MVP或者MVVM等架构。由于并没有那么权威的实现，很多开发者也陷入了选择困难症，在各种架构直接摇摆不定，找不到适合自己项目架构。而Google也适时的推出了一系列官方示例用于参考。</p>
<h3 id="Google示例项目"><a href="#Google示例项目" class="headerlink" title="Google示例项目"></a>Google示例项目</h3><blockquote>
<p><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">Android Architecture Blueprints [beta]</a></p>
</blockquote>
<p>示例项目以一个TODO APP为例，目前仍然在进行中。本次项目重构采用的是基础版 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">todo-mvp</a></p>
<p>示例项目的代码组织方式和我之前以adapter, activity, fragment等组织方式不同，采用的是按照功能划分，一种功能就是一个包，包内文件以xxxactivity, xxxfragment, xxxcontract, xxxpresenter命名，xxx代表着所要实现的功能。本次项目重构两种方式均有采用。</p>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>首先是仿照TODO MVP，建立两个Base接口，BaseView和BasePresenter，这两个基本接口是所有的View和Presenter的基类。</p>
<pre><code class="Java">public interface BasePresenter {

    void start();

}
</code></pre>
<p>BasePresenter中有方法start()，作用是Presenter开始获取数据并改变界面显示，调用时机为Fragment的onResume()方法中。</p>
<pre><code class="Java">public interface BaseView&lt;T&gt; {

    void setPresenter(T presenter);

    void initViews(View view);

}
</code></pre>
<p>BaseView中有方法setPresenter(),将Presenter示例传入view，调用时机为Presenter实现类的构造方法中，initViews()传入View实例，用于初始化界面元素，调用时机为Fragment的onCreate()方法中。</p>
<p>接着创建契约类，用于统一管理View和Presenter的所有接口。这里以知乎日报的部分为例。</p>
<pre><code class="Java">public interface ZhihuDailyContract {

    interface View extends BaseView&lt;Presenter&gt; {

        void showError();

        void showLoading();

        void stopLoading();

        void showResults(ArrayList&lt;ZhihuDailyNews.Question&gt; list);

        void showNetworkError();

    }

    interface Presenter extends BasePresenter {

        void loadPosts(long date, boolean clearing);

        void refresh();

        void loadMore(long date);

        void startReading(int position);

        void goToSettings();

    }

}
</code></pre>
<p>然后创建相应的Activity，在官方的示例项目中，Activity是作为View和Presenter的桥梁使用，用于创建View和Presenter实例。本项目由于涉及了TabLayout和ViewPager的使用，所以创建View和Presenter的部分我放到了ViewPager的Adapter中实现。</p>
<pre><code class="Java">public class MainPagerAdapter extends FragmentPagerAdapter {

    private String[] titles;
    private final Context context;

    public MainPagerAdapter(FragmentManager fm, Context context) {
        super(fm);
        this.context = context;
        titles = context.getResources().getStringArray(R.array.page_titles);
    }

    @Override
    public Fragment getItem(int position) {
        if (position == 1){
            GuokrFragment fragment = GuokrFragment.newInstance();
            new GuokrPresenter(context, fragment);
            return fragment;
        } else if (position == 2){
            DoubanMomentFragment fragment = DoubanMomentFragment.newInstance();
            new DoubanMomentPresenter(context, fragment);
            return fragment;
        }
        ZhihuDailyFragment fragment = ZhihuDailyFragment.newInstance();
        new ZhihuDailyPresenter(context, fragment);
        return fragment;
    }

    @Override
    public int getCount() {
        return titles.length;
    }

    @Override
    public CharSequence getPageTitle(int position) {
        return titles[position];
    }

}
</code></pre>
<p>Fragment在示例项目中的角色为View的具体实现类。</p>
<pre><code class="Java">public class ZhihuDailyFragment extends Fragment
        implements ZhihuDailyContract.View{

    private RecyclerView recyclerView;
    private SwipeRefreshLayout refresh;
    private FloatingActionButton fab;

    private ZhihuDailyNewsAdapter adapter;

    private ZhihuDailyContract.Presenter presenter;

    public ZhihuDailyFragment() {

    }

    public static ZhihuDailyFragment newInstance() {
        return new ZhihuDailyFragment();
    }

    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
    }

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_douban_zhihu_daily,container,false);

        initViews(view);

        presenter.loadPosts(Calendar.getInstance().getTimeInMillis(), false);

        refresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {

            @Override
            public void onRefresh() {
                presenter.refresh();
            }

        });

        fab.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                ...
            }
        });

        return view;
    }


    @Override
    public void setPresenter(ZhihuDailyContract.Presenter presenter) {
        if (presenter != null) {
            this.presenter = presenter;
        }
    }

    @Override
    public void initViews(View view) {
        recyclerView = (RecyclerView) view.findViewById(R.id.rv_main);
        recyclerView.setLayoutManager(new LinearLayoutManager(getContext()));
        recyclerView.addItemDecoration(new DividerItemDecoration(getActivity(),LinearLayoutManager.VERTICAL));
        refresh = (SwipeRefreshLayout) view.findViewById(R.id.refresh);
        fab = (FloatingActionButton) view.findViewById(R.id.fab);
        fab.setRippleColor(getResources().getColor(R.color.colorPrimaryDark));

    }

    @Override
    public void showError() {
        Snackbar.make(fab, R.string.loaded_failed,Snackbar.LENGTH_SHORT).show();
    }

    @Override
    public void showLoading() {
        refresh.post(new Runnable() {
            @Override
            public void run() {
                refresh.setRefreshing(true);
            }
        });
    }

    @Override
    public void stopLoading() {
        refresh.post(new Runnable() {
            @Override
            public void run() {
                refresh.setRefreshing(false);
            }
        });
    }

    @Override
    public void showResults(ArrayList&lt;ZhihuDailyNews.Question&gt; list) {
        if (adapter == null) {
            adapter = new ZhihuDailyNewsAdapter(getContext(), list);
            adapter.setItemClickListener(new OnRecyclerViewOnClickListener() {
                @Override
                public void OnItemClick(View v, int position) {
                    presenter.startReading(position);
                }
            });
            recyclerView.setAdapter(adapter);
        } else {
            adapter.notifyDataSetChanged();
        }
    }

    @Override
    public void showNetworkError() {
        Snackbar.make(fab,R.string.no_network_connected,Snackbar.LENGTH_INDEFINITE)
                .setAction(R.string.go_to_set, new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        presenter.goToSettings();
                    }
                }).show();
    }

}
</code></pre>
<p>创建Presenter。</p>
<pre><code class="Java">public class ZhihuDailyPresenter implements ZhihuDailyContract.Presenter, OnStringListener {

    private ZhihuDailyContract.View view;
    private Context context;
    private StringModelImpl model;

    private ArrayList&lt;ZhihuDailyNews.Question&gt; list = new ArrayList&lt;ZhihuDailyNews.Question&gt;();

    public ZhihuDailyPresenter(Context context, ZhihuDailyContract.View view) {
        this.context = context;
        this.view = view;
        this.view.setPresenter(this);
        model = new StringModelImpl(context);
    }

    @Override
    public void loadPosts(long date, boolean clearing) {
        view.showLoading();
        if (clearing) {
            list.clear();
        }
        model.load(Api.ZHIHU_HISTORY + formatter.ZhihuDailyDateFormat(date), this);
    }

    @Override
    public void refresh() {
        list.clear();
        loadPosts(Calendar.getInstance().getTimeInMillis(), true);
    }

    @Override
    public void loadMore(long date) {
        if (NetworkState.networkConnected(context)) {
            model.load(Api.ZHIHU_HISTORY + formatter.ZhihuDailyDateFormat(date), this);
        } else {
            view.showNetworkError();
        }
    }

    @Override
    public void startReading(int position) {
        context.startActivity(new Intent(context, ZhihuDetailActivity.class)
                .putExtra(&quot;id&quot;,list.get(position).getId())
        );
    }

    @Override
    public void goToSettings() {
        context.startActivity(new Intent(Settings.ACTION_SETTINGS));
    }

    @Override
    public void start() {

    }

    @Override
    public void onSuccess(String result) {
        Gson gson = new Gson();
        ZhihuDailyNews post = gson.fromJson(result, ZhihuDailyNews.class);

        for (ZhihuDailyNews.Question item : post.getStories()) {
            list.add(item);
        }
        view.showResults(list);
        view.stopLoading();

    }

    @Override
    public void onError(VolleyError error) {
        view.stopLoading();
        view.showError();
    }

}
</code></pre>
<p>Presenter获取到了View，并通过调用setPresenter()方法将自身传入，如果需要对改变界面显示，直接调用View层的方法即可。这样Presenter就于View层实现了分离。</p>
<p>最后是Model层的实现。由于使用了Gson，数据的返回类型只需要为String类型即可。</p>
<pre><code class="Java">public interface OnStringListener {

    /**
     * 请求成功时回调
     * @param result
     */
    void onSuccess(String result);

    /**
     * 请求失败时回调
     * @param error
     */
    void onError(VolleyError error);

}
</code></pre>
<p>定义了两个方法，分别为请求成功时和请求失败时的回调。</p>
<p>然后需要一个StringModel的实现类–StringModelImpl。</p>
<pre><code class="Java">public class StringModelImpl {

    private Context context;

    public StringModelImpl(Context context) {
        this.context = context;
    }

    public void load(String url, final OnStringListener listener) {
        StringRequest request = new StringRequest(url, new Response.Listener&lt;String&gt;() {
            @Override
            public void onResponse(String s) {
                listener.onSuccess(s);
            }
        }, new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError volleyError) {
                listener.onError(volleyError);
            }
        });
        VolleySingleton.getVolleySingleton(context).addToRequestQueue(request);
    }

}
</code></pre>
<p>这样，Model, View, Presenter均已实现，实现了各个层次的分离。</p>
<p>采用MVP架构进行重构，代码量上相对于原项目时有所增加的，但这种数量的增加相对于MVP架构带来的好处是显而易见的。当然这是对于代码量比较大的项目而言，平时用于练手的小项目就没有必要强项目所难，勉强的实现MVP了，这样只会增加代码量而已。</p>
<h3 id="本项目地址"><a href="#本项目地址" class="headerlink" title="本项目地址"></a>本项目地址</h3><blockquote>
<p><a href="https://github.com/marktony/ZhihuDaily" target="_blank" rel="external">纸飞机-采用MVP架构，一款集合了知乎日报、果壳精选和豆瓣一刻的综合性阅读客户端</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的单例模式]]></title>
      <url>http://tonnyl.github.io/2016/07/19/Java%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h3><a id="more"></a>
<p>单例模式是一种对象创建模式，用于产生对象的一个具体实例，并且可以确保系统中一个类只能产生唯一的一个实例。</p>
<p>这样的方式能够带来两大好处：</p>
<ol>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，对于复制的对象，这样的创建方式的开销是十分值得的。</li>
<li>new的次数少了，对内存的使用频率也就下降了，当然也就减轻了GC的压力。</li>
</ol>
<h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>这种模式要解决的问题就是要保证应用中只存在一个对象。那怎样实现呢？</p>
<ol>
<li>不允许其他程序new对象</li>
<li>在该类中创建对象</li>
<li>对外需要暴露一个方法，让其他获取这个对象</li>
</ol>
<p>体现到代码中，解决办法为：</p>
<ol>
<li>私有化构造函数</li>
<li>在本类中创建一个本类对象</li>
<li>定义一个方法，能够让其他的类获取这个对象</li>
</ol>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>1.最简单的写法为</p>
<pre><code class="Java">public class Singleton {

    private Singleton(){}

    private static Singleton instance = new Singleton();

    public static Singleton getInstance(){
        return instance;
    }

}
</code></pre>
<p>这种方式称为饿汉式。</p>
<ul>
<li>优点<ul>
<li>简单明了</li>
<li>在类加载时即完成了实例化，避免了线程同步的问题</li>
</ul>
</li>
<li>缺点<ul>
<li>没有使用懒加载</li>
<li>可能造成内存浪费</li>
</ul>
</li>
</ul>
<p>2.变种方式</p>
<pre><code class="Java">public class Singleton {

    private static Singleton instance;

    private Singleton(){}

    static {
        instance = new Singleton();
    }

    public static Singleton getInstance(){
        return instance;
    }

}
</code></pre>
<p>相比于第一种写法，本类中将实例化对象的代码放到了static代码块中。两种方法的效果其实是一样的。所以优缺点也是一样的。</p>
<p>3.懒汉式(线程不安全)</p>
<pre><code class="Java">public class Singleton {  
    private static Singleton instance;    
    private Singleton (){}    
    public static Singleton getInstance() {    
    if (instance == null) {        
        instance = new Singleton();    
    }
        return instance;
    }
}
</code></pre>
<ul>
<li>优点<ul>
<li>使用了懒加载</li>
</ul>
</li>
<li>缺点<ul>
<li>当有多个线程并行调用 getInstance() 的时候，就会创建多个实    例。也就是说在多线程下不能正常工作。</li>
</ul>
</li>
</ul>
<p>4.懒汉式(线程安全)</p>
<pre><code class="Java">public class Singleton {  
    private static Singleton instance;    
    private Singleton (){}    
    public static synchronized Singleton getInstance(){    
      if (instance == null) {
           instance = new Singleton();    
      }
      return instance;
    }
}
</code></pre>
<ul>
<li>优点<ul>
<li>线程安全，解决了多实例问题</li>
</ul>
</li>
<li>缺点<ul>
<li>不高效。因为在任何时候只能有一个线程调用 getInstance() 方    法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。</li>
</ul>
</li>
</ul>
<p>5.双重校验锁</p>
<pre><code class="Java">public class Singleton {

    private static Singleton instance = null;

    private Singleton(){}

    public static Singleton getInstance(){
        if (instance == null){
            synchronized (Singleton.class){
                if (instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

}
</code></pre>
<p>进行两次if(instance == null)(Double-Check)的检查可以保证线程安全。</p>
<ul>
<li>优点<ul>
<li>并发度高，提升了性能。</li>
</ul>
</li>
<li>缺点<ul>
<li>并不是绝对安全</li>
</ul>
</li>
</ul>
<p>6.内部类</p>
<pre><code class="Java">public class Singleton{  

    private Singleton() {};  

    private static class SingletonHolder{  
        private static Singleton instance=new Singleton();  
    }   

    public static Singleton getInstance(){  
        return SingletonHolder.instance;  
    }

}
</code></pre>
<p>这是Google公司的工程师Bob Lee写的新的懒汉单例模式。</p>
<ul>
<li>优点<ul>
<li>使用JVM本身机制保证了线程安全问题</li>
<li>由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的。</li>
<li>同时读取实例的时候不会进行同步，没有性能缺陷。</li>
<li>不依赖jdk版本。</li>
</ul>
</li>
</ul>
<p>这种方式也是《Effective Java》推荐的写法。</p>
<p>7.枚举</p>
<pre><code class="java">public enum EasySingleton{
    INSTANCE;
}
</code></pre>
<ul>
<li>优点<ul>
<li>简单明了</li>
<li>调用简单，使用EasySingleton.INSTANCE访问实例，比getInstance()简单</li>
<li>创建枚举本身就是线程安全的，不用担心存在多个实例的问题</li>
</ul>
</li>
<li>缺点<ul>
<li>枚举类型enum在jdk1.5时才引入，所以这种方法并不适用于jdk1.5之前的版本</li>
</ul>
</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用多线程并发测试。</p>
<pre><code class="Java">public class SingletonPatternTest {

    public static void main(String[] args){

        CountDownLatch latch = new CountDownLatch(1);

        int threadCount = 1000;

        for (int i = 0; i &lt; threadCount; i++){
            new Thread(){
                @Override
                public void run() {
                    try {
                        // all thread to wait
                        latch.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    // test get instance
                    System.out.println(Singleton.getInstance().hashCode());
                }
            }.start();
        }

        // release lock, let all thread excute Singleton.getInstance() at the same time
        latch.countDown();

    }

}
</code></pre>
<p>其中CountDownLatch latch为闭锁，所有线程中都用latch.await();等待锁释放，待所有线程初始化完成使用latch.countDown();释放锁，从而达到线程并发执行Singleton.getInstance()的效果。</p>
<p>结果为：</p>
<pre><code>2016228077
2016228077
2016228077
2016228077
...
</code></pre><p>Reference:</p>
<p><a href="http://blog.csdn.net/dmk877/article/details/50311791" target="_blank" rel="external">http://blog.csdn.net/dmk877/article/details/50311791</a></p>
<p><a href="http://www.trinea.cn/java/singleton/" target="_blank" rel="external">http://www.trinea.cn/java/singleton/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Get start with Kotlin on Android]]></title>
      <url>http://tonnyl.github.io/2016/07/10/Get-start-with-Kotlin-on-Android/</url>
      <content type="html"><![CDATA[<p>本篇文章主要介绍怎样入门用Kotlin开发Android项目。示例项目地址为：<a href="https://github.com/marktony/FanfouHandpick" target="_blank" rel="external">GitHub:饭否精选</a></p>
<h3 id="什么是Kotlin？"><a href="#什么是Kotlin？" class="headerlink" title="什么是Kotlin？"></a>什么是Kotlin？</h3><p>Kotlin是由<a href="https://www.jetbrains.com/" target="_blank" rel="external">JetBrains</a>开发，基于JVM的一门新的编程语言。开发过Android的童鞋应该都知道Android Studio，它就是基于Intellij IDEA开发的，而Intellij IDEA正是由JetBrains出品。</p>
<p>对于Android开发者而言，Kotlin有两个有趣的特点：</p>
<ul>
<li>对于Java熟悉的开发者，上手Kotlin会很快，因为Kotlin非常直觉化。</li>
<li>强大的IDE支持。</li>
</ul>
<p>相比于Java7,Kotlin的优势在于：</p>
<ul>
<li>易于表现。能实实在在的少写很多代码。</li>
<li>类型安全。我们在Java中经常要防止产生<strong>NullPointerException</strong>，而使用Kotlin是空安全的。我们可以节约很多调试空异常的时间。</li>
<li>函数式。Kotlin是面向对象的语言，但是她使用很多函数式编程的概念。例如lambda表达式。</li>
<li>扩展函数。我们可以扩展类更多的特性。</li>
<li>与Java的完美互操作。我们甚至在一个项目中使用Kotlin和Java两种语言混合编程。</li>
</ul>
<h3 id="在Android项目中使用Kotlin"><a href="#在Android项目中使用Kotlin" class="headerlink" title="在Android项目中使用Kotlin"></a>在Android项目中使用Kotlin</h3><p>首先当然是要配置开发环境了。从Intellij 15开始，Kotlin插件是默认安装的。但是Android Studio中可能就要我们手动配置了。</p>
<p>打开 <strong>Android Studio</strong> 进入 <strong>Preferences</strong> 的 <strong>plugin</strong> 栏，选择 <strong>Install JetBrains Plugin</strong>,在搜索框中输入 <strong>Kotlin</strong>,然后就能看到Kotlin插件了，点击安装即可。</p>
<p>环境配置好后，就可以动手写项目了。按照平时我们新建Android项目的步骤，新建一个项目。然后点击Android Studio的菜单 <strong>Code</strong> 的 <strong>Convert Java File to Kotlin File</strong>,java文件就自动的转换为了Kotlin文件。是不是很简单呢。</p>
<h3 id="印象"><a href="#印象" class="headerlink" title="印象"></a>印象</h3><p>我并没有用Kotlin进行Android开发的经验，这次的项目也主要是作为练手使用。给我的感觉就是省事儿，能减少很多不必要的代码。可以不用写很多的findViewById了。设置监听器也方便了很多了。<br>Talk is cheap, show you the code.</p>
<pre><code class="Kotlin">class MainActivity : AppCompatActivity() {

  override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        textView.text = &quot;Hello Kotlin&quot;

        textView.setOnClickListener {
          Snackbar.make(fab,&quot;Hello Snackbar&quot;,Snackbar.LENGTH_SHORT)
        }

  }

}
</code></pre>
<p>上手印象不错，以后有机会会尝试使用Kotlin！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Fragment生命周期探索]]></title>
      <url>http://tonnyl.github.io/2016/06/13/Fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%8E%A2%E7%B4%A2/</url>
      <content type="html"><![CDATA[<p>Fragment和Activity类似，也有自己的生命周期，并且fragment的生命周期和activity的生命周期特别相似。<br><a id="more"></a></p>
<p>Activity的生命周期由四种状态，运行、暂停、停止、和销毁，类似的，Fragment也有这四种状态，只是在一些细小的地方有所不同。</p>
<p>Fragment生命周期图(来自Android官网)</p>
<img src="/2016/06/13/Fragment生命周期探索/fragment_lifecycle.png" alt="fragment_lifecycle" title="fragment_lifecycle">
<p>下面直接通过工程来认识Fragment的生命周期</p>
<p>首先新建FragmentDemo工程。</p>
<p>MainActivity.java</p>
<pre><code class="java">
package com.marktony.fragmentdemo;

import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;

public class MainActivity extends AppCompatActivity {

    private Button btnAddFragment;

    private FragmentManager fragmentManager;
    private FragmentTransaction fragmentTransaction;

    public static final String TAG = &quot;MainActivity&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        initViews();

        initData();

        btnAddFragment.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                MyFragment fragment = new MyFragment();
                fragmentTransaction.replace(R.id.container,fragment);
                fragmentTransaction.commit();
            }
        });

        Log.d(TAG,&quot;onCreate&quot;);
    }

    private void initData() {

        fragmentManager = getSupportFragmentManager();
        fragmentTransaction = fragmentManager.beginTransaction();

    }

    private void initViews() {

        btnAddFragment = (Button) findViewById(R.id.btn_add_fragment);

    }
}
</code></pre>
<p>代码很简单，加载相应的布局，通过监听button的点击事件，加载fragment。</p>
<p>activity_main.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:id=&quot;@+id/container&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;
    android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
    android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
    android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;
    tools:context=&quot;com.marktony.fragmentdemo.MainActivity&quot;&gt;

    &lt;Button
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:id=&quot;@+id/btn_add_fragment&quot;
        android:text=&quot;add_fragment&quot;/&gt;

&lt;/RelativeLayout&gt;
</code></pre>
<p>MyFragment.java</p>
<pre><code class="java">package com.marktony.fragmentdemo;

import android.content.Context;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.support.v4.app.Fragment;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

/**
 * Created by lizhaotailang on 2016/6/13.
 */
public class MyFragment extends Fragment {

    public static final String TAG = &quot;MY_FRAGMENT&quot;;

    // empty constructor
    public MyFragment(){

    }

    @Override
    public void onAttach(Context context) {
        super.onAttach(context);

        Log.d(TAG,&quot;onAttach&quot;);
    }

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        Log.d(TAG,&quot;onCreate&quot;);
    }

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {

        Log.d(TAG,&quot;onCreateView&quot;);

        return inflater.inflate(R.layout.fragment_my,container,false);

    }

    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        Log.d(TAG,&quot;onActivityCreated&quot;);
    }

    @Override
    public void onStart() {
        super.onStart();

        Log.d(TAG,&quot;onStart&quot;);
    }

    @Override
    public void onResume() {
        super.onResume();

        Log.d(TAG,&quot;onResume&quot;);
    }

    @Override
    public void onPause() {
        super.onPause();

        Log.d(TAG,&quot;onPause&quot;);
    }

    @Override
    public void onStop() {
        super.onStop();

        Log.d(TAG,&quot;onStop&quot;);
    }

    @Override
    public void onDestroyView() {
        super.onDestroyView();

        Log.d(TAG,&quot;onDestroyView&quot;);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();

        Log.d(TAG,&quot;onDestroy&quot;);
    }

    @Override
    public void onDetach() {
        super.onDetach();

        Log.d(TAG,&quot;onDetach&quot;);
    }

}
</code></pre>
<p>MyFragment中复写了一些方法，每个方法被调用时打印日志。</p>
<p>ok，大功告成，现在就跑到手机上。</p>
<p>观察打印日志，可以看到:</p>
<pre><code>com.marktony.fragmentdemo D/MainActivity: onCreate
</code></pre><p>按下按钮时</p>
<pre><code>com.marktony.fragmentdemo D/MY_FRAGMENT: onAttach
com.marktony.fragmentdemo D/MY_FRAGMENT: onCreate
com.marktony.fragmentdemo D/MY_FRAGMENT: onCreateView
com.marktony.fragmentdemo D/MY_FRAGMENT: onActivityCreated
com.marktony.fragmentdemo D/MY_FRAGMENT: onStart
com.marktony.fragmentdemo D/MY_FRAGMENT: onResume
</code></pre><p>此时按下home键</p>
<pre><code>com.marktony.fragmentdemo D/MY_FRAGMENT: onPause
com.marktony.fragmentdemo D/MY_FRAGMENT: onStop
</code></pre><p>重新回到应用</p>
<pre><code>com.marktony.fragmentdemo D/MY_FRAGMENT: onStart
com.marktony.fragmentdemo D/MY_FRAGMENT: onResume
</code></pre><p>按下back键，此时fragment和activity均被销毁。</p>
<pre><code>com.marktony.fragmentdemo D/MY_FRAGMENT: onPause
com.marktony.fragmentdemo D/MY_FRAGMENT: onStop
com.marktony.fragmentdemo D/MY_FRAGMENT: onDestroyView
com.marktony.fragmentdemo D/MY_FRAGMENT: onDestroy
com.marktony.fragmentdemo D/MY_FRAGMENT: onDetach
</code></pre><p>观察日志，不难发现。</p>
<p>当fragment被创建时，会依次经历以下状态：</p>
<ul>
<li>onAttach()</li>
<li>onCreate()</li>
<li>onCreateView()</li>
<li>onActivityCreated()</li>
</ul>
<p>当fragment处于可见状态时，会经历</p>
<ul>
<li>onStart()</li>
<li>onResume()</li>
</ul>
<p>不可见时，经历了</p>
<ul>
<li>onPause()</li>
<li>onStop()</li>
</ul>
<p>当fragment被销毁时（或相应的activity被销毁时）</p>
<ul>
<li>onPause()</li>
<li>onStop()</li>
<li>onDestroyView()</li>
<li>onDestroy()</li>
<li>onDetach()</li>
</ul>
<p>由此可见，fragment的生命周期和activity的生命周期真的非常的相似，只是增加了一些新的状态。</p>
<p>在fragment中也是可以通过onSaveInstanceState()方法保存数据的，因为进入停止状态的fragment可能由于系统内存不足而被回收，保存下来数据可以在onCreate(),onCreateView(),onActivityCreate()三个方法中重新得到，他们都含有一个Bundle类型的saveInstanceState参数。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GitHub Pages现在支持Https了]]></title>
      <url>http://tonnyl.github.io/2016/06/10/GitHub-Pages%E7%8E%B0%E5%9C%A8%E6%94%AF%E6%8C%81Https%E4%BA%86/</url>
      <content type="html"><![CDATA[<p>HTTPS for GitHub Pages<br><a id="more"></a></p>
<p>数以百万计的人用<a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages</a>来支持他们的网站，这些网站每天也会有数以百万计的访问量，为了更好的支持这些GitHub Pages站点，也为了在互联网中增加HTTPS的使用范围，GitHub Pages现在官方支持所有   <code>&lt;username&gt;.github.io</code> 站点了。HTTPS提供的加密层，可以防止他人窥探或篡改指向您的Pages站点。</p>
<p>你现在就可以访问 <code>*.github.io</code>站点，强制你的站点使用HTTPS。如果你使用了HTTPS，任何HTTP请求都会被直接重定向为HTTPS请求。</p>
<img src="/2016/06/10/GitHub-Pages现在支持Https了/github_pages_now_support_https.png" alt="github_pages_now_support_https" title="github_pages_now_support_https">
<p>从2016年6月9日开始，所有的新建GitHub Pages站点都会被强制使用HTTPS。同时为了使已经存在的站点能够强制使用HTTPS，你可以访问你的站点的仓库，点击<a href="https://help.github.com/articles/securing-your-github-pages-site-with-https/" target="_blank" rel="external">Pages HTTPS documentation</a>来获取更多的信息。</p>
<p>开启GitHub Pages HTTPS的方法：</p>
<p>如上面所说，对于在2016年6月9日之后开通的，以 <code>&lt;username&gt;.github.io</code> 为域名的站点，将自动开启HTTPS。</p>
<p>对于在9日之前开通的站点，可以用下面的方法开启：</p>
<p>step 1. 在GitHub主站，进入到pages的库(repository)<br>step 2. 在你的仓库名称下，点击Settings</p>
<img src="/2016/06/10/GitHub-Pages现在支持Https了/repo-actions-settings.png" alt="repo-actions-settings" title="repo-actions-settings">
<p>step 3. 在“GitHub Pages”下，选择Enforce HTTPS</p>
<img src="/2016/06/10/GitHub-Pages现在支持Https了/enforce-https-checkbox.png" alt="enforce-https-checkbox" title="enforce-https-checkbox">
<p>嗯，听到这个消息，我也是在第一时间把博客升级到了HTTPS，不信你看！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[实现RecyclerView的item的滑动删除]]></title>
      <url>http://tonnyl.github.io/2016/05/28/%E5%AE%9E%E7%8E%B0RecyclerView%E7%9A%84item%E7%9A%84%E6%BB%91%E5%8A%A8%E5%88%A0%E9%99%A4/</url>
      <content type="html"><![CDATA[<p>利用ItemTouchHelper实现recycler view item的侧滑删除<br><a id="more"></a></p>
<h3 id="关于ItemTouchHelper"><a href="#关于ItemTouchHelper" class="headerlink" title="关于ItemTouchHelper"></a>关于ItemTouchHelper</h3><p>官方文档的解释：</p>
<blockquote>
<p>This is a utility class to add swipe to dismiss and drag &amp; drop support to RecyclerView.</p>
</blockquote>
<p>从文档不难看出，ItemTouchHelper是一个用于在RecyclerView中实现滑动删除和拖拽的工具类。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>修改build.gradle文件，添加依赖。</li>
</ul>
<pre><code>compile &#39;com.android.support:recyclerview-v7:23.4.0&#39;
</code></pre><ul>
<li>构建object与Adapter</li>
</ul>
<p>这里假设我已经构建好了实体类CodeLanguage和adapter，在构建adapter时，需要添加一个方法。</p>
<pre><code class="java">public void remove(int position) {
   mMovies.remove(position);
   notifyItemRemoved(position);
}
</code></pre>
<ul>
<li>创建ItemTouchHelper.SimpleCallback子类</li>
</ul>
<p>为了处理拖动和滑动事件，需要创建ItemTouchHelper.SimpleCallback的实现类。这里，只对滑动事件感兴趣，这是我们的callback.</p>
<pre><code class="java">public class CodeLanguageItemTouchHelper extens ItemTouchHelper.SimpleCallback{

    private CodeLanguageAdapter adapter;

    public CodeLanguageItemTouchHelper(CodeLanguageAdapter adapter){
      super(ItemTouchHelper.UP | ItemTouchHelper.DOWN, ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT);
      this.adapter = adapter;
   }

    /**
    * If you don&#39;t support drag &amp; drop, this method will never be called.
    * 如果不支持拖拽，那么这个方法就不会被执行。
    * @param recyclerView The RecyclerView to which ItemTouchHelper is attached to. ItemTouchHelper需要附加到的RecyclerView
    * @param viewHolder The ViewHolder which is being dragged by the user. 拖动的ViewHolder
    * @param target The ViewHolder over which the currently active item is being dragged. 目标位置的ViewHolder
    * @return True if the viewHolder has been moved to the adapter position of target. viewHolder是否被移动到目标位置
    */
   @Override
   public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) {
      return false;  
   }

    /**
    * Called when a ViewHolder is swiped by the user.
    * If you don&#39;t support swiping, this method will never be called.
    * 如果不支持滑动，方法不会被执行。
    * @param viewHolder The ViewHolder which has been swiped by the user.
    * @param direction  The direction to which the ViewHolder is swiped.
    *                    It is one of UP, DOWN, LEFT or RIGHT.
    *                    If your getMovementFlags(RecyclerView, ViewHolder) method returned relative flags instead of LEFT / RIGHT;
    *                    `direction` will be relative as well. (START or END).
    */
   @Override
   public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {
      //Remove item
      adapter.remove(viewHolder.getAdapterPosition());
   }

}
</code></pre>
<p>CodeLanguageItemTouchHelper默认的构造方法需要传入两个参数。</p>
<pre><code class="java">
/**
* Creates a Callback for the given drag and swipe allowance.
* @param dragDirs 表示拖拽的方向，有六个类型的值：LEFT、RIGHT、START、END、UP、DOWN
* @param swipeDirs 表示滑动的方向，有六个类型的值：LEFT、RIGHT、START、END、UP、DOWN
*/
ItemTouchHelper.SimpleCallback(int dragDirs, int swipeDirs)
</code></pre>
<p>CodeLanguageItemTouchHelper默认需要实现两个方法onMove(),onSwiped()，onMove()是对拖拽的实现，onSwiped()是对滑动的实现。</p>
<ul>
<li>将ItemTouchHelper添加至RecyclerView</li>
</ul>
<p>创建好自己的ItemTouchHelper类后，将它附加到RecyclerView就很简单了。在Activity或者Fragment的onCreate()方法中：</p>
<pre><code class="java">ItemTouchHelper.Callback callback = new MovieTouchHelper(adapter);
ItemTouchHelper helper = new ItemTouchHelper(callback);
helper.attachToRecyclerView(codeLanguageRecyclerView);
</code></pre>
<p>现在所有的工作已经完成。我们现在还没有添加动画，默认的动画系统已经添加。现在就可以使用了。</p>
<p>示例project在这里：<a href="https://github.com/TonnyL/zhuanlan" target="_blank" rel="external">GitHub</a>，与上述项目稍有不同。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于知乎专栏ID的一些说明]]></title>
      <url>http://tonnyl.github.io/2016/05/27/%E5%85%B3%E4%BA%8E%E7%9F%A5%E4%B9%8E%E4%B8%93%E6%A0%8FID%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<p>对什么是知乎专栏ID以及如何在知乎专栏App中添加喜欢的专栏的一些方法。<br><a id="more"></a></p>
<h3 id="什么是知乎专栏ID？"><a href="#什么是知乎专栏ID？" class="headerlink" title="什么是知乎专栏ID？"></a>什么是知乎专栏ID？</h3><p>知乎专栏id是由若干字符组成，是一个知乎专栏的唯一标识。如 <strong>wooyun</strong> 是知乎用户 <strong>fenggou</strong> 的专栏 <strong>乌云君</strong> 的id。</p>
<h3 id="怎样获取知乎专栏的ID？"><a href="#怎样获取知乎专栏的ID？" class="headerlink" title="怎样获取知乎专栏的ID？"></a>怎样获取知乎专栏的ID？</h3><ul>
<li>PC用户通过浏览器浏览网站时，进入某用户的主页时，可以看到浏览器显示的URL，如图所示，红色线条所指处wooyun即为ID。</li>
</ul>
<img src="/2016/05/27/关于知乎专栏ID的一些说明/zhihu_id_pc.png" alt="zhihu_id_pc.png" title="">
<ul>
<li>Android客户端麻烦一些，进入到用户的主页后，如果该用户有开通知乎专栏，进入TA的专栏。</li>
</ul>
<p>点击TA的文章。</p>
<img src="/2016/05/27/关于知乎专栏ID的一些说明/zhihu_id_android_0.png" alt="zhihu_id_android_0.png" title="">
<p>进入TA的专栏。</p>
<img src="/2016/05/27/关于知乎专栏ID的一些说明/zhihu_id_android_1.png" alt="zhihu_id_android_1.png" title="">
<p>点击分享按钮。</p>
<img src="/2016/05/27/关于知乎专栏ID的一些说明/zhihu_id_android_2.png" alt="zhihu_id_android_2.png" title="">
<p>然后选择复制到粘贴板。</p>
<img src="/2016/05/27/关于知乎专栏ID的一些说明/zhihu_id_android_3.png" alt="zhihu_id_android_3.png" title="">
<p>粘贴至知乎专栏App的自定义页面。点击添加按钮，粘贴至dialog中。</p>
<img src="/2016/05/27/关于知乎专栏ID的一些说明/zhihu_id_android_4.png" alt="zhihu_id_android_4.png" title="">
<p>删除不需要的部分，只留下id部分。现在就可以点击确定添加了。</p>
<img src="/2016/05/27/关于知乎专栏ID的一些说明/zhihu_id_android_5.png" alt="zhihu_id_android_5.png" title="">
<h3 id="什么时候能够更加简单的添加ID？"><a href="#什么时候能够更加简单的添加ID？" class="headerlink" title="什么时候能够更加简单的添加ID？"></a>什么时候能够更加简单的添加ID？</h3><p>好吧，现在添加id的步骤确实有点麻烦，后面我会想办法把添加id的步骤精简一些。预计下一版会实现。</p>
<h3 id="需要注意的事项"><a href="#需要注意的事项" class="headerlink" title="需要注意的事项"></a>需要注意的事项</h3><p>建议总添加ID不要超过20个，添加过多的栏目时可能造成初始化页面时，加载时间过长。</p>
<h3 id="最后说一句"><a href="#最后说一句" class="headerlink" title="最后说一句"></a>最后说一句</h3><p>项目目前已经开源到GitHub,项目地址<a href="https://github.com/marktony/zhuanlan" target="_blank" rel="external">知乎专栏GitHub</a>,欢迎感兴趣的同学fork+star，定制属于自己的知乎专栏App。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tips]]></title>
      <url>http://tonnyl.github.io/2016/05/19/Tips/</url>
      <content type="html"><![CDATA[<p>那些我自己踩过的坑!</p>
<a id="more"></a>
<ul>
<li><p>SwipeRefreshLayout setRefreshing()方法失败<br>解决方法：</p>
<pre><code class="java">swipeRefreshLayout.post(new Runnable() {
  @Override
  public void run() {
      swipeRefreshLayout.setRefreshing(true);
  }
});
</code></pre>
</li>
<li><p>Recyclerview与SwipeRefreshLayout滑动事件冲突<br>界面中同时有这两种view时，滑动时间便冲突了。知乎android客户端设置界面在无网络连接时，也存在同样的滑动事件冲突的问题，但是它的布局应该是SwipeRefreshLayout和ScrollView冲突。<br>解决方法：</p>
<pre><code class="java">recyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() {
          @Override
          public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
              super.onScrolled(recyclerView, dx, dy);

              // 确保只有当RecyclerView的item滑动到最上面的一个时RefreshLayout才能下拉
              refreshLayout.setEnabled(linearLayoutManager.findFirstVisibleItemPosition() == 0);
          }
      });
</code></pre>
</li>
<li><p>应用退出时网络请求未完成导致失去context<br>这么说可能不是特别清楚，具体的描述应该是：当网络请求仍在进行时，退出应用，这是失去context，某些适配器没有适配完成，导致应用直接崩溃。<br>在知乎专栏的过程中，fragment中的内容全部为recyclerview，而且全部是在网络请求下完成的。第一版的时候我遇到的问题就是上述描述的这样，在网络请求没有完全完成时，退出应用，recyclerview的适配还没有完成，之后直接导致set text on a null object。<br>我的解决方法是：给所有volley网络请求设置TAG，然后在fragment的onStop()方法中取消请求。<br>示例代码:</p>
</li>
</ul>
<pre><code class="java">public class MyFragment extends Fragment{

    private RequestQueue queue;
    private static final String     TAG = &quot;TAG&quot;;

    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        queue = Volley.newRequestQueue(getActivity().getApplicationContext());
    }

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.my_fragment,container,false);

        JsonObjectRequest request = new JsonObjectRequest(Request.Method.GET, &quot;my url&quot;, new Response.Listener&lt;JSONObject&gt;() {
            @Override
            public void onResponse(JSONObject jsonObject) {
                // code
        }, new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError volleyError) {
               // code
            }
        });

        request.setTag(TAG);
        queue.add(request);

         @Override
        public void onStop() {
        super.onStop();

        if (queue != null){
            queue.cancelAll(TAG);
        }
    }
}
</code></pre>
<ul>
<li>去除字符串中的html部分<br>在Android中通过一行代码即可搞定。<pre><code class="java">newString = android.text.Html.fromHtml(oldString).toString();
</code></pre>
在java中的解决方法是：<pre><code class="java">String newString = Jsoup.parse(html).text();
</code></pre>
</li>
</ul>
<p>more…</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[知乎专栏API分析]]></title>
      <url>http://tonnyl.github.io/2016/05/14/%E7%9F%A5%E4%B9%8E%E4%B8%93%E6%A0%8FAPI%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>知乎专栏API的简单分析<br><a id="more"></a></p>
<p>感谢知乎，提供如此出色的平台，更要感谢辛苦的专栏作者们，为我们提供了这么多的干货，最后感谢支持我的人们，谢谢你们！</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>声明：以下所有API均由 <strong>知乎(Zhihu.INC)</strong> 提供，本人通过非正常手段获取。获取与共享的行为有侵犯知乎权益的嫌疑。若被告知停止使用与共享，本人将及时删除整个项目。请您知悉相关情况，遵守知乎的协议。API仅供学习交流使用，请勿用作商业用途。</p>
<h3 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h3><p><a href="https://github.com/TonnyL/zhuanlan" target="_blank" rel="external">知乎专栏Android</a></p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>专栏的消息均以JSON格式输出</li>
<li>http method均为GET</li>
<li>JSON ARRAY 中的数据，只选取了具有代表性的部分进行展示</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="获取指定专栏的信息"><a href="#获取指定专栏的信息" class="headerlink" title="获取指定专栏的信息"></a>获取指定专栏的信息</h4><pre><code>https://zhuanlan.zhihu.com/api/columns/专栏名
</code></pre><p>例如获取知乎小管家的专栏信息</p>
<pre><code>https://zhuanlan.zhihu.com/api/columns/zhihuadmin
</code></pre><p>得到的信息为：</p>
<pre><code class="json">{
  &quot;followersCount&quot;: 7883,
  &quot;creator&quot;:
    {
      &quot;profileUrl&quot;: &quot;https://www.zhihu.com/people/zhihuadmin&quot;,
      &quot;bio&quot;: &quot;欢迎反馈问题和建议！&quot;,
      &quot;hash&quot;: &quot;3d198a56310c02c4a83efb9f4a4c027e&quot;,
      &quot;uid&quot;: 53253479858176,
      &quot;isOrg&quot;: false,
      &quot;description&quot;: &quot;&quot;,
      &quot;slug&quot;: &quot;zhihuadmin&quot;,
      &quot;avatar&quot;:
        {
          &quot;id&quot;: &quot;34bf96bf5584ac4b5264bd7ed4fdbc5a&quot;,
          &quot;template&quot;: &quot;https://pic3.zhimg.com/{id}_{size}.jpg&quot;
        },
      &quot;name&quot;: &quot;知乎小管家&quot;
    },
    &quot;topics&quot;:
      [
        {
          &quot;url&quot;: &quot;https://www.zhihu.com/topic/19552112&quot;,
          &quot;id&quot;: &quot;19552112&quot;,
          &quot;name&quot;: &quot;知乎建议反馈&quot;
        },
      ],
    &quot;activateState&quot;: &quot;activated&quot;,
    &quot;href&quot;: &quot;/api/columns/zhihuadmin&quot;,
    &quot;acceptSubmission&quot;: true,
    &quot;firstTime&quot;: false,
    &quot;postTopics&quot;:
      [
        {
          &quot;postsCount&quot;: 4,
          &quot;id&quot;: 2,
          &quot;name&quot;: &quot;知乎&quot;
        },
      ],
    &quot;pendingName&quot;: &quot;&quot;,
    &quot;avatar&quot;:
      {
        &quot;id&quot;: &quot;5a1ec50171767c4fc856f430e46297db&quot;,
        &quot;template&quot;: &quot;https://pic4.zhimg.com/{id}_{size}.jpg&quot;
      },
    &quot;canManage&quot;: false,
    &quot;description&quot;: &quot;知乎社区管理团队官方专栏，不定期更新社区管理工作相关的最新消息。&quot;,  
    &quot;pendingTopics&quot;: [],
    &quot;nameCanEditUntil&quot;: 0,
    &quot;reason&quot;: &quot;&quot;,
    &quot;banUntil&quot;: 0,
    &quot;slug&quot;: &quot;zhihuadmin&quot;,
    &quot;name&quot;: &quot;知乎小管家说&quot;,
    &quot;url&quot;: &quot;/zhihuadmin&quot;,
    &quot;intro&quot;: &quot;知乎社区管理团队官方专栏，不定期更新社区管理工作…&quot;,  
    &quot;topicsCanEditUntil&quot;: 0,
    &quot;activateAuthorRequested&quot;: &quot;none&quot;,
    &quot;commentPermission&quot;: &quot;anyone&quot;,
    &quot;following&quot;: false,
    &quot;postsCount&quot;: 19,  
    &quot;canPost&quot;: false
  }
</code></pre>
<ul>
<li>followersCount: 关注该专栏的人数</li>
<li>creator: 该专栏的创建者信息<ul>
<li>profileUrl: 知乎网的个人主页url</li>
<li>bio: 官网信息中的一句话描述</li>
<li>hash: hash值</li>
<li>uid: uid</li>
<li>isOrg: 是否为机构帐号</li>
<li>description: 描述</li>
<li>slug: slug</li>
<li>avatar: 头像信息<ul>
<li>id: id值，在拼接url时用到</li>
<li>template: url拼接模版</li>
</ul>
</li>
<li>name: 作者名称</li>
</ul>
</li>
<li>topics: 专栏话题信息<ul>
<li>url: 话题在知乎官网中的地址</li>
<li>id: 话题id</li>
<li>name: 话题名称</li>
</ul>
</li>
<li>activateState: 状态信息，是否激活</li>
<li>href: api请求地址</li>
<li>acceptSubmission: 是否接受提交文章</li>
<li>firstTime: 是否为首次提交？？？</li>
<li>postTopics: 文章话题信息<ul>
<li>postsCount: 该话题下文章数</li>
<li>id: id</li>
<li>name: 话题名称</li>
</ul>
</li>
<li>pendingName: ？？？</li>
<li>avatar: 专栏头像信息<ul>
<li>id: 头像id</li>
<li>template: url拼接模版</li>
</ul>
</li>
<li>canManage: 是否可以进行管理</li>
<li>description: 专栏信息描述</li>
<li>pendingTopics: ???话题</li>
<li>nameCanEditUntil: 距下一次修改名称的时间</li>
<li>reason: 被封禁的原因</li>
<li>banUntil: 被封禁的时间</li>
<li>slug: 专栏slug</li>
<li>url: url</li>
<li>intro: 专栏介绍信息</li>
<li>topicsCanEditUntil: 距下一次修改话题的时间</li>
<li>activateAuthorRequested: ???</li>
<li>commentPermission: 评论权限</li>
<li>following: 是否关注改专栏</li>
<li>postsCount: 专栏文章数</li>
<li>canPost: 当前帐号是否有发表文章的权限</li>
</ul>
<p>在获取图片url时，可以根据需要选择不同的尺寸。如下所示，图片质量依次增加。也可以不添加尺寸参数，默认获取最大类型。</p>
<pre><code>https://pic3.zhimg.com/34bf96bf5584ac4b5264bd7ed4fdbc5a_s.jpg
https://pic3.zhimg.com/34bf96bf5584ac4b5264bd7ed4fdbc5a_m.jpg
https://pic3.zhimg.com/34bf96bf5584ac4b5264bd7ed4fdbc5a_l.jpg
https://pic3.zhimg.com/34bf96bf5584ac4b5264bd7ed4fdbc5a_b.jpg
https://pic3.zhimg.com/34bf96bf5584ac4b5264bd7ed4fdbc5a_r.jpg
</code></pre><h4 id="获取指定专栏的文章列表"><a href="#获取指定专栏的文章列表" class="headerlink" title="获取指定专栏的文章列表"></a>获取指定专栏的文章列表</h4><pre><code>https://zhuanlan.zhihu.com/api/columns/专栏名/posts?limit=数量&amp;offset=从哪里开始
</code></pre><p>例如，获取知乎小管家的最新的10篇文章</p>
<pre><code>https://zhuanlan.zhihu.com/api/columns/zhihuadmin/posts?limit=10&amp;offset=0
</code></pre><p>其中，limit为获取的数量限制，offset为偏移量，即从哪里开始获取。<br>默认数据为limit=10，offset=0，当然你也可以根据需要定义二者的值。<br>获得的数据为:</p>
<pre><code class="JSON">[
  {  
    &quot;isTitleImageFullScreen&quot;: false,
    &quot;rating&quot;: &quot;none&quot;,
    &quot;sourceUrl&quot;: &quot;&quot;,
    &quot;publishedTime&quot;: &quot;2016-10-13T14:00:49+08:00&quot;,
    &quot;links&quot;:
      {
        &quot;comments&quot;: &quot;/api/posts/22921645/comments&quot;
      },
    &quot;author&quot;:
      {
        &quot;profileUrl&quot;: &quot;https://www.zhihu.com/people/zhihuadmin&quot;,
        &quot;bio&quot;: &quot;欢迎反馈问题和建议！&quot;,
        &quot;hash&quot;: &quot;3d198a56310c02c4a83efb9f4a4c027e&quot;,
        &quot;uid&quot;: 53253479858176,
        &quot;isOrg&quot;: false,
        &quot;description&quot;: &quot;&quot;,  
        &quot;slug&quot;: &quot;zhihuadmin&quot;,
        &quot;avatar&quot;:
          {
            &quot;id&quot;: &quot;34bf96bf5584ac4b5264bd7ed4fdbc5a&quot;,
            &quot;template&quot;: &quot;https://pic3.zhimg.com/{id}_{size}.jpg&quot;
          },
        &quot;name&quot;: &quot;知乎小管家&quot;
      },
    &quot;url&quot;: &quot;/p/22921645&quot;,
    &quot;title&quot;: &quot;新版社区管理规定于 2016 年 10 月 13 日正式运行&quot;,
    &quot;titleImage&quot;: &quot;https://pic2.zhimg.com/v2-517f47cc5269b57f26ea4a25f29d8505_r.jpg&quot;,
    &quot;summary&quot;: &quot;&quot;,
    &quot;content&quot;: &quot;&lt;p&gt;2016 年 9 月 13 日小管家发布了新版社区管理规定，明确了「恶意行为」的定义和违规类型，同时增加了「发布垃圾广告信息」的 3 种违规类型。在完成了为期 1 个月的试运行后&lt;b&gt;，&lt;/b&gt;&lt;b&gt;&lt;a href=\&quot;https://www.zhihu.com/question/19790711/answer/36685915\&quot; class=\&quot;\&quot; data-editable=\&quot;true\&quot; data-title=\&quot;\u65b0\u7248\u793e\u533a\u7ba1\u7406\u89c4\u5b9a\&quot;&gt;\u65b0\u7248\u793e\u533a\u7ba1\u7406\u89c4\u5b9a&lt;/a&gt;&quot;,
    &quot;state&quot;: &quot;published&quot;,
    &quot;href&quot;: &quot;/api/posts/22921645&quot;,
    &quot;meta&quot;:
      {
        &quot;previous&quot;: null,
        &quot;next&quot;: null
      },
    &quot;commentPermission&quot;: &quot;anyone&quot;,
    &quot;snapshotUrl&quot;: &quot;&quot;,
    &quot;canComment&quot;: false,
    &quot;slug&quot;: 22921645,
    &quot;commentsCount&quot;: 76,
    &quot;likesCount&quot;: 436
  },
]
</code></pre>
<ul>
<li>isTitleImageFullScreen: 文章标题大图是否全屏</li>
<li>rating: ???评级</li>
<li>sourceUrl: 源路径</li>
<li>publishedTime: 发表时间</li>
<li>links: 链接信息<ul>
<li>comments: 评论地址</li>
</ul>
</li>
<li>creator: 该专栏的创建者信息<ul>
<li>profileUrl: 知乎网的个人主页url</li>
<li>bio: 官网信息中的一句话描述</li>
<li>hash: hash值</li>
<li>uid: uid</li>
<li>isOrg: 是否为机构帐号</li>
<li>description: 描述</li>
<li>slug: slug</li>
<li>avatar: 头像信息<ul>
<li>id: id值，在拼接url时用到</li>
<li>template: url拼接模版</li>
</ul>
</li>
<li>name: 作者名称</li>
</ul>
</li>
<li>url: 文章网页内容获取(<a href="https://zhuanlan.zhihu.com" target="_blank" rel="external">https://zhuanlan.zhihu.com</a> + url)</li>
<li>title: 文章标题</li>
<li>titleImage: 文章标题大图url(需要注意的是,titleImage的值有可能为空)，和头像一样，也可以组合不同的尺寸参数获取不同尺寸的图片</li>
<li>summary: 文章简要信息</li>
<li>content: HTML格式的文章内容详情，可以通过WebView或者UIWebView展示内容</li>
<li>state: 文章状态(是否发表)</li>
<li>href: api请求地址</li>
</ul>
<h4 id="获取特定的文章信息"><a href="#获取特定的文章信息" class="headerlink" title="获取特定的文章信息"></a>获取特定的文章信息</h4><pre><code>https://zhuanlan.zhihu.com/api/posts/SLUG
</code></pre><p>例如，获取知乎小管家的最新一篇文章，通过已经获得的信息，有两种方法组合url进行获取，一是通过href值，另一种就是slug值，当然，这两种方式殊途同归。</p>
<pre><code>https://zhuanlan.zhihu.com/api/posts/22921645
</code></pre><p>获取到的信息为:</p>
<pre><code class="JSON">{
  &quot;isTitleImageFullScreen&quot;: false,
  &quot;rating&quot;: &quot;none&quot;,
  &quot;titleImage&quot;: &quot;https://pic2.zhimg.com/v2-cab0719fdec0816c475d7b70e016cbb1_r.jpg&quot;,
  &quot;links&quot;:
    {
      &quot;comments&quot;: &quot;/api/posts/22591792/comments&quot;
    },
  &quot;reviewers&quot;: [],
  &quot;topics&quot;:
    [
      {
        &quot;url&quot;: &quot;https://www.zhihu.com/topic/19550887&quot;,
        &quot;id&quot;: &quot;19550887&quot;,
        &quot;name&quot;: &quot;知乎社区&quot;
      },
    ],
  &quot;titleImageSize&quot;:
    {
      &quot;width&quot;: 0,
      &quot;height&quot;: 0
    },
  &quot;href&quot;: &quot;/api/posts/22591792&quot;,
  &quot;excerptTitle&quot;: &quot;&quot;,
  &quot;author&quot;:
    {
      &quot;profileUrl&quot;: &quot;https://www.zhihu.com/people/zhihuadmin&quot;,
      &quot;bio&quot;: &quot;欢迎反馈问题和建议！&quot;,
      &quot;hash&quot;: &quot;3d198a56310c02c4a83efb9f4a4c027e&quot;,
      &quot;uid&quot;: 53253479858176,
      &quot;isOrg&quot;: false,
      &quot;description&quot;: &quot;&quot;,
      &quot;badge&quot;:
        {
          &quot;identity&quot;:
            {
              &quot;description&quot;: &quot;知乎官方帐号&quot;
            },
          &quot;best_answerer&quot;: null
        },
      &quot;slug&quot;: &quot;zhihuadmin&quot;,
      &quot;avatar&quot;:
        {
          &quot;id&quot;: &quot;34bf96bf5584ac4b5264bd7ed4fdbc5a&quot;,
          &quot;template&quot;: &quot;https://pic3.zhimg.com/{id}_{size}.jpg&quot;
        },
      &quot;name&quot;: &quot;知乎小管家&quot;
    },
  &quot;column&quot;:
    {
      &quot;slug&quot;: &quot;zhihuadmin&quot;,
      &quot;name&quot;: &quot;知乎小管家说&quot;
    },
  &quot;tipjarState&quot;: &quot;inactivated&quot;,
  &quot;content&quot;: &quot;&lt;p&gt;今天，小管家和大家分享一下站内「不规范转载」行为的处理情况。&lt;/p&gt;&lt;br&gt;&quot;,
  &quot;state&quot;: &quot;published&quot;,
  &quot;sourceUrl&quot;: &quot;&quot;,
  &quot;pageCommentsCount&quot;: 34,
  &quot;canComment&quot;: true,
  &quot;snapshotUrl&quot;: &quot;&quot;,
  &quot;slug&quot;: 22591792,
  &quot;publishedTime&quot;: &quot;2016-09-23T17:33:56+08:00&quot;,
  &quot;url&quot;: &quot;/p/22591792&quot;,
  &quot;title&quot;: &quot;知乎小管家工作笔记：不规范转载？不可以！&quot;,
  &quot;lastestLikers&quot;:
    [
      {
        &quot;profileUrl&quot;: &quot;https://www.zhihu.com/people/su-shu-95-98&quot;,
        &quot;bio&quot;: &quot;一个无法用一句话描述的人&quot;,
        &quot;hash&quot;: &quot;a6975d974fb22609a31dbbdec6f375e3&quot;,
        &quot;uid&quot;: 657690756534505472,
        &quot;isOrg&quot;: false,
        &quot;description&quot;: &quot;你说什么都对。&quot;,
        &quot;slug&quot;: &quot;su-shu-95-98&quot;,
        &quot;avatar&quot;:
          {
            &quot;id&quot;: &quot;888129f4afd91083c0cfd156e6889438&quot;,
            &quot;template&quot;: &quot;https://pic1.zhimg.com/{id}_{size}.jpg&quot;
          },
        &quot;name&quot;: &quot;苏舒&quot;
      },
    ],
  &quot;summary&quot;: &quot;&lt;img src=\&quot;https://pic1.zhimg.com/v2-4f2228e8f8292ec30c373488afa2bd48_200x112.jpg\&quot; data-rawwidth=\&quot;920\&quot; data-rawheight=\&quot;638\&quot; class=\&quot;origin_image inline-img zh-lightbox-thumb\&quot; data-original=\&quot;https://pic1.zhimg.com/v2-4f2228e8f8292ec30c373488afa2bd48_r.jpg\&quot;&gt;今天，小管家和大家分享一下站内「不规范转载」行为的处理情况。 年初我们发布了...&quot;,
  &quot;reviewingCommentsCount&quot;: 0,
  &quot;meta&quot;:
    {
      &quot;previous&quot;:
        {
          &quot;isTitleImageFullScreen&quot;: false,
          &quot;rating&quot;: &quot;none&quot;,
          &quot;titleImage&quot;: &quot;https://pic2.zhimg.com/517f47cc5269b57f26ea4a25f29d8505_r.jpg&quot;,
          &quot;links&quot;:
            {
              &quot;comments&quot;: &quot;/api/posts/22434253/comments&quot;
            },
          &quot;topics&quot;:
            [
              {
                &quot;url&quot;: &quot;https://www.zhihu.com/topic/19550887&quot;,
                &quot;id&quot;: &quot;19550887&quot;,
                &quot;name&quot;: &quot;知乎社区&quot;
              },            
            ],
          &quot;href&quot;: &quot;/api/posts/22434253&quot;,
          &quot;excerptTitle&quot;: &quot;&quot;,
          &quot;author&quot;:
            {
              &quot;profileUrl&quot;: &quot;https://www.zhihu.com/people/zhihuadmin&quot;,
              &quot;bio&quot;: &quot;欢迎反馈问题和建议！&quot;,
              &quot;hash&quot;: &quot;3d198a56310c02c4a83efb9f4a4c027e&quot;,
              &quot;uid&quot;: 53253479858176,
              &quot;isOrg&quot;: false,
              &quot;description&quot;: &quot;&quot;,
              &quot;slug&quot;: &quot;zhihuadmin&quot;,
              &quot;avatar&quot;:
                {
                  &quot;id&quot;: &quot;34bf96bf5584ac4b5264bd7ed4fdbc5a&quot;,
                  &quot;template&quot;: &quot;https://pic3.zhimg.com/{id}_{size}.jpg&quot;
                },
              &quot;name&quot;: &quot;知乎小管家&quot;
            },
          &quot;column&quot;:
            {
              &quot;slug&quot;: &quot;zhihuadmin&quot;,
              &quot;name&quot;: &quot;知乎小管家说&quot;
            },
          &quot;content&quot;: &quot;题下发布相同回答；&lt;/p&gt;&lt;img src=\&quot;https://pic2.zhimg.com/a86dbedbeb67a26b33252ee4e8e886a9_b.png\&quot; data-rawwidth=\&quot;469\&quot; data-rawheight=\&quot;348\&quot; class=\&quot;origin_image zh-lightbox-thumb\&quot; width=\&quot;469\&quot; data-original=\&quot;https://pic2.zhimg.com/a86dbedbeb67a26b33252ee4e8e886a9_r.png\&quot;&gt;&lt;br&gt;&quot;,
          &quot;state&quot;: &quot;published&quot;,
          &quot;sourceUrl&quot;: &quot;&quot;,
          &quot;pageCommentsCount&quot;: 0,
          &quot;canComment&quot;: true,
          &quot;snapshotUrl&quot;: &quot;&quot;,
          &quot;slug&quot;: 22434253,
          &quot;publishedTime&quot;: &quot;2016-09-13T17:34:29+08:00&quot;,
          &quot;url&quot;: &quot;/p/22434253&quot;,
          &quot;title&quot;: &quot;新版社区管理规范于今日试运行&quot;,
          &quot;summary&quot;: &quot;社区管理规范是知友共识的总结，也是社区健康发展的基石。近期，我们不断收到知友们反馈新的扰乱社区秩序的行为，如集赞爆照、点赞抽奖、评论区发布乱码、刷赞刷粉、恶意营销、回答隐藏淘宝链接...&quot;,
          &quot;reviewingCommentsCount&quot;: 0,
          &quot;meta&quot;:
            {
              &quot;previous&quot;: null,
              &quot;next&quot;: null
            },
          &quot;commentPermission&quot;: &quot;anyone&quot;,
          &quot;commentsCount&quot;: 0,
          &quot;likesCount&quot;: 0
        },
      &quot;next&quot;: null
    },
  &quot;commentPermission&quot;: &quot;anyone&quot;,
  &quot;commentsCount&quot;: 34,
  &quot;likesCount&quot;: 241
}
</code></pre>
<ul>
<li>isTitleImageFullScreen: 文章标题大图是否全屏</li>
<li>rating: ???评级</li>
<li>titleImage: 文章标题大图url(需要注意的是,titleImage的值有可能为空)，和头像一样，也可以组合不同的尺寸参数获取不同尺寸的图片</li>
<li>links: 链接信息<ul>
<li>comments: 评论获取地址</li>
</ul>
</li>
<li>reviewers: 复审人(在我请求的这么多次中，并没有成功获得过此项对应的值。不排除此项返回具体值的可能性。推测为creator类型。)</li>
<li>topics: 专栏话题信息<ul>
<li>url: 话题在知乎官网中的地址</li>
<li>id: 话题id</li>
<li>name: 话题名称</li>
</ul>
</li>
<li>titleImageSize:<ul>
<li>width 宽度</li>
<li>height 高度</li>
</ul>
</li>
<li>href: api请求地址</li>
<li>excerptTitle: 引用(摘录)标题</li>
<li>author:<ul>
<li>profileUrl: 知乎网的个人主页url</li>
<li>bio: 官网信息中的一句话描述</li>
<li>hash: hash值</li>
<li>uid: uid</li>
<li>isOrg: 是否为机构帐号</li>
<li>description: 描述</li>
<li>badge 徽章，即认证信息<ul>
<li>identity 官方帐号<ul>
<li>description 认证详情描述</li>
</ul>
</li>
<li>best_answerer 优秀回答者</li>
</ul>
</li>
<li>slug: slug</li>
<li>avatar: 头像信息<ul>
<li>id: id值，在拼接url时用到</li>
<li>template: url拼接模版</li>
</ul>
</li>
<li>name: 作者名称</li>
</ul>
</li>
<li>column: 所属专栏<ul>
<li>slug slug</li>
<li>name 专栏名称</li>
</ul>
</li>
<li>tipjarState: 打赏信息</li>
<li>content: HTML格式的内容信息详情</li>
<li>state: 文章状态，是否发布</li>
<li>sourceUrl: 源地址</li>
<li>pageCommentsCount: 评论数</li>
<li>canComment: 是否可以评论</li>
<li>snapshotUrl: 短网址?</li>
<li>slug: 文章的slug</li>
<li>publishedTime: 文章发表时间</li>
<li>url: url地址</li>
<li>title: 文章标题</li>
<li>lastestLikers: 最近点赞的用户<ul>
<li>profileUrl: 知乎网的个人主页url</li>
<li>bio: 官网信息中的一句话描述</li>
<li>hash: hash值</li>
<li>uid: uid</li>
<li>isOrg: 是否为机构帐号</li>
<li>description: 描述</li>
<li>slug: slug</li>
<li>avatar: 头像信息<ul>
<li>id: id值，在拼接url时用到</li>
<li>template: url拼接模版</li>
</ul>
</li>
<li>name: 作者名称</li>
</ul>
</li>
<li>summary”: 文章简要信息</li>
<li>reviewingCommentsCount: 审查中的评论数量</li>
<li>meta: meta<ul>
<li>previous 上一篇文章的信息，json结构和上面的内容相同</li>
<li>next 下一篇文章的信息</li>
</ul>
</li>
<li>commentPermission: 评论权限</li>
<li>commentsCount: 评论数量</li>
<li>likesCount: 赞的数量</li>
</ul>
<p>在认证信息中，目前只发现有两种类型，identity官方帐号和best_answerer优秀回答者，由于知乎小管家只是官方帐号，并不是优秀回答者，这里选取优秀回答者<a href="https://www.zhihu.com/people/aton" target="_blank" rel="external">苏莉安</a>的信息进行分析。</p>
<pre><code class="JSON">&quot;badge&quot;:
  {
    &quot;identity&quot;: null,
    &quot;best_answerer&quot;:
      {
        &quot;topics&quot;: [],
        &quot;description&quot;: &quot;优秀回答者&quot;
      }
  }
</code></pre>
<ul>
<li>identity 官方帐号</li>
<li>best_answerer 优秀回答者<ul>
<li>topics 话题</li>
<li>description 描述信息</li>
</ul>
</li>
</ul>
<h4 id="获取评论列表"><a href="#获取评论列表" class="headerlink" title="获取评论列表"></a>获取评论列表</h4><pre><code>https://zhuanlan.zhihu.com/api/posts/文章slug/comments?limit=数量限制&amp;offset=偏移量
</code></pre><p>这里拼接url的方法和获取文章列表时的方法时一样的，不再赘述。例如获取文章slug为22591792的前30条评论。</p>
<pre><code>https://zhuanlan.zhihu.com/api/posts/22591792/comments?limit=30&amp;offset=0
</code></pre><p>获取到的信息为</p>
<pre><code class="JSON">[
  {
    &quot;content&quot;: &quot;小管家棒棒哒！支持~&quot;,
    &quot;liked&quot;: false,
    &quot;href&quot;: &quot;/api/posts/22591792/comments/169039008&quot;,
    &quot;inReplyToCommentId&quot;: 0,
    &quot;reviewing&quot;: false,
    &quot;author&quot;:
      {
        &quot;profileUrl&quot;: &quot;https://www.zhihu.com/people/fei-xiao-gui&quot;, &quot;bio&quot;: &quot;心中有爱 脚下有风 所以我跑得快~&quot;,
        &quot;hash&quot;: &quot;41cd5c7249081389da3a523b3cb0629b&quot;, &quot;uid&quot;: 28048833380352,
        &quot;isOrg&quot;: false,
        &quot;description&quot;: &quot;品学兼优~&quot;,
        &quot;slug&quot;: &quot;fei-xiao-gui&quot;,
        &quot;avatar&quot;:
          {
            &quot;id&quot;: &quot;a061ebdd61bb57c81b3206dda51418fc&quot;, &quot;template&quot;: &quot;https://pic1.zhimg.com/{id}_{size}.jpg&quot;
          },
        &quot;name&quot;: &quot;菲小桂&quot;
      },
    &quot;createdTime&quot;: &quot;2016-09-23T17:35:54+08:00&quot;,
    &quot;featured&quot;: false,
    &quot;id&quot;: 169039008,
    &quot;likesCount&quot;: 1
  }
]
</code></pre>
<ul>
<li>content: 评论内容</li>
<li>liked: 是否给这条评论点过赞</li>
<li>href: 该条评论的详情地址</li>
<li>inReplyToCommentId: 所回复的评论的id</li>
<li>reviewing: 是否正在被审查中</li>
<li>author: 评论的作者<ul>
<li>profileUrl: 知乎网的个人主页url</li>
<li>bio: 官网信息中的一句话描述</li>
<li>hash: hash值</li>
<li>uid: uid</li>
<li>isOrg: 是否为机构帐号</li>
<li>description: 描述</li>
<li>slug: slug</li>
<li>avatar: 头像信息<ul>
<li>id: id值，在拼接url时用到</li>
<li>template: url拼接模版</li>
</ul>
</li>
<li>name: 作者名称</li>
</ul>
</li>
<li>createdTime: 评论创建时间</li>
<li>featured: ???是否为精彩评论</li>
<li>id: 该条评论的id</li>
<li>likesCount: 获得的赞的数量</li>
</ul>
<p>对他人评论的回复数据有些许的不同，inReplyToCommentId的值不为0，json数据中增加了inReplyToUser字段，内容为author类型。这里不再具体分析。</p>
<h4 id="获取点赞信息"><a href="#获取点赞信息" class="headerlink" title="获取点赞信息"></a>获取点赞信息</h4><pre><code>https://zhuanlan.zhihu.com/api/posts/22591792/likers?limit=获取数量&amp;offset=偏移量
</code></pre><p>例如，获取文章slug为22591792的最新20个点赞的人的信息，author类型。</p>
<pre><code>https://zhuanlan.zhihu.com/api/posts/22591792/likers?limit=20&amp;offset=0
</code></pre><p>url的拼接方法和上面获取文章信息时方法相同，不再赘述。</p>
<p>最后还是放上自己的示例项目地址：<br><a href="https://github.com/TonnyL/zhuanlan" target="_blank" rel="external">知乎专栏Android</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中类成员的初始化]]></title>
      <url>http://tonnyl.github.io/2016/05/12/Java%E4%B8%AD%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>如果一个类的基本成员变量，在没有进行初始化的情况下，那么它的默认值是多少呢？<br><a id="more"></a></p>
<p>在Java中，类的某个成员变量是基本数据类型，即使没有进行初始化，Java也会确保它获得一个默认值。OK, talk is cheap, show me the code:</p>
<pre><code>public class InitialTest {

    private int anInt;
    private long aLong;
    private short aShort;
    private char aChar;
    private float aFloat;
    private double aDouble;
    private boolean aBoolean;
    private byte aByte;
    private InitialTest reference;

    public static void main(String args[]){

        InitialTest initialTest = new InitialTest();
        System.out.println(&quot;Boolean &quot; + initialTest.aBoolean);
        System.out.println(&quot;Byte &quot; + initialTest.aByte);
        System.out.println(&quot;Char &quot; + initialTest.aChar);
        System.out.println(&quot;Short &quot; +initialTest.aShort);
        System.out.println(&quot;Int &quot; + initialTest.anInt);
        System.out.println(&quot;Long &quot; + initialTest.aLong);
        System.out.println(&quot;Float &quot; + initialTest.aFloat);
        System.out.println(&quot;Double &quot; + initialTest.aDouble);
        System.out.print(&quot;Reference &quot; + initialTest.reference);

    }

}
</code></pre><p>我们编写了一个简单的测试类，可以很轻松的看出作用是什么。下面是运行结果</p>
<pre><code>Boolean false
Byte 0
Char  
Short 0
Int 0
Long 0
Float 0.0
Double 0.0
Reference null
</code></pre><p>结果已经很明显了。如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">基本类型</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">‘\u0000’(null)</td>
</tr>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:left">(byte)0</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">(short)0</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">0.0</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">0.0</td>
</tr>
<tr>
<td style="text-align:left">reference</td>
<td style="text-align:left">null</td>
</tr>
</tbody>
</table>
<p>当变量作为类的成员使用时，Java才会确保给定默认值，以确保那些基本成员变量得到初始化(C++中没有此功能),防止程序产生错误。但是，这些初始值对于你的程序可能是不正确的，所以最好明确的对变量进行初始化。</p>
<p>但是上述确保初始化的方法并不适用于“局部变量”(即非类成员)，因此当我把代码改成下面的样子时，IDE就会提示错误了：</p>
<pre><code>public static void main(String args[]){
    InitialTest initialTest = new InitialTest();
    System.out.println(&quot;Boolean &quot; + initialTest.aBoolean);
    System.out.println(&quot;Byte &quot; + initialTest.aByte);
    System.out.println(&quot;Short &quot; +initialTest.aShort);
    System.out.println(&quot;Char &quot; + initialTest.aChar);
    System.out.println(&quot;Int &quot; + initialTest.anInt);
    System.out.println(&quot;Long &quot; + initialTest.aLong);
    System.out.println(&quot;Float &quot; + initialTest.aFloat);
    System.out.println(&quot;Double &quot; + initialTest.aDouble);
    System.out.print(&quot;Reference &quot; + initialTest.reference);
    int i;
    System.out.println(&quot;another int is &quot; + i);
}
</code></pre><p>IDEA提示错误：</p>
<pre><code>Variable &#39;i&#39; might not have been initialized
</code></pre><p>如果不是在IDE中编辑的，那么在编译的时候也会提示你这个错误，告诉你这个变量没有进行初始化。C++编辑器会对未初始化变量给予一个警告，而非错误。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Activity的四种启动模式]]></title>
      <url>http://tonnyl.github.io/2016/05/11/Activity%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>浅析Android中Activity的四种启动模式:standard,singleTop,singleTask,singleInstance<br><a id="more"></a></p>
<p>启动模式一共有上述的四种，可以在AndroidManifest.xml文件中通过给<ctivity>标签指定android:launchMode属性来选择启动模式。</ctivity></p>
<h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>standard是Activity默认的启动模式，在不进行显示指定的情况下，所有Activity都会自动的使用这种模式。Android使用返回栈来管理Activity,在standard模式下，每当启动一个新的Activity,它就会在返回栈中入栈，并处于栈顶的位置。对于使用standard模式的Activity,系统不会在乎这个Activity是否已经在返回栈中，每次启动都会创建一个新的Activity实例。</p>
<p>现在通过实践来体会一下standard模式，首先是新建一个ActivityTest项目，修改MainActivity的onCreate()中代码，如下所示：</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    Log.d(&quot;Mainactivity&quot;,this.toString());

    Button btn1 = (Button) findViewById(R.id.btn1);

    btn1.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Intent intent = new Intent(MainActivity.this,MainActivity.class);
            startActivity(intent);
        }
    });

}
</code></pre><p>代码很简单，在MainActivity的基础上启动MainActivity，从逻辑上讲没什么意义，不过我们在于研究standard模式，因此我们也就不去追究实际的用途了。另外我们还在onCreate()中添加了一句打印日志信息，打印当前Activity的实例。</p>
<p>现在运行程序，然后再MainActivity界面连续点击两次按钮，观察LogCat中打印的日志信息。</p>
<pre><code>MainActivity: com.marktony.applicationtest.MainActivity@5e658bb
MainActivity: com.marktony.applicationtest.MainActivity@cfae411
MainActivity: com.marktony.applicationtest.MainActivity@b0e0bac
</code></pre><p>从打印信息中可以很清楚的看到，每次点击按钮就会创建一个新的MainActivity的实例，此时返回栈中也会存在三个MainActivity的实例，因此想要完全退出应用，必须点击三次返回键。</p>
<h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>在某些情况下，你可能会觉得standard模式不太合理。activity明明已经在栈顶了，为什么再次启动时还要创建一个新的Activity实例呢？这时singleTop模式就派上用场了。当Activity的启动模式被指定为singleTop时，在启动Activity时如果发现返回栈的栈顶已经是该Activity，则可以认为直接使用它，不创建新的实例。</p>
<p>下面看实例,修改AndroidManifest.xml中的MainActivity的启动模式为singleTop:</p>
<pre><code>&lt;activity android:name=&quot;.MainActivity&quot;
    android:launchMode=&quot;singleTop&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre><p>重新运行程序，通过LogCat查看日志信息，我们可以看到已经创建了一个新的Activity实例。</p>
<pre><code>MainActivity: com.marktony.applicationtest.MainActivity@5e658bb
</code></pre><p>之后不管点击多少次按钮，都不会有新的打印信息出现，因为目前Activity已经处于返回栈的栈顶，每当想要再启动一个MainActivity时都会直接使用栈顶的Activity，因此MainActivity也只会有一个实例，仅按一次返回键即可退出程序。</p>
<p>不过当MainActivity不在栈顶时，这是再启动MainActivity，还是会创建新的实例，下面来实验一下。修改MainActivity中的代码，如下所示：</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    Log.d(&quot;MainActivity&quot;,this.toString());

    Button btn1 = (Button) findViewById(R.id.btn1);

    btn1.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Intent intent = new Intent(MainActivity.this,SecondActivity.class);
            startActivity(intent);
        }
    });
}
</code></pre><p>这次我们点击按钮启动的是SecondActivity。然后修改SecondActivity中onCreate()方法中的代码，如下所示：</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_second);

    Button btn2 = (Button) findViewById(R.id.btn2);
    btn2.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Intent intent = new
            Intent(SecondActivity.this,MainActivity.class);
            startActivity(intent);
        }
    });
}
</code></pre><p>我们在SecondActivity中的按钮的点击事件中又加入了启动MainActivity的代码。现在重新运行程序，在MainActivity界面点击按钮进入SecondActivity，然后在SecondActivity界面点击按钮，又会重新进入到MainActivity。查看LogCat中的信息：</p>
<pre><code>MainActivity: com.marktony.applicationtest.MainActivity@eb60bcf
SecondActivity: com.marktony.applicationtest.SecondActivity@5cf7342
MainActivity: com.marktony.applicationtest.MainActivity@a360333
</code></pre><p>可以看到系统创建了两个不同的MainActivity,这是由于在SecondActivity中再次启动Activity时，栈顶的Activity已经变成了SecondActivity，因此会新建一个新的MainActivity。现在按下back键就会返回到SecondActivity,再次按下back键，又会回到MainActivity,再按一次back键才会退出程序。</p>
<h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>使用singleTask模式可以很好的解决重复创建栈顶Activity的问题，但是正如你看到的，如果该Activity并没有处于栈顶的位置，还是可能创建多个Activity实例的。那么有没有方法可以让Activity在整个应用程序的上下文中指存在一个实例呢？<br>这就要借助singleTask模式来实现了。当Activity的启动模式指定为singleTask，每次启动该Activity时系统首先会在返回栈中检查是否存在该Activity的实例，如果发现已经存在则直接使用该实例，并把在这个Activity之上的所有Activity统统出栈，如果没有发现就会创建一个新的实例。<br>下面通过代码来直观的理解一下。修改AndroidManifest.xml文件中MainActivity的启动模式：</p>
<pre><code>&lt;activity android:name=&quot;.MainActivity&quot;
    android:launchMode=&quot;singleTask&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre><p>然后在MainActivity中添加onRestart()方法，并打印日志：</p>
<pre><code>@Override
protected void onRestart() {
    super.onRestart();
    Log.d(&quot;MainActivity&quot;,&quot;onStart&quot;);
}
</code></pre><p>最后在SecondActivity中添加onDestroy()方法，并打印日志：</p>
<pre><code>@Override
protected void onDestroy() {
    super.onDestroy();
    Log.d(&quot;SecondActivity&quot;,&quot;onDestroy&quot;);
}
</code></pre><p>现在重新运行程序，在MainActivity界面点击按钮进入SecondActivity，然后在SecondActivity界面点按钮，又会重新进入到MainActivity。查看LogCat中的日志信息：</p>
<pre><code>MainActivity: com.marktony.applicationtest.MainActivity@f2c42cf
SecondActivity: com.marktony.applicationtest.SecondActivity@81ea653
MainActivity: onStart
SecondActivity: onDestroy
</code></pre><p>从打印信息中可以看出，在SecondActivity中启动MainActivity时，会发现返回栈里已经存在一个MainActivity的实例，并且是在SecondActivity的下面，于是SecondActivity会从返回栈中出栈，而MainActivity重新成为了栈顶Activity，因此MainActivity的onRestart()方法和SecondActivity的onDestroy()方法会得到执行。现在返回栈中只剩下一个MainActivity的实例了，按一下back键就可以退出程序。</p>
<h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>singleInstance应该是四种启动模式中最特殊也最复杂的一种了。不同于以上三种启动模式，指定为singleInstance的Activity会启用一个新的返回栈来管理这个Activity(其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈)。那么这么做有什么意义呢？假设我们的程序中有一个Activity是允许其他程序调用的，如果我们想实现其他程序和我们的程序可以共享这个Activity的实例，应该如何实现呢？使用前面三种启动模式肯定是无法实现的，因为每个程序都会有自己的返回栈，同一个Activity在不同的返回栈中入栈时必然是创建新的实例。而使用singleInstance模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个Activity，不管是那个应用程序来访问这个Activity，都共用的同一个返回栈，也就解决了共享Activity实例的问题。</p>
<p>OK,talk is cheap,show me the code,我们还是来实践一下。修改AndroidManifest.xml中SecondActivity的启动模式:</p>
<pre><code>&lt;activity android:name=&quot;.SecondActivity&quot;
    android:launchMode=&quot;singleInstance&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.marktony.applicatiointest.ACTION_START&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
        &lt;category android:name=&quot;com.marktony.applicationtest.MY_CATEGORY&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre><p>我们先将SecondActivity的启动模式指定为singleInstance，然后修改MainActivity中onCreate()方法的代码:</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    Log.d(&quot;MainActivity&quot;,&quot;task id is &quot; + getTaskId());

    Button btn1 = (Button) findViewById(R.id.btn1);
    btn1.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Intent intent = new Intent(MainActivity.this,SecondActivity.class);
            startActivity(intent);
        }
    });

}
</code></pre><p>在onCreate()方法中打印了当前返回栈的id。然后修改SecondActivity中onCreate()方法的代码：</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_second);

    Log.d(&quot;SecondActivity&quot;,&quot;task id is &quot; + getTaskId());

    Button btn2 = (Button) findViewById(R.id.btn2);
    btn2.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Intent intent = new Intent(SecondActivity.this,ThirdActivity.class);
            startActivity(intent);
        }
    });
}
</code></pre><p>同样在onCreate()方法中打印了当前返回栈的id，然后又修改了按钮点击事件的代码，用于启动ThirdActivity。最后修改ThirdActivity中onCreate()方法的代码：</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_third);

    Log.d(&quot;ThirdActivity&quot;,&quot;task id is &quot; + getTaskId());
}
</code></pre><p>仍然是在onCreate()方法中打印了当前返回栈的id。现在重新运行程序，在MainActivity界面中点击按钮进入到SecondActivity，然后在SecondActivity中点击按钮进入到ThirdActivity。查看LogCat中的打印信息：</p>
<pre><code>MainActivity: task id is 403
SecondActivity: task id is 404
ThirdActivity: task id is 403
</code></pre><p>可以看到，SecondActivity的task id不同于MainActivity和ThirdActivity，这说明SecondActivity确实是存放在一个单独的返回栈中的，而且这个栈中只有SecondActivity这一个Activity。</p>
<p>然后我们按下back键进行返回，你会发现ThirdActivity竟然返回了MainActivity，再按下back键又会返回到SecondActivity，再按下返回键会退出程序，这是为什么呢？<br>其实原理很简单，由于MainActivity和ThirdActivity是存放在同一个返回栈里的，当在ThirdActivity的界面按下返回键，ThirdActivity会从返回栈中出栈，那么MainActivity就成为了栈顶Activity显示在界面上，因此也就出现了从ThirdActivity直接返回到MainActivity的情况。然后在MainActivity再次按下返回键，这是当前的返回栈已经空了，于是就显示了另一个返回栈的栈顶Activity，及SecondActivity。最后再次按下back键，这是所有的返回栈均被清空了，也就自然的退出了程序。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[进程与线程]]></title>
      <url>http://tonnyl.github.io/2016/05/02/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="进程与线程之间的关系"><a href="#进程与线程之间的关系" class="headerlink" title="进程与线程之间的关系"></a>进程与线程之间的关系</h2><a id="more"></a>
<h4 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h4><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的独立单位。进程拥有一个完整的虚拟空间地址，并不依赖线程而独立存在。</p>
<h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><p>线程是进程的一个实体，是cpu调度和分配的基本单位。它是进程更小的能独立运行的基本单位。线程本身并不拥有系统资源，运行是只是暂用一些计数器、寄存器和栈。</p>
<h4 id="进程与线程之间的关系-1"><a href="#进程与线程之间的关系-1" class="headerlink" title="进程与线程之间的关系"></a>进程与线程之间的关系</h4><p>简单来说，一个程序至少拥有一个进程，而一个进程至少拥有一个线程。<br>一个线程可以创建和撤销另外一个线程，同一个进程中可以有多个线程并发的执行。</p>
<p>线程更加接近于执行体的概念，它可以同进程中的其他线程共享数据，但是拥有独立的栈空间，拥有独立的执行序列。</p>
<h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h4><p>进程与线程的主要区别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃之后，在保护模式对其他进程没有影响，线程只是进程的不同执行路径。线程有自己独立的堆栈和局部变量，但是没有独立的地址空间，一个线程死掉那么整个进程也就死掉了，所以多进程的应用要比多线程的应用更加健壮。但是进程在切换时耗费的资源也比较多，效率也要更差，所以在并发性要求高又要共享变量数据，只能靠线程，而不是进程。</p>
<p>在执行过程中，每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多线程执行控制。</p>
<p>从逻辑上看，多线程的意义在于在一个应用程序当中，有多个执行部分可以同时执行。但是操作系统并没有将多个线程看作多个独立的应用，来实现进程的调度和管理以及资源分配。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ANR]]></title>
      <url>http://tonnyl.github.io/2016/05/01/ANR/</url>
      <content type="html"><![CDATA[<p>浅谈Android开发中的ANR现象<br><a id="more"></a></p>
<h3 id="什么是ANR"><a href="#什么是ANR" class="headerlink" title="什么是ANR"></a>什么是ANR</h3><p>ANR,Application Not Responding,即程序未响应。发生ANR时，系统会显示一个dialog，提示用户出现了ANR，用户可以选择“等待”，或者是“强制关闭”，结束应用。ANR同崩溃一样，是在开发过程中应该避免的。</p>
<h3 id="什么会触发ANR："><a href="#什么会触发ANR：" class="headerlink" title="什么会触发ANR："></a>什么会触发ANR：</h3><ul>
<li>主线程被IO操作阻塞。（文档中特别强调:<strong>you should not perform the work on the UI thread(不要在UI线程中进行IO操作)</strong>）。</li>
<li>主线程中存在耗时的操作。</li>
<li>主线程中错误操作。如Thread.wait()或Thread.sleep()等。</li>
</ul>
<p>在Android中，应用程序的响应是受到Activity Manager 和 Window Manageer系统服务的。一旦出现以下情况，Android系统就会展示dialog：</p>
<ul>
<li>5秒内没有相应触摸操作。(No response to an input event (such as key press or screen touch events) within 5 seconds.)</li>
<li>广播接收器在10内没有执行完成。(A BroadcastReceiver hasn’t finished executing within 10 seconds.)</li>
</ul>
<h3 id="怎样避免ANR"><a href="#怎样避免ANR" class="headerlink" title="怎样避免ANR"></a>怎样避免ANR</h3><p>Android应用通常是完全运行在UI线程(<code>UI Thread</code>)或者说主线程(<code>Main Thread</code>)中。也就是说，你在UI线程中进行的任何长耗时操作都有可能触发ANR。因此，在主线程中的任何操作都应该尽可能快的完成。</p>
<ul>
<li>在Activity生命周期中的关键方法，例如onCreate()和onResume()中，完成尽可能少的工作。</li>
<li>使用AsyncTask处理耗时操作(网络请求和数据操作等。)</li>
<li>如果使用了Thread或者HandlerThread,确保主线程不会在等待工作线程完成时被阻塞，也就是不会触发Thread.wait()或Thread.sleep()，应该使用Handler处理工作线程的结果。</li>
<li>在BroadcastReceiver中完成那些小而散(small,discrete)的工作，而不是那些长耗时操作或计算的工作，如果需要，应该交给IntentService去完成。</li>
</ul>
<h3 id="技巧提高"><a href="#技巧提高" class="headerlink" title="技巧提高"></a>技巧提高</h3><p>通常，100至200ms是用户认为应用运行缓慢的阀值。下面是一些额外的tips，可以使应用避免ANR和及时响应用户：</p>
<ul>
<li>如果应用正在后台处理用户的输入，那么，处理的进度应该告知用户处理的进度。可以在UI中使用 <strong>ProgressBar</strong>。</li>
<li>特别的，如果是游戏应用的话，计算工作应该在工作进程(Worker thread)中完成。</li>
<li>如果在初始化中需要进行耗时操作，可以考虑使用欢迎页(splash screen)或者提示用户正在尽快加载，同时显示加载进度信息。这样，用户才不会认为你的应用停滞了(frozen)、</li>
<li>使用Systrace和Traceview来定位应用中响应用户的瓶颈的位置。</li>
</ul>
<p>文档地址：<a href="!http://developer.android.com/training/articles/perf-anr.html">Android Developer</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[知乎小报开发总结]]></title>
      <url>http://tonnyl.github.io/2016/04/28/zhihudaily/</url>
      <content type="html"><![CDATA[<p>总结在开发知乎小报的过程中遇到的问题和相应的解决方法,以及分享开发过程中的一些心得体会<br><a id="more"></a></p>
<h2 id="知乎小报开发总结"><a href="#知乎小报开发总结" class="headerlink" title="知乎小报开发总结"></a>知乎小报开发总结</h2><p>总结在知乎小报开发的工程中遇到的问题以及相关的解决办法。</p>
<p>1.Intent导致的ActivityNotFoundException</p>
<p>无法找到对应的activity，这个异常在使用Intent启动一些系统级隐式的activity时可能会出现，例如短信、邮件、打开相机等，（还有手机没有邮件、短信app？当然有了！）如果不对这个异常进行处理的话，应用就会直接Crash。</p>
<pre><code>Uri uri = Uri.parse(&quot;market://details?id=&quot;+getPackageName());
Intent intent = new Intent(Intent.ACTION_VIEW,uri);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
startActivity(intent);
</code></pre><p>这个异常在开发简单翻译的过程就曾经遇到过。</p>
<ul>
<li><p>方法1: 最佳解决方案–&gt;在发出这个隐式Intent之前调用resolveActivity做检查</p>
<pre><code>Intent intent = new Intent(Intent.ACTION_XXX);
ComponentName componentName = intent.resolveActivity(getPackageManager());
if(componentName != null) {
String className = componentName.getClassName();
}
</code></pre></li>
<li><p>方法2：使用try-catch捕获这个异常。</p>
<pre><code>try{
// to start a mail activity code
} catch (android.content.ActivityNotFoundException ex){
// catch Exception
Snackbar.make(view, &quot;No mail app found&quot;,Snackbar.LENGTH_SHORT).show();
}
</code></pre></li>
</ul>
<p>2.WebView无图模式的实现</p>
<p>Android WebView中实现了一个方法</p>
<pre><code>webView.getSettings().setBlockNetworkImage(boolean config)
</code></pre><p>官方文档解释为：</p>
<pre><code>Gets whether the WebView does not load image resources from the network.
</code></pre><p>当config为true时，不加载图片，反之加载图片，而且是当url加载完成时才开始加载。</p>
<p>3.接口实现RecyclerView item的点击事件<br>RecyclerView是Google在v7包中新增的一种控件，用于代替ListView,不过它并没有基本的点击事件，所以需要我们自己为item定义点击事件。</p>
<p>首先需要自定义接口</p>
<pre><code>public interface OnRecyclerViewOnClickListener {
    void OnItemClick(View v,int position);
}
</code></pre><p>在适配器中定义接口变量</p>
<pre><code>private OnRecyclerViewOnClickListener mListener;
</code></pre><p>暴露接口</p>
<pre><code>public void setItemClickListener(OnRecyclerViewOnClickListener listener){
    this.mListener = listener;
}
</code></pre><p>然后在onCreateViewHolder中注册点击事件</p>
<pre><code>@Override
public LatestItemViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    View view = inflater.inflate(R.layout.latest_item_layout,parent,false);
    LatestItemViewHolder holder = new LatestItemViewHolder(view,mListener);
    return holder;
}
</code></pre><p>在ViewHolder中设置</p>
<pre><code>public class LatestItemViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener {
    private OnRecyclerViewOnClickListener listener;
    private CardView item;

    public LatestItemViewHolder(View itemView,OnRecyclerViewOnClickListener listener) {
        super(itemView);

        item = (CardView) itemView.findViewById(R.id.card_view_item);
        this.listener = listener;
        itemView.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        if (listener != null){
            listener.OnItemClick(v,getLayoutPosition());
        }
    }
}
</code></pre><p>在Activity或者Fragment中使用</p>
<pre><code>adapter = new LatestPostAdapter(getActivity(),list);
rvLatestNews.setAdapter(adapter);
adapter.setItemClickListener(new OnRecyclerViewOnClickListener() {
    @Override
    public void OnItemClick(View v, int position) {
        // write code
    }
});
</code></pre><p>4.横屏下Crash<br>由于在fragment中使用了RecyclerView，当然也就涉及到了Adapoter的使用。由于我在Adapter的构造函数中传入了Context,这直接导致了横屏下直接崩溃。</p>
<pre><code>public class LatestPostAdapter extends RecyclerView.Adapter&lt;LatestPostAdapter.LatestItemViewHolder&gt; {
// some code
public LatestPostAdapter(Context context, List&lt;LatestPost&gt; list){
      this.context = context;
      this.list = list;
      this.inflater = LayoutInflater.from(context);
  }
}
</code></pre><p>我们不应该保存那些依赖Activity的数据，比如Drawable，Adapter，View或者任何与Context相关联的数据。因为上一个Activity已经没有了，如果你还要保持这些资源的引用，可能导致资源泄露。</p>
<p>解决的方法</p>
<ul>
<li>1.简单粗暴型 直接禁止横屏，当然这只是适用于极少数的情况。可以在manifest文件中对应的activity配置：</li>
</ul>
<pre><code class="xml">android:screenOrientation=&quot;portrait&quot;
android:screenOrientation=&quot;landscape&quot;
</code></pre>
<p>或者在Java代码中处理</p>
<pre><code>setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);  
</code></pre><ul>
<li><p>2.在横屏时做相应的处理。<br>首先在manifest.xml文件中配置屏幕方向改变时不需要重新载入。</p>
  <!--configChanges参数的作用是不让activity重启
  3.2之前的sdk只需要配置前面两个值:keyboardHidden|orientation
  3.2之后的sdk必须配置三个值keyboardHidden|orientation|screensize
  -->
  <activity android:name=".UI.Activities.MainActivity" android:label="@string/app_name" android:configchanges="keyboardHidden|orientation|screenSize" android:theme="@style/AppTheme.NoActionBar">

</activity></li>
</ul>
<p>然后在activity中重写方法</p>
<pre><code>@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
}
</code></pre><p>5.toolbar中小箭头(返回上级activity)<br>好吧，这是个不算高级的问题，但是确实困扰了我一段时间。首先是怎样显示这个箭头。</p>
<pre><code>private Toolbar toolbar;
toolbar = (Toolbar) findViewById(R.id.toolbar);
setSupportActionBar(toolbar);
// 关键
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
</code></pre><p>怎样监听小箭头的点击事件呢？</p>
<p>由于箭头是位于toolbar中的控件，可以联想到应该是和onOptionsItemSelected方法有关。</p>
<pre><code>@Override
public boolean onOptionsItemSelected(MenuItem item) {

   int id = item.getItemId();

   // 小箭头的id为android.R.id.home
   if (id == android.R.id.home){
       onBackPressed();
   }

   return super.onOptionsItemSelected(item);
 }
</code></pre>]]></content>
    </entry>
    
  
  
</search>
